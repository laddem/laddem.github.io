<<<<<<< HEAD
[{"authors":null,"categories":null,"content":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://laddem.github.io/author/laddem/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/laddem/","section":"authors","summary":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.","tags":null,"title":"LADDEM","type":"authors"},{"authors":null,"categories":null,"content":"\r\r Table of Contents\r O que você vai aprender O curso Programação Instrutores Links úteis  \r\rO que você vai aprender  A filosofia de design por trás de um dos pacotes mais populares no R Importação, Manipulação e Visualização de dados na prática tidyr, dplyr, ggplot2 e vários outros pacotes para simplificar sua rotina de análise de dados  O curso Uma semana, com aulas à noite, no formato workshop, com muitos exercícios para praticar e pegar o jeito.\nProgramação \rreadr, tibble e tidyr\rUm modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\n\r\rstringr, forcats e dplyr\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\n\r\rggplot2\rO pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.\n\r\rpurrr\rO autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.\n\r\rSoluções\rSoluções dos exercícios\n\r\rInstrutores Vinícius de Souza Maia\nNatália Martins Arruda\nLinks úteis Ciência de dados em R\nR for Data Science\n","date":1621728000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1621728000,"objectID":"02eadce3bea228c4a3968729e322add5","permalink":"https://laddem.github.io/courses/tidyverse/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/","section":"courses","summary":"Aprenda a utilizar o tidyverse nas suas análises de dados.","tags":null,"title":"📊 Aprenda a utilizar o tidyverse","type":"book"},{"authors":null,"categories":null,"content":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\nEla acaba sendo um ponto de partida interessante porque contextualiza a maioria dos pacotes que vamos utilizar. O readr é uma maneira de facilitar e tornar mais rápida a importação de dados em formatos comuns, como o texto delimitado por separadores e o formato colunado com larguras-fixas utilizado pelo IBGE.\nA tibble é uma proposta de modernização para o data.frame, aproveitando a estrutura flexível e poderosa, mas mudando certas convenções, como a conversão de strings para fatores, permitindo a criação de colunas de listas, utilização de nomes mais complexos para colunas, etc.\nO tidyr é uma forma de reformatar (reshape) bancos de dados que vêm em formatos que dificultam seu processamento, permitindo que o analista facilmente reconfigure a informação para o formato mais adequado. Ele é o primeiro pacote que veremos sobre a parte de \u0026ldquo;cozinha\u0026rdquo; dos dados, no qual é preciso processar o dado bruto para torná-lo passível de análise.\nO mesmo pode ser dito para os outros pacotes que veremos nos próximos dias. Cada um deles foi pensado para resolver um problema ou facilitar uma rotina de trabalho relacionada com um dos passos descritos acima.\nProgramação literária Vários dos conceitos que guiam o design do tidyverse são orientados por uma certa filosofia. Esta filosofia dita que a principal preocupação por trás de um programa não é que ele funcione. Eventualmente e com um pouco de persistência, é quase sempre possível chegar a uma solução técnica adequada. A principal questão é que o programa é uma ferramenta de comunicação com outras pessoas que o lerão, seja seus colegas, colaboradores, alunos ou você mesmo, daqui a 2 anos, quando lembrar que você já escreveu um programa para aquela tarefa. Trago aqui alguns trechos de Literate Programming, de Donald Knuth (1984), traduzidos livremente por este que vos fala:\n Creio que chegou a hora de melhorar significativamente a documentação dos programas, e que podemos atingir este objetivo tratando programas como obras literárias. Por isso o título: \u0026ldquo;Programação Literária\u0026rdquo;. Abandonemos os velhos hábitos de construir programas: ao invés de imaginar que nossa tarefa principal é instruir um computador sobre o que deve ser feito, concentremo-nos em explicar aos seres humanos o que queremos que o computador faça. O praticante da programação literária pode ser visto como um ensaísta, cuja principal preocupação é com a clareza da exposição e a excelência no estilo. Tal autor, com um dicionário na mão, escolhe os nomes das variáveis com cuidado e explica claramente seu significado. Ele ou ela esmera por um programa que é compreensível porque seus conceitos foram introduzidos na melhor ordem possível para o entendimento humano, utilizando uma mistura de métodos formais e informais que se complementam.\n Assim, várias das escolhas feitas na construção de tidyverse procuram reforçar essa característica de interpretabilidade dos programas, como a ordem lógica das operações com o pipe (%\u0026gt;%), funções com nomes mais longos e semânticos, a utilização de uma função específica para cada tarefa, ao invés da adaptação de funções genéricas para uma grande variedade de tarefas. O propósito de um código escrito como tidyverse é que, no limite, a própria síntaxe do código funcione como parte da documentação do programa.\nO mistério do pipe: %\u0026gt;% Usuários de longa data do R já podem ter encontrado no mato esse animal estranho e podem ter ficado confusos com seu significado. O pipe é de origem humilde e nasceu nos sistemas Unix há muitas décadas atrás. Seu objetivo é muito simples: e se você tiver uma sequência de computações em que cada uma recebe o resultado daquela feita anteriormente? Claro que você poderia fazer:\nx \u0026lt;- 1:10\ry \u0026lt;- diff(x)\rmean(y)\r ## [1] 1\r Mas não seria interessante pular os objetos intermediários e ir direto ao ponto? O pipe vem do pacote magrittr, mas ele vêm carregado em quase todos os pacotes do tidyverse. Vamos carregar logo o tibble.\n# Para ter acesso ao pipe, basta carregar um pacote do tidyverse, como tibble, dplyr, tidyr, etc.\r# Vamos carregar o tibble agora\rlibrary(tibble)\rx %\u0026gt;% diff() %\u0026gt;% mean()\r ## [1] 1\r Vejamos um exemplo mais real, quantos artistas existem no dataset billboard? Podemos usar unique e length para descobrir.\nx \u0026lt;- unique(tidyr::billboard$artist)\rlength(x)\r ## [1] 228\r Mas com %\u0026gt;% fica bem melhor:\ntidyr::billboard %\u0026gt;% .$artist %\u0026gt;% unique() %\u0026gt;% length()\r ## [1] 228\r Ok, mas como ele funciona? É simples, o pipe carrega o objeto a sua esquerda num ponto . invisível que é automaticamente passado como o primeiro argumento da função à direita.\nx \u0026lt;- 1:10\rmean(x)\r ## [1] 5.5\r x %\u0026gt;% mean()\r ## [1] 5.5\r OK, mas e se meu argumento não for o primeiro, ainda posso usar pipe? Pode! É só usar explicitamente um ponto no lugar onde você quer aproveitar o efeito:\niris %\u0026gt;% boxplot(Sepal.Length ~ Species, data = .)\r O ponto . depois de data indica indica que ali deve ser colocado o iris. O pipe é uma peça chave de muitas funções do tidyverse, não porque ele seja obrigatório, mas sim porque ele permite expressar sequências de operações numa ordem mais lógica, do tipo: \u0026ldquo;Primeiro faça a, então b, então c, \u0026hellip; \u0026ldquo;, ao contrário da forma como isto é geralmente feito usando parênteses para precedência.\n# Compare\rmean(diff(1:10))\r ## [1] 1\r 1:10 %\u0026gt;% diff %\u0026gt;% mean\r ## [1] 1\r E assim fica desmistificado o mistério do pipe! Um último pulo do gato: pelo amor de deus ninguém digita Shift + %, \u0026gt;, Shift + %, basta usar o atalho: Ctrl + Shift + M que ele põe um pipe separado por espaços %\u0026gt;%.\nreadr Usuários do R provavelmente vão estar familiarizados com os nossos leitores de arquivos mais comuns: read.table e read.csv. Talvez muitos de vocês já até memorizaram alguns dos argumentos mais comuns. Não é o caso aqui de revisitar esta função, mas o readr tem muitos paralelos com elas, porque é pensado como uma nova versão da mesma coisa.\n# Comecemos carregando o readr\rlibrary(readr)\r Debaixo do capô O readr, como as funções de leitura do base é uma coleção de parsers, que transformam texto em objetos R com o tipo desejado.\nparse_number(c(\u0026quot;1\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;38\u0026quot;))\r ## [1] 1 20 38\r parse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;ma\u0026lt;e7\u0026gt;\u0026lt;e3\u0026gt;\u0026quot; \u0026quot;p\u0026lt;ea\u0026gt;ra\u0026quot;\r # Note os acentos e caracteres especiais\rparse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;), locale = locale(encoding = \u0026quot;Windows-1252\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;maçã\u0026quot; \u0026quot;pêra\u0026quot;\r parse_logical(c(\u0026quot;true\u0026quot;, \u0026quot;false\u0026quot;, \u0026quot;true\u0026quot;))\r ## [1] TRUE FALSE TRUE\r Em geral, a gente não precisa descer tanto o nível, a gente vai trabalhar mesmo é com os leitores de dados \u0026ldquo;retangulares\u0026rdquo;. Como os do base, eles são read_csv, read_table, etc. Vamos trabalhar com bancos de dados que já vêm no pacote, para facilitar o processo.\n# Lista os datasets que vem no pacote\rreadr_example()\r ## [1] \u0026quot;challenge.csv\u0026quot; \u0026quot;epa78.txt\u0026quot; \u0026quot;example.log\u0026quot; ## [4] \u0026quot;fwf-sample.txt\u0026quot; \u0026quot;massey-rating.txt\u0026quot; \u0026quot;mtcars.csv\u0026quot; ## [7] \u0026quot;mtcars.csv.bz2\u0026quot; \u0026quot;mtcars.csv.zip\u0026quot;\r Uma coisa que gosto de fazer é olhar como o arquivo está organizado antes de tentar abrí-lo. Muitos de vocês podem fazer isso com readLines. Ela ganhou sua versão no pacote com read_lines.\n# Vamos tentar abrir massey-rating.txt\rread_lines(readr_example(\u0026quot;massey-rating.txt\u0026quot;), n_max = 10)\r ## [1] \u0026quot;UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf\u0026quot; ## [2] \u0026quot; 1 1 1 1 1 1 1 1 1 1 1 Ohio St B10 \u0026quot;\r## [3] \u0026quot; 2 2 2 2 2 2 2 2 4 2 2 Oregon P12 \u0026quot;\r## [4] \u0026quot; 3 4 3 4 3 4 3 4 2 3 3 Alabama SEC \u0026quot;\r## [5] \u0026quot; 4 3 4 3 4 3 5 3 3 4 4 TCU B12 \u0026quot;\r## [6] \u0026quot; 6 6 6 5 5 7 6 5 6 11 5 Michigan St B10 \u0026quot;\r## [7] \u0026quot; 7 7 7 6 7 6 11 8 7 8 6 Georgia SEC \u0026quot;\r## [8] \u0026quot; 5 5 5 7 6 8 4 6 5 5 7 Florida St ACC \u0026quot;\r## [9] \u0026quot; 8 8 9 9 10 5 7 7 10 7 8 Baylor B12 \u0026quot;\r## [10] \u0026quot; 9 11 8 13 11 11 12 9 14 9 9 Georgia Tech ACC \u0026quot;\r # Identificando o separador, escolho a função adequada\rread_table(readr_example(\u0026quot;massey-rating.txt\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## UCC = col_double(),\r## PAY = col_double(),\r## LAZ = col_double(),\r## KPK = col_double(),\r## RT = col_double(),\r## COF = col_double(),\r## BIH = col_double(),\r## DII = col_double(),\r## ENG = col_double(),\r## ACU = col_double(),\r## Rank = col_double(),\r## Team = col_character(),\r## Conf = col_character()\r## )\r ## # A tibble: 10 x 13\r## UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf ## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 1 1 1 1 1 1 1 1 1 1 Ohio~ B10 ## 2 2 2 2 2 2 2 2 2 4 2 2 Oreg~ P12 ## 3 3 4 3 4 3 4 3 4 2 3 3 Alab~ SEC ## 4 4 3 4 3 4 3 5 3 3 4 4 TCU B12 ## 5 6 6 6 5 5 7 6 5 6 11 5 Mich~ B10 ## 6 7 7 7 6 7 6 11 8 7 8 6 Geor~ SEC ## 7 5 5 5 7 6 8 4 6 5 5 7 Flor~ ACC ## 8 8 8 9 9 10 5 7 7 10 7 8 Bayl~ B12 ## 9 9 11 8 13 11 11 12 9 14 9 9 Geor~ ACC ## 10 13 10 13 11 8 9 10 11 9 10 10 Miss~ SEC\r Como identifiquei que as colunas estavam separadas por espaços, utilizei read_table cujo delimitador é o espaço \u0026quot; \u0026quot;.\nA segunda feature mais interessante do readr, é uma interface para selecionar os tipos de colunas que serão importadas. Vejamos o seguinte exemplo.\n# Vamos abrir mtcars.csv\rread_lines(readr_example(\u0026quot;mtcars.csv\u0026quot;), n_max = 10)\r ## [1] \u0026quot;\\\u0026quot;mpg\\\u0026quot;,\\\u0026quot;cyl\\\u0026quot;,\\\u0026quot;disp\\\u0026quot;,\\\u0026quot;hp\\\u0026quot;,\\\u0026quot;drat\\\u0026quot;,\\\u0026quot;wt\\\u0026quot;,\\\u0026quot;qsec\\\u0026quot;,\\\u0026quot;vs\\\u0026quot;,\\\u0026quot;am\\\u0026quot;,\\\u0026quot;gear\\\u0026quot;,\\\u0026quot;carb\\\u0026quot;\u0026quot;\r## [2] \u0026quot;21,6,160,110,3.9,2.62,16.46,0,1,4,4\u0026quot; ## [3] \u0026quot;21,6,160,110,3.9,2.875,17.02,0,1,4,4\u0026quot; ## [4] \u0026quot;22.8,4,108,93,3.85,2.32,18.61,1,1,4,1\u0026quot; ## [5] \u0026quot;21.4,6,258,110,3.08,3.215,19.44,1,0,3,1\u0026quot; ## [6] \u0026quot;18.7,8,360,175,3.15,3.44,17.02,0,0,3,2\u0026quot; ## [7] \u0026quot;18.1,6,225,105,2.76,3.46,20.22,1,0,3,1\u0026quot; ## [8] \u0026quot;14.3,8,360,245,3.21,3.57,15.84,0,0,3,4\u0026quot; ## [9] \u0026quot;24.4,4,146.7,62,3.69,3.19,20,1,0,4,2\u0026quot; ## [10] \u0026quot;22.8,4,140.8,95,3.92,3.15,22.9,1,0,4,2\u0026quot;\r # Identificamos o separador de colunas, selecionamos a função adequada\rread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r O console nos mostra que a leitura do banco foi completada, mas também mostra Column Specification. Isto indica qual o tipo de dado que foi identificado automaticamente numa análise feita pela função guess_parser. Em diversos casos, nós podemos querer identificar manualmente as colunas. Vejamos um exemplo:\n# Vamos identificar as colunas com spec\rspec_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r # Copia e cola, modifica as colunas que queremos alterar\rspec_cols \u0026lt;- cols(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\rdisp = col_double(),\rhp = col_double(),\rdrat = col_double(),\rwt = col_double(),\rqsec = col_double(),\rvs = col_double(),\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols)\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r # Para importar apenas colunas selecionadas, utilize 'cols_only()'\rspec_cols2 \u0026lt;- cols_only(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf2 \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols2)\rdf2\r ## # A tibble: 32 x 5\r## mpg cyl am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 1 4 4\r## 2 21 6 1 4 4\r## 3 22.8 4 1 4 1\r## 4 21.4 6 0 3 1\r## 5 18.7 8 0 3 2\r## 6 18.1 6 0 3 1\r## 7 14.3 8 0 3 4\r## 8 24.4 4 0 4 2\r## 9 22.8 4 0 4 2\r## 10 19.2 6 0 4 4\r## # ... with 22 more rows\r # Para indicar os tipos de colunas de um jeito mais sucinto, utilize uma string:\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = \u0026quot;dfddddddfdd\u0026quot;)\r# Só cuidado pra não perder a conta dos ds!\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nmeu_locale \u0026lt;- locale(encoding = \u0026quot;UTF-8\u0026quot;, decimal_mark = \u0026quot;,\u0026quot;, grouping_mark = \u0026quot;.\u0026quot;)\r Aí é só passar isso pra uma das funções do pacote sob o argumento locale\nread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), locale = meu_locale)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_number(),\r## cyl = col_double(),\r## disp = col_number(),\r## hp = col_double(),\r## drat = col_number(),\r## wt = col_number(),\r## qsec = col_number(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 39 262 1646 0 1 4 4\r## 2 21 6 160 110 39 2875 1702 0 1 4 4\r## 3 228 4 108 93 385 232 1861 1 1 4 1\r## 4 214 6 258 110 308 3215 1944 1 0 3 1\r## 5 187 8 360 175 315 344 1702 0 0 3 2\r## 6 181 6 225 105 276 346 2022 1 0 3 1\r## 7 143 8 360 245 321 357 1584 0 0 3 4\r## 8 244 4 1467 62 369 319 20 1 0 4 2\r## 9 228 4 1408 95 392 315 229 1 0 4 2\r## 10 192 6 1676 123 392 344 183 1 0 4 4\r## # ... with 22 more rows\r Existe ainda a possibilidade de ler dados colunados com largura-fixa. readr implementa quatro funções diferentes para ajudar na construção do dicionário:\n# Nossos dados\rx \u0026lt;- readr_example(\u0026quot;fwf-sample.txt\u0026quot;)\rread_lines(x, n_max = 10)\r ## [1] \u0026quot;John Smith WA 418-Y11-4111\u0026quot;\r## [2] \u0026quot;Mary Hartford CA 319-Z19-4341\u0026quot;\r## [3] \u0026quot;Evan Nolan IL 219-532-c301\u0026quot;\r # separados por espaço\rdic1 \u0026lt;- fwf_empty(x)\rdic1\r ## $begin\r## [1] 0 5 20 30\r## ## $end\r## [1] 4 13 22 NA\r## ## $skip\r## [1] 0\r## ## $col_names\r## [1] \u0026quot;X1\u0026quot; \u0026quot;X2\u0026quot; \u0026quot;X3\u0026quot; \u0026quot;X4\u0026quot;\r df \u0026lt;- read_fwf(file = x, col_positions = dic1)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character(),\r## X4 = col_character()\r## )\r df\r ## # A tibble: 3 x 4\r## X1 X2 X3 X4 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando a largura da coluna\rlarguras \u0026lt;- c(20, 10, 12)\rdic2 \u0026lt;- fwf_widths(larguras)\rdic2\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 30 X2 ## 3 30 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic2)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando onde cada coluna começa e termina\rcomeca \u0026lt;- c(1, 21, 30)\rtermina \u0026lt;- c(20, 29, 42)\rdic3 \u0026lt;- fwf_positions(comeca, termina)\rdic3\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 29 X2 ## 3 29 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic3)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando pares nome-valor\rdic4 \u0026lt;- fwf_cols(\rnome = c(1, 20),\ruf = c(21, 29),\rnumero = c(30, 42))\rdic4\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 nome ## 2 20 29 uf ## 3 29 42 numero\r df \u0026lt;- read_fwf(file = x, col_positions = dic4)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## nome = col_character(),\r## uf = col_character(),\r## numero = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## nome uf numero ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r Especificar dicionários para arquivos colunados é um pé-no-saco, por sorte, existem pacotes que já fizeram parte desse trabalho por nós. O readr não melhora muita o serviço manual de construção de dicionários, o que ele oferece é um ganho de performance tremendo. read_fwf é centenas de vezes mais rápido que o base read.fwf.\nEm termos do que o pacote faz, é basicamente isso. A única coisa que falta mencionar é que ele importa os dados como tibbles ao invés do data.frame padrão, mas isso já é um ótimo gancho pra nossa próxima parte.\ntibbles Tibbles são basicamente data.frames com um método mais bonitinho de print. Elas automaticamente se ajustam a largura da sua tela, omitindo as colunas que estouram, e por padrão imprimem só as 10 primeiras observações. Outras características que pessoalmente gosto, é que elas informam o tipo de variável junto com o nome, arrendondam digitos significativos, destacam números grandes, negativos, NAs e etc.\ndf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = cols()) # omitir a especificação\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Do ponto de vista prático, elas funcionam exatamente igual a data.frames, tudo que você pode fazer com um data.frame, você faz com tibbles. O que elas trazem de novidade é:\n Elas nunca mudam o tipo de dado inputado.  df1 \u0026lt;- data.frame(x = list(1:5, 1:10, 1:20))\rdf1\r ## x.1.5 x.1.10 x.1.20\r## 1 1 1 1\r## 2 2 2 2\r## 3 3 3 3\r## 4 4 4 4\r## 5 5 5 5\r## 6 1 6 6\r## 7 2 7 7\r## 8 3 8 8\r## 9 4 9 9\r## 10 5 10 10\r## 11 1 1 11\r## 12 2 2 12\r## 13 3 3 13\r## 14 4 4 14\r## 15 5 5 15\r## 16 1 6 16\r## 17 2 7 17\r## 18 3 8 18\r## 19 4 9 19\r## 20 5 10 20\r df2 \u0026lt;- tibble(x = list(1:5, 1:10, 1:20))\rdf2\r ## # A tibble: 3 x 1\r## x ## \u0026lt;list\u0026gt; ## 1 \u0026lt;int [5]\u0026gt; ## 2 \u0026lt;int [10]\u0026gt;\r## 3 \u0026lt;int [20]\u0026gt;\r  Elas nunca ajustam os nomes das variáveis  names(data.frame(`nome hipster` = 1))\r ## [1] \u0026quot;nome.hipster\u0026quot;\r names(tibble(`nome hipster` = 1))\r ## [1] \u0026quot;nome hipster\u0026quot;\r  Ela avalia cada argumento de forma \u0026ldquo;preguiçosa\u0026rdquo; e sequencial  # erro\rdata.frame(x = 1:5, y = x ^ 2)\r ## Error in x^2: argumento não-numérico para operador binário\r # funciona\rtibble(x = 1:5, y = x ^ 2)\r ## # A tibble: 5 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 4\r## 3 3 9\r## 4 4 16\r## 5 5 25\r  Ela nunca utiliza row.names  head(data.frame(state.x77))\r ## Population Income Illiteracy Life.Exp Murder HS.Grad Frost Area\r## Alabama 3615 3624 2.1 69.05 15.1 41.3 20 50708\r## Alaska 365 6315 1.5 69.31 11.3 66.7 152 566432\r## Arizona 2212 4530 1.8 70.55 7.8 58.1 15 113417\r## Arkansas 2110 3378 1.9 70.66 10.1 39.9 65 51945\r## California 21198 5114 1.1 71.71 10.3 62.6 20 156361\r## Colorado 2541 4884 0.7 72.06 6.8 63.9 166 103766\r as_tibble(state.x77)\r ## # A tibble: 50 x 8\r## Population Income Illiteracy `Life Exp` Murder `HS Grad` Frost Area\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 3615 3624 2.1 69.0 15.1 41.3 20 50708\r## 2 365 6315 1.5 69.3 11.3 66.7 152 566432\r## 3 2212 4530 1.8 70.6 7.8 58.1 15 113417\r## 4 2110 3378 1.9 70.7 10.1 39.9 65 51945\r## 5 21198 5114 1.1 71.7 10.3 62.6 20 156361\r## 6 2541 4884 0.7 72.1 6.8 63.9 166 103766\r## 7 3100 5348 1.1 72.5 3.1 56 139 4862\r## 8 579 4809 0.9 70.1 6.2 54.6 103 1982\r## 9 8277 4815 1.3 70.7 10.7 52.6 11 54090\r## 10 4931 4091 2 68.5 13.9 40.6 60 58073\r## # ... with 40 more rows\r  Ela muda a \u0026ldquo;regra da reciclagem\u0026rdquo;: apenas são aceitos vetores unitários ou vetores de tamanho igual aos demais  data.frame(x = 1:10, y = 1:5)\r ## x y\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r # erro\rtibble(x = 1:10, y = 1:5)\r ## Error: Tibble columns must have compatible sizes.\r## * Size 10: Existing data.\r## * Size 5: Column `y`.\r## i Only values of size one are recycled.\r tibble(x = 1:10, y = 1)\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 1\r## 3 3 1\r## 4 4 1\r## 5 5 1\r## 6 6 1\r## 7 7 1\r## 8 8 1\r## 9 9 1\r## 10 10 1\r tibble(x = 1:10, y = c(1:5, 1:5))\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r  Tibbles são estritas com relação as operações de subsetting com [  df1 \u0026lt;- data.frame(x = 1:3, y = 3:1)\rclass(df1[,1:2])\r ## [1] \u0026quot;data.frame\u0026quot;\r class(df1[,1])\r ## [1] \u0026quot;integer\u0026quot;\r df2 \u0026lt;- tibble(x = 1:3, y = 3:1)\rclass(df2[, 1:2])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r class(df2[, 1])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r # Se quiser extrair só uma coluna, utilize '[[' ou '$'\rclass(df2[[1]])\r ## [1] \u0026quot;integer\u0026quot;\r class(df2$x)\r ## [1] \u0026quot;integer\u0026quot;\r Elas também não aceitam \u0026lsquo;partial matching\u0026rsquo; de nomes de variáveis.\ndf \u0026lt;- data.frame(nome_de_cavalo = 1)\rdf$nome\r ## [1] 1\r df2 \u0026lt;- tibble(nome_de_cavalo = 1)\rdf2$nome\r ## Warning: Unknown or uninitialised column: `nome`.\r ## NULL\r tidyr Ok, nossos dados estão no R, mas, muitas vezes, não estão no formato adequado. De maneira geral, analistas de dados vão dar preferência a um formato parecido com este:\nIsto tem uma razão de ser que deve tornar-se óbvia quando tentarmos realizar as operações de transformação de variáveis, visualização, modelos, etc. Porém, muitas vezes outras considerações são feitas na hora registrar os dados, armazená-los, apresentá-los ao público, por isso, frequentemente nossos dados não estão no formato tidy e precisam ser reformatados. Essa é uma das principais tarefas do tidyr e é nela que vamos nos concentrar.\nAtente que reformatação, como muitos outros aspectos da análise de dados, não é receita de bolo. Muitas vezes o formato desejado não é óbvio, muito menos os passos necessários para chegar lá. Porém, vou apresentar as ferramentas e alguns exemplos simples que cobrem muitos dos nossos casos de uso.\nlibrary(tidyr)\rwho\r ## # A tibble: 7,240 x 60\r## country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghani~ AF AFG 1980 NA NA NA NA\r## 2 Afghani~ AF AFG 1981 NA NA NA NA\r## 3 Afghani~ AF AFG 1982 NA NA NA NA\r## 4 Afghani~ AF AFG 1983 NA NA NA NA\r## 5 Afghani~ AF AFG 1984 NA NA NA NA\r## 6 Afghani~ AF AFG 1985 NA NA NA NA\r## 7 Afghani~ AF AFG 1986 NA NA NA NA\r## 8 Afghani~ AF AFG 1987 NA NA NA NA\r## 9 Afghani~ AF AFG 1988 NA NA NA NA\r## 10 Afghani~ AF AFG 1989 NA NA NA NA\r## # ... with 7,230 more rows, and 52 more variables: new_sp_m4554 \u0026lt;int\u0026gt;,\r## # new_sp_m5564 \u0026lt;int\u0026gt;, new_sp_m65 \u0026lt;int\u0026gt;, new_sp_f014 \u0026lt;int\u0026gt;,\r## # new_sp_f1524 \u0026lt;int\u0026gt;, new_sp_f2534 \u0026lt;int\u0026gt;, new_sp_f3544 \u0026lt;int\u0026gt;,\r## # new_sp_f4554 \u0026lt;int\u0026gt;, new_sp_f5564 \u0026lt;int\u0026gt;, new_sp_f65 \u0026lt;int\u0026gt;,\r## # new_sn_m014 \u0026lt;int\u0026gt;, new_sn_m1524 \u0026lt;int\u0026gt;, new_sn_m2534 \u0026lt;int\u0026gt;,\r## # new_sn_m3544 \u0026lt;int\u0026gt;, new_sn_m4554 \u0026lt;int\u0026gt;, new_sn_m5564 \u0026lt;int\u0026gt;,\r## # new_sn_m65 \u0026lt;int\u0026gt;, new_sn_f014 \u0026lt;int\u0026gt;, new_sn_f1524 \u0026lt;int\u0026gt;,\r## # new_sn_f2534 \u0026lt;int\u0026gt;, new_sn_f3544 \u0026lt;int\u0026gt;, new_sn_f4554 \u0026lt;int\u0026gt;,\r## # new_sn_f5564 \u0026lt;int\u0026gt;, new_sn_f65 \u0026lt;int\u0026gt;, new_ep_m014 \u0026lt;int\u0026gt;,\r## # new_ep_m1524 \u0026lt;int\u0026gt;, new_ep_m2534 \u0026lt;int\u0026gt;, new_ep_m3544 \u0026lt;int\u0026gt;,\r## # new_ep_m4554 \u0026lt;int\u0026gt;, new_ep_m5564 \u0026lt;int\u0026gt;, new_ep_m65 \u0026lt;int\u0026gt;,\r## # new_ep_f014 \u0026lt;int\u0026gt;, new_ep_f1524 \u0026lt;int\u0026gt;, new_ep_f2534 \u0026lt;int\u0026gt;,\r## # new_ep_f3544 \u0026lt;int\u0026gt;, new_ep_f4554 \u0026lt;int\u0026gt;, new_ep_f5564 \u0026lt;int\u0026gt;,\r## # new_ep_f65 \u0026lt;int\u0026gt;, newrel_m014 \u0026lt;int\u0026gt;, newrel_m1524 \u0026lt;int\u0026gt;,\r## # newrel_m2534 \u0026lt;int\u0026gt;, newrel_m3544 \u0026lt;int\u0026gt;, newrel_m4554 \u0026lt;int\u0026gt;,\r## # newrel_m5564 \u0026lt;int\u0026gt;, newrel_m65 \u0026lt;int\u0026gt;, newrel_f014 \u0026lt;int\u0026gt;,\r## # newrel_f1524 \u0026lt;int\u0026gt;, newrel_f2534 \u0026lt;int\u0026gt;, newrel_f3544 \u0026lt;int\u0026gt;,\r## # newrel_f4554 \u0026lt;int\u0026gt;, newrel_f5564 \u0026lt;int\u0026gt;, newrel_f65 \u0026lt;int\u0026gt;\r Esse é um banco de dados difícil de analisar, ele tem 60 colunas, indicando o número de casos de tuberculose em diversos estágios da doença, por país e ano. O problema é que ao invés de termos algo como:\ntribble(\r~pais, ~ano, ~tipo, ~idade, ~casos,\r\u0026quot;brasil\u0026quot;, 1980, \u0026quot;extrapulmonar\u0026quot;, \u0026quot;15-24\u0026quot;, 10,\r\u0026quot;brasil\u0026quot;, 1990, \u0026quot;relapso\u0026quot;, \u0026quot;15-24\u0026quot;, 10\r)\r ## # A tibble: 2 x 5\r## pais ano tipo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 brasil 1980 extrapulmonar 15-24 10\r## 2 brasil 1990 relapso 15-24 10\r As informações de tipo de tuberculose e idade dos pacientes estão espalhadas pelas colunas. Pra encurtar a história, precisamos \u0026ldquo;tombar\u0026rdquo; esse banco para que essas colunas se tornem um novo conjunto de variáveis. Vamos passo a passo.\n# Primeiro, vamos excluir as colunas iso2 e iso3, porque elas são a mesma informação redundante\rwho$iso2 \u0026lt;- NULL\rwho$iso3 \u0026lt;- NULL\rwho1 \u0026lt;- pivot_longer(who,\rcols = c(new_sp_m014:newrel_f65),\rnames_to = \u0026quot;tipo_tb\u0026quot;,\rvalues_to = \u0026quot;casos\u0026quot;,\rvalues_drop_na = TRUE)\rwho1\r ## # A tibble: 76,046 x 4\r## country year tipo_tb casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 new_sp_m014 0\r## 2 Afghanistan 1997 new_sp_m1524 10\r## 3 Afghanistan 1997 new_sp_m2534 6\r## 4 Afghanistan 1997 new_sp_m3544 3\r## 5 Afghanistan 1997 new_sp_m4554 5\r## 6 Afghanistan 1997 new_sp_m5564 2\r## 7 Afghanistan 1997 new_sp_m65 0\r## 8 Afghanistan 1997 new_sp_f014 5\r## 9 Afghanistan 1997 new_sp_f1524 38\r## 10 Afghanistan 1997 new_sp_f2534 36\r## # ... with 76,036 more rows\r Nosso primeiro passo é transformar todas as colunas de novos casos em um par de colunas:\n cols indica quais colunas serão tombadas e quais serão mantidas. Uma coluna names_to recebe as categorias da variável. Uma coluna values_to recebe os valores das células. values_drop_na é uma opção para eliminar células vazias.  Essa primeira transformação já nos dá um banco de dados um pouco mais amigável, porém, ainda temos variáveis \u0026ldquo;presas\u0026rdquo; na coluna tipo_tb. Vamos tentar soltá-las.\n# primeiro, corrigir uma pequena inconsistencia:\runique(who1$tipo_tb)\r ## [1] \u0026quot;new_sp_m014\u0026quot; \u0026quot;new_sp_m1524\u0026quot; \u0026quot;new_sp_m2534\u0026quot; \u0026quot;new_sp_m3544\u0026quot; \u0026quot;new_sp_m4554\u0026quot;\r## [6] \u0026quot;new_sp_m5564\u0026quot; \u0026quot;new_sp_m65\u0026quot; \u0026quot;new_sp_f014\u0026quot; \u0026quot;new_sp_f1524\u0026quot; \u0026quot;new_sp_f2534\u0026quot;\r## [11] \u0026quot;new_sp_f3544\u0026quot; \u0026quot;new_sp_f4554\u0026quot; \u0026quot;new_sp_f5564\u0026quot; \u0026quot;new_sp_f65\u0026quot; \u0026quot;new_sn_m014\u0026quot; ## [16] \u0026quot;new_sn_m1524\u0026quot; \u0026quot;new_sn_m2534\u0026quot; \u0026quot;new_sn_m3544\u0026quot; \u0026quot;new_sn_m4554\u0026quot; \u0026quot;new_sn_m5564\u0026quot;\r## [21] \u0026quot;new_sn_m65\u0026quot; \u0026quot;new_ep_m014\u0026quot; \u0026quot;new_ep_m1524\u0026quot; \u0026quot;new_ep_m2534\u0026quot; \u0026quot;new_ep_m3544\u0026quot;\r## [26] \u0026quot;new_ep_m4554\u0026quot; \u0026quot;new_ep_m5564\u0026quot; \u0026quot;new_ep_m65\u0026quot; \u0026quot;new_sn_f014\u0026quot; \u0026quot;newrel_m014\u0026quot; ## [31] \u0026quot;newrel_f014\u0026quot; \u0026quot;new_sn_f1524\u0026quot; \u0026quot;new_sn_f2534\u0026quot; \u0026quot;new_sn_f3544\u0026quot; \u0026quot;new_sn_f4554\u0026quot;\r## [36] \u0026quot;new_sn_f5564\u0026quot; \u0026quot;new_sn_f65\u0026quot; \u0026quot;new_ep_f014\u0026quot; \u0026quot;new_ep_f1524\u0026quot; \u0026quot;new_ep_f2534\u0026quot;\r## [41] \u0026quot;new_ep_f3544\u0026quot; \u0026quot;new_ep_f4554\u0026quot; \u0026quot;new_ep_f5564\u0026quot; \u0026quot;new_ep_f65\u0026quot; \u0026quot;newrel_m1524\u0026quot;\r## [46] \u0026quot;newrel_m2534\u0026quot; \u0026quot;newrel_m3544\u0026quot; \u0026quot;newrel_m4554\u0026quot; \u0026quot;newrel_m5564\u0026quot; \u0026quot;newrel_m65\u0026quot; ## [51] \u0026quot;newrel_f1524\u0026quot; \u0026quot;newrel_f2534\u0026quot; \u0026quot;newrel_f3544\u0026quot; \u0026quot;newrel_f4554\u0026quot; \u0026quot;newrel_f5564\u0026quot;\r## [56] \u0026quot;newrel_f65\u0026quot;\r # Notem que newrel deveria ser new_rel\r# Alguns de vocês devem conhecer 'gsub'\rwho1$tipo_tb \u0026lt;- gsub(\u0026quot;newrel\u0026quot;, \u0026quot;new_rel\u0026quot;, who1$tipo_tb)\r# Agora, podemos usar outra função chave do tidyr, 'separate'\rwho2 \u0026lt;- who1 %\u0026gt;% separate(col = tipo_tb,\rinto = c(NA, \u0026quot;tipo_tb\u0026quot;, \u0026quot;sexo_idade\u0026quot;),\rsep = \u0026quot;_\u0026quot;)\rwho2\r ## # A tibble: 76,046 x 5\r## country year tipo_tb sexo_idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m014 0\r## 2 Afghanistan 1997 sp m1524 10\r## 3 Afghanistan 1997 sp m2534 6\r## 4 Afghanistan 1997 sp m3544 3\r## 5 Afghanistan 1997 sp m4554 5\r## 6 Afghanistan 1997 sp m5564 2\r## 7 Afghanistan 1997 sp m65 0\r## 8 Afghanistan 1997 sp f014 5\r## 9 Afghanistan 1997 sp f1524 38\r## 10 Afghanistan 1997 sp f2534 36\r## # ... with 76,036 more rows\r # E outra passagem de separate para separar a idade do sexo\rwho3 \u0026lt;- who2 %\u0026gt;% separate(col = sexo_idade,\rinto = c(\u0026quot;sexo\u0026quot;, \u0026quot;idade\u0026quot;),\rsep = 1)\rwho3\r ## # A tibble: 76,046 x 6\r## country year tipo_tb sexo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m 014 0\r## 2 Afghanistan 1997 sp m 1524 10\r## 3 Afghanistan 1997 sp m 2534 6\r## 4 Afghanistan 1997 sp m 3544 3\r## 5 Afghanistan 1997 sp m 4554 5\r## 6 Afghanistan 1997 sp m 5564 2\r## 7 Afghanistan 1997 sp m 65 0\r## 8 Afghanistan 1997 sp f 014 5\r## 9 Afghanistan 1997 sp f 1524 38\r## 10 Afghanistan 1997 sp f 2534 36\r## # ... with 76,036 more rows\r Bem melhor, não acham? Estamos agora com um banco de dados muito mais adequado para uma análise de dados em R. Cada linha é uma observação, cada coluna é uma informação sobre ela.\nAlguns de vocês podem ter reparado que fizemos um caminho em que nosso banco de dados passou de ter muitas colunas para muitas linhas (ficou mais \u0026ldquo;longo\u0026rdquo;) e depois precisamos separar algumas das colunas que criamos em outras (o que fizemos com separate). Podemos facilmente imaginar situações em que queremos fazer o caminho inverso: transformar um banco do formato longo para o formato com mais colunas e unir colunas separadas em uma nova. Vamos ver um exemplo.\n# Exemplo adaptado de https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population\rpopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Imagine que, por qualquer motivo, você prefira trabalhar com uma variável \u0026ldquo;Data\u0026rdquo; ao invés de dia, mês e ano. Podemos usar unite:\npopulacao2 \u0026lt;- populacao %\u0026gt;% unite(col = Data, Day, Month, Year, sep = \u0026quot; \u0026quot;)\rpopulacao2\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19 May 20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19 May 20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census result[9]\r O outro problema que precisamos resolver frequentemente, é separar um par de variáveis em diversas colunas, fazendo o caminho inverso que fizemos no caso do dataset da OMS.\nus_rent_income\r ## # A tibble: 104 x 5\r## GEOID NAME variable estimate moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama income 24476 136\r## 2 01 Alabama rent 747 3\r## 3 02 Alaska income 32940 508\r## 4 02 Alaska rent 1200 13\r## 5 04 Arizona income 27517 148\r## 6 04 Arizona rent 972 4\r## 7 05 Arkansas income 23789 165\r## 8 05 Arkansas rent 709 5\r## 9 06 California income 29454 109\r## 10 06 California rent 1358 3\r## # ... with 94 more rows\r No exemplo acima, queremos separar em colunas os valores das variáveis de renda e valor do aluguel. Esse tipo de operação tem um certo grau de abstração que me deu bastante dor de cabeça para entender inicialmente, então vamos olhar com carinho para o que queremos ter depois da transformação.\nus_rent_income2 \u0026lt;- tribble(\r~GEOID, ~NAME, ~income_estimate, ~rent_estimate, ~income_moe, ~rent_moe,\r\u0026quot;01\u0026quot;, \u0026quot;Alabama\u0026quot;, 24476, 747, 136, 3,\r\u0026quot;02\u0026quot;, \u0026quot;Alaska\u0026quot;, 32940, 1200, 508, 13\r)\rus_rent_income2\r ## # A tibble: 2 x 6\r## GEOID NAME income_estimate rent_estimate income_moe rent_moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r O banco que queremos tem uma cara assim. Ele tem mais colunas novas e menos linhas, já que eu tinha no formato tidy uma variável chamada \u0026ldquo;variable\u0026rdquo; que guardava os valores renda e aluguel e duas colunas que guardavam os valores da estimativa e do moe. Agora, eu vou ter 4 colunas, duas para as estimativas de renda e aluguel e duas para os moes das mesmas variáveis. Como especificar isso para o banco todo? Usando pivot_wider.\nus_rent_income %\u0026gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe))\r ## # A tibble: 52 x 6\r## GEOID NAME estimate_income estimate_rent moe_income moe_rent\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r## 3 04 Arizona 27517 972 148 4\r## 4 05 Arkansas 23789 709 165 5\r## 5 06 California 29454 1358 109 3\r## 6 08 Colorado 32401 1125 109 5\r## 7 09 Connecticut 35326 1123 195 5\r## 8 10 Delaware 31560 1076 247 10\r## 9 11 District of Columbia 43198 1424 681 17\r## 10 12 Florida 25952 1077 70 3\r## # ... with 42 more rows\r As funções pivot_ tem diversos outros argumentos e cobrem diversos casos de uso. Vejam este exemplo da documentação de pivot_longer:\nanscombe\r ## x1 x2 x3 x4 y1 y2 y3 y4\r## 1 10 10 10 8 8.04 9.14 7.46 6.58\r## 2 8 8 8 8 6.95 8.14 6.77 5.76\r## 3 13 13 13 8 7.58 8.74 12.74 7.71\r## 4 9 9 9 8 8.81 8.77 7.11 8.84\r## 5 11 11 11 8 8.33 9.26 7.81 8.47\r## 6 14 14 14 8 9.96 8.10 8.84 7.04\r## 7 6 6 6 8 7.24 6.13 6.08 5.25\r## 8 4 4 4 19 4.26 3.10 5.39 12.50\r## 9 12 12 12 8 10.84 9.13 8.15 5.56\r## 10 7 7 7 8 4.82 7.26 6.42 7.91\r## 11 5 5 5 8 5.68 4.74 5.73 6.89\r Podemos transformar esse banco de dados rapidamente usando um dos argumentos de pivot_longer, chamado names_pattern.\nanscombe %\u0026gt;% pivot_longer(everything(),\rnames_to = c(\u0026quot;.value\u0026quot;, \u0026quot;set\u0026quot;),\rnames_pattern = \u0026quot;(.)(.)\u0026quot;)\r ## # A tibble: 44 x 3\r## set x y\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10 8.04\r## 2 2 10 9.14\r## 3 3 10 7.46\r## 4 4 8 6.58\r## 5 1 8 6.95\r## 6 2 8 8.14\r## 7 3 8 6.77\r## 8 4 8 5.76\r## 9 1 13 7.58\r## 10 2 13 8.74\r## # ... with 34 more rows\r Esse exemplo é interessante, porque ele se aproveita de uma \u0026ldquo;regular expression\u0026rdquo;, tema da parte do nosso curso em que falaremos sobre manipulação de strings com o stringr. Resumidas as contas, as colunas se chamam \u0026ldquo;x1, x2, x3 \u0026hellip;\u0026rdquo; e a string \u0026ldquo;(.)(.)\u0026rdquo; indica que há dois \u0026ldquo;grupos\u0026rdquo; formados por um caractere cada. A string \u0026ldquo;.value\u0026rdquo; que vai no argumento de cima é um atalho da função para dizer \u0026ldquo;pegue o valor de todas as células das variáveis selecionadas\u0026rdquo;, aqui, todas. Ou seja, ele indica para a função que o primeiro caractere \u0026ldquo;x\u0026rdquo; ou \u0026ldquo;y\u0026rdquo; definirá uma nova variável e armazenará os valores das celulas, enquanto o segundo grupo \u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo; ou \u0026ldquo;4\u0026rdquo; formará uma segunda variável chamada \u0026ldquo;set\u0026rdquo; que contém apenas os nomes das colunas. Deu um nó na cabeça?\nUma última preocupação ao utilizar a reformatação de dados é o que ocorre com os valores NA. Vejamos este exemplo:\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\r Existem dois tipos de valor nulo, explícito se diz de um valor nulo como aquele NA que aparece na variável lucro. Implícito é o valor que ocorre no primeiro quadrimestre de 2016, onde sequer foi adicionada uma linha no banco de dados. Os valores implícitos são muito sacanas, porque eles não são imediatamente visíveis.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro)\r ## # A tibble: 4 x 3\r## qdr `2015` `2016`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1.88 NA ## 2 2 0.59 0.92\r## 3 3 0.35 0.17\r## 4 4 NA 2.66\r Ao transformar o banco, o valor implícito ficou explícito. Caso você não esteja interessado neste valor, você pode passar o values_drop_na durante a transformação de volta ao formato original.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro) %\u0026gt;% pivot_longer(c(`2015`, `2016`),\rnames_to = \u0026quot;ano\u0026quot;,\rvalues_to = \u0026quot;lucro\u0026quot;,\rvalues_drop_na = TRUE)\r ## # A tibble: 6 x 3\r## qdr ano lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2015 1.88\r## 2 2 2015 0.59\r## 3 2 2016 0.92\r## 4 3 2015 0.35\r## 5 3 2016 0.17\r## 6 4 2016 2.66\r Que faz os valores missing desaparecerem do resultado.\ncomplete pode ser usada pra tornar valores implícitos, explícitos! A função toma todas as colunas pedidas e verifica todas as combinações possíveis de valores, preenchendo as lacunas com NA. Cuidado ao utilizar complete com valores numéricos ou conjuntos de colunas com muitas combinações possíveis, pois o número de combinações pode ser infinitamente grande e travar sua sessão!\nacoes %\u0026gt;% complete(ano, qdr)\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Pra encerrar, fill serve para aqueles casos em que um valor missing indica que a última observação deve ser repetida. Pesquisadores brasileiros das antigas podem lembrar-se do Censo de 1991, em que o IBGE registrava os arquivos de domícilio e pessoas com esse sistema. Em inglês, isso se chama LOCF, ou \u0026ldquo;last observation carried forward\u0026rdquo;.\ntreatment \u0026lt;- tribble(\r~ person, ~ treatment, ~response,\r\u0026quot;Derrick Whitmore\u0026quot;, 1, 7,\rNA, 2, 10,\rNA, 3, 9,\r\u0026quot;Katherine Burke\u0026quot;, 1, 4\r)\rtreatment\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 \u0026lt;NA\u0026gt; 2 10\r## 3 \u0026lt;NA\u0026gt; 3 9\r## 4 Katherine Burke 1 4\r treatment %\u0026gt;% fill(person)\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 Derrick Whitmore 2 10\r## 3 Derrick Whitmore 3 9\r## 4 Katherine Burke 1 4\r tidyr tem também outras funcionalidades relevantes para modelagem estatística, mas acho que isso sai um pouco do escopo do curso. Quem sabe a gente não faz um curso posterior só sobre modelagem no tidyverse?\nRevisão readr O pacote readr apresenta uma família de funções para substituir as funções do base relacionadas a importação de arquivos em formato texto, seja delimitado ou largura-fixa. São elas,\n read_delim read_csv read_csv2 read_tsv read_table read_fwf  E assim sucessivamente. Durante o processo de importação, você pode querer especificar o tipo de coluna com cols ou cols_only, usando o argumento col_types. Ou use uma string do tipo \u0026ldquo;ddcdiDT\u0026rdquo; em que cada letra é um tipo de variável.\n col_integer col_double col_factor col_character  Etc. Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nAh, e você sempre pode salvar com write_, inclusive salvando/lendo compactado para bzip, gzip ou xzip.\ntibble Tibbles são uma versão do data.frame com algumas regrinhas novas. Vou apenas repetí-las aqui de forma resumida.\n tibbles tem um método print mais bonito e amigável, especialmente para bancos com muitas observações e variáveis. elas são estritas com operações de subsetting com [ e $. elas não aceita a reciclagem de argumento de tamanho diferente de 1.  tidyr tidyr é um pacote de reformatação de bancos, criando novas linhas e colunas a partir da reorganização das variáveis e valores existentes. Suas principais operações são:\n pivot_longer para converter colunas em linhas pivot_wider para converter linhas em colunas separate para separar uma coluna em várias com base em caracteres unite para unir diversas colunas em uma com base em caracteres  Ufa. Acabou né? Posso ir dormir já? Claro, só fazer uns exercícios!\nExercícios  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  file \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.  # Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\rbillboard  ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r  Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?\n  O que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.\n  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r  Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?\n  Compare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?\n  Agradecimentos Esse material é uma adaptação livre das vinhetas dos pacotes tidyr, readr e tibble e do capítulo Tidy Data do R for Data Science, de Wickham \u0026amp; Grolemund.\n","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"0bad4868b4cebec13d81438fabee26ad","permalink":"https://laddem.github.io/courses/tidyverse/dia1/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia1/","section":"courses","summary":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:","tags":null,"title":"readr, tibble e tidyr","type":"book"},{"authors":null,"categories":null,"content":"\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\nO pacote stringr é uma série de adaptações da biblioteca stringi e serve para a manipulação de variáveis texto, incluindo funções para detecção, modificação, substituição, remoção de texto em variáveis caractere. Para dominar esse assunto, é necessário compreender o conceito de “regex,” ou “expressão regular,” que foge um pouco do escopo do curso, mas que será introduzido brevemente.\nO pacote forcats contém uma série de funções para trabalhar com o tipo factor. São funções que facilitam operações envolvendo esse tipo de variável, como contagens, troca dos nomes das categorias, agrupamento de categorias, recodificação, plotagem, etc.\nO pacote dplyr é um dos pilares do tidyverse e ele tem dois papéis principais: operações de manipulação de banco de dados simples e operações de bancos de dados relacionais. No primeiro tipo são incluídas as operações de criação e modificação de variáveis, medidas resumo globais e por grupos, seleção de variáveis, mudança da ordem das linhas e colunas, etc. No segundo tipo, são as operações de tipo _join, em que uma variável chave é utilizada para combinar registros de dois bancos de dados distintos.\nOs pacotes stringr e forcats são mais diretos, mas o dplyr pode representar um certo nível de abstração que pode incomodar usuários de longa data do R, portanto, vamos nos esforçar para demonstrar as vantagens de mudar seu workflow para incluir as funções desse pacote através de comparações com o R base.\ndplyr dplyr para manipulação de dados Talvez o pacote mais utilizado de todo o tidyverse, dplyr é um pacote de manipulação de bancos de dados inspirado pela linguagem SQL. A ideia é concatenar operações de seleção de variáveis, filtragem de observação, arranjo e ordenamento, derivação de variáveis, computação de medidas resumo para o banco todo ou para grupos. As funções básicas e mais utilizadas são, portanto:\n select filter arrange mutate summarize group_by  Para praticar, vamos usar o dataset flights, que contém informações sobre os vôos saídos de Nova Iorque em 2013.\nlibrary(nycflights13)\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r## The following objects are masked from 'package:stats':\r## ## filter, lag\r## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r flights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r glimpse(flights)\r ## Rows: 336,776\r## Columns: 19\r## $ year \u0026lt;int\u0026gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2~\r## $ month \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ day \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ dep_time \u0026lt;int\u0026gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, ~\r## $ sched_dep_time \u0026lt;int\u0026gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, ~\r## $ dep_delay \u0026lt;dbl\u0026gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1~\r## $ arr_time \u0026lt;int\u0026gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,~\r## $ sched_arr_time \u0026lt;int\u0026gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,~\r## $ arr_delay \u0026lt;dbl\u0026gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1~\r## $ carrier \u0026lt;chr\u0026gt; \u0026quot;UA\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;DL\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;EV\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;~\r## $ flight \u0026lt;int\u0026gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4~\r## $ tailnum \u0026lt;chr\u0026gt; \u0026quot;N14228\u0026quot;, \u0026quot;N24211\u0026quot;, \u0026quot;N619AA\u0026quot;, \u0026quot;N804JB\u0026quot;, \u0026quot;N668DN\u0026quot;, \u0026quot;N394~\r## $ origin \u0026lt;chr\u0026gt; \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;,~\r## $ dest \u0026lt;chr\u0026gt; \u0026quot;IAH\u0026quot;, \u0026quot;IAH\u0026quot;, \u0026quot;MIA\u0026quot;, \u0026quot;BQN\u0026quot;, \u0026quot;ATL\u0026quot;, \u0026quot;ORD\u0026quot;, \u0026quot;FLL\u0026quot;, \u0026quot;IAD\u0026quot;,~\r## $ air_time \u0026lt;dbl\u0026gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1~\r## $ distance \u0026lt;dbl\u0026gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, ~\r## $ hour \u0026lt;dbl\u0026gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6~\r## $ minute \u0026lt;dbl\u0026gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0~\r## $ time_hour \u0026lt;dttm\u0026gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0~\r Podemos filtrar nossas linhas: filter\n# Voos de primeiro de janeiro\rflights %\u0026gt;% filter(month == 1, day == 1)\r ## # A tibble: 842 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 832 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos a partir de junho\rflights %\u0026gt;% filter(month \u0026gt; 6)\r ## # A tibble: 170,618 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 170,608 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saídos do aeroporto JFK\rflights %\u0026gt;% filter(origin == \u0026quot;JFK\u0026quot;)\r ## # A tibble: 111,279 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 111,269 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com destino ao aeroporto de Albuquerque\rflights %\u0026gt;% filter(dest == \u0026quot;ABQ\u0026quot;)\r ## # A tibble: 254 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 1955 2001 -6 2213 2248\r## 2 2013 10 2 2010 2001 9 2230 2248\r## 3 2013 10 3 1955 2001 -6 2232 2248\r## 4 2013 10 4 2017 2001 16 2304 2248\r## 5 2013 10 5 1959 1959 0 2226 2246\r## 6 2013 10 6 1959 2001 -2 2234 2248\r## 7 2013 10 7 2002 2001 1 2233 2248\r## 8 2013 10 8 1957 2001 -4 2216 2248\r## 9 2013 10 9 1957 2001 -4 2220 2248\r## 10 2013 10 10 2011 2001 10 2235 2248\r## # ... with 244 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de até 10 minutos\rflights %\u0026gt;% filter(dep_delay \u0026lt;= 10)\r ## # A tibble: 245,687 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 245,677 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de cerca de 10 minutos\rflights %\u0026gt;% filter(near(dep_delay, 10, tol = 2))\r ## # A tibble: 8,677 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 611 600 11 945 931\r## 2 2013 1 1 709 700 9 852 832\r## 3 2013 1 1 826 817 9 1145 1158\r## 4 2013 1 1 851 840 11 1215 1206\r## 5 2013 1 1 1011 1001 10 1133 1128\r## 6 2013 1 1 1208 1158 10 1540 1502\r## 7 2013 1 1 1240 1229 11 1451 1428\r## 8 2013 1 1 1310 1300 10 1559 1554\r## 9 2013 1 1 1330 1321 9 1613 1536\r## 10 2013 1 1 1511 1500 11 1753 1742\r## # ... with 8,667 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos que ocorreram entre abril e maio\rflights %\u0026gt;% filter(between(month, 4, 5))\r ## # A tibble: 57,126 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 57,116 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Podemos combinar várias condições usando operadores lógicos\n# Voos até 15 de abril ou até 15 de maio\rflights %\u0026gt;% filter(\rbetween(month, 4, 5), # mesmo que usar \u0026amp;\rbetween(day, 1, 15)\r)\r ## # A tibble: 28,176 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 28,166 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos entre 15 de abril e 15 de maio\rflights %\u0026gt;% filter(\rmonth == 4 \u0026amp; between(day, 15, 30) | # OU\rmonth == 5 \u0026amp; between(day, 1, 15)\r)\r ## # A tibble: 29,101 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 15 2 2359 3 341 339\r## 2 2013 4 15 453 500 -7 639 640\r## 3 2013 4 15 511 515 -4 741 802\r## 4 2013 4 15 527 530 -3 806 813\r## 5 2013 4 15 527 529 -2 750 743\r## 6 2013 4 15 537 540 -3 846 840\r## 7 2013 4 15 542 545 -3 931 927\r## 8 2013 4 15 551 600 -9 728 758\r## 9 2013 4 15 552 600 -8 835 850\r## 10 2013 4 15 552 600 -8 648 701\r## # ... with 29,091 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos em todas os primeiros 7 dias de cada mês, exceto em janeiro e dezembro\rflights %\u0026gt;% filter(\rbetween(day, 1, 7),\r!month %in% c(1, 12)\r)\r ## # A tibble: 64,365 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 64,355 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saidos de JFK, excluindo aqueles para os quais não tem informações de horário de saída\rflights %\u0026gt;% filter(\rorigin == \u0026quot;JFK\u0026quot;, !is.na(dep_time)\r)\r ## # A tibble: 109,416 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 109,406 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com mais de 30 minutos de atraso em janeiro ou dezembro\rflights %\u0026gt;% filter(\rdep_delay \u0026gt; 30, xor(month == 1, month == 12)\r)\r ## # A tibble: 8,221 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 732 645 47 1011 941\r## 2 2013 1 1 749 710 39 939 850\r## 3 2013 1 1 811 630 101 1047 830\r## 4 2013 1 1 826 715 71 1136 1045\r## 5 2013 1 1 848 1835 853 1001 1950\r## 6 2013 1 1 903 820 43 1045 955\r## 7 2013 1 1 909 810 59 1331 1315\r## 8 2013 1 1 953 921 32 1320 1241\r## 9 2013 1 1 957 733 144 1056 853\r## 10 2013 1 1 1025 951 34 1258 1302\r## # ... with 8,211 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r E assim sucessivamente.\nDa mesma forma, temos select para selecionar as variáveis do banco. As duas grandes novidades são que você não precisa utilizar aspas na seleção de variáveis e que select introduz várias helper functions para facilitar a seleção de variáveis parecidas.\n# Selecionar as colunas ano, mes, dia, horario de saida e horario de chegada\rflights %\u0026gt;% select(year, month, day, dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Utilizando helpers\rflights %\u0026gt;% select(year:dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Mais helpers\rflights %\u0026gt;% select(year:day, starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 2 830 11\r## 2 2013 1 1 533 4 850 20\r## 3 2013 1 1 542 2 923 33\r## 4 2013 1 1 544 -1 1004 -18\r## 5 2013 1 1 554 -6 812 -25\r## 6 2013 1 1 554 -4 740 12\r## 7 2013 1 1 555 -5 913 19\r## 8 2013 1 1 557 -3 709 -14\r## 9 2013 1 1 557 -3 838 -8\r## 10 2013 1 1 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, ends_with(\u0026quot;time\u0026quot;))\r ## # A tibble: 336,776 x 8\r## year month day dep_time sched_dep_time arr_time sched_arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 515 830 819 227\r## 2 2013 1 1 533 529 850 830 227\r## 3 2013 1 1 542 540 923 850 160\r## 4 2013 1 1 544 545 1004 1022 183\r## 5 2013 1 1 554 600 812 837 116\r## 6 2013 1 1 554 558 740 728 150\r## 7 2013 1 1 555 600 913 854 158\r## 8 2013 1 1 557 600 709 723 53\r## 9 2013 1 1 557 600 838 846 140\r## 10 2013 1 1 558 600 753 745 138\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, c(ends_with(\u0026quot;time\u0026quot;)) \u0026amp; !contains(\u0026quot;sched\u0026quot;))\r ## # A tibble: 336,776 x 6\r## year month day dep_time arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 830 227\r## 2 2013 1 1 533 850 227\r## 3 2013 1 1 542 923 160\r## 4 2013 1 1 544 1004 183\r## 5 2013 1 1 554 812 116\r## 6 2013 1 1 554 740 150\r## 7 2013 1 1 555 913 158\r## 8 2013 1 1 557 709 53\r## 9 2013 1 1 557 838 140\r## 10 2013 1 1 558 753 138\r## # ... with 336,766 more rows\r # Você pode mudar o nome das colunas durante um call para select\rflights %\u0026gt;% select(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 3\r## ano mes dia\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1\r## 2 2013 1 1\r## 3 2013 1 1\r## 4 2013 1 1\r## 5 2013 1 1\r## 6 2013 1 1\r## 7 2013 1 1\r## 8 2013 1 1\r## 9 2013 1 1\r## 10 2013 1 1\r## # ... with 336,766 more rows\r # Ou você pode usar rename para mudar os nomes sem selecionar variáveis\rflights %\u0026gt;% rename(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 19\r## ano mes dia dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r São realmente muitas possibilidades, vejam a documentação e os exemplos em ?select.\nUtilizando arrange podemos facilmente organizar nosso banco a partir de variáveis de interesse:\n# Selecionar algumas variáveis e ver organizar de acordar com os mais adiantados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(dep_delay, arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 12 7 2040 -43 40 48\r## 2 2013 2 3 2022 -33 2240 -58\r## 3 2013 11 10 1408 -32 1549 -10\r## 4 2013 1 11 1900 -30 2233 -10\r## 5 2013 1 29 1703 -27 1947 -10\r## 6 2013 8 9 729 -26 1002 7\r## 7 2013 3 30 2030 -25 2213 -37\r## 8 2013 10 23 1907 -25 2143 0\r## 9 2013 5 5 934 -24 1225 -44\r## 10 2013 9 18 1631 -24 1812 -33\r## # ... with 336,766 more rows\r # Ou os mais atrasados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(-dep_delay, -arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 9 641 1301 1242 1272\r## 2 2013 6 15 1432 1137 1607 1127\r## 3 2013 1 10 1121 1126 1239 1109\r## 4 2013 9 20 1139 1014 1457 1007\r## 5 2013 7 22 845 1005 1044 989\r## 6 2013 4 10 1100 960 1342 931\r## 7 2013 3 17 2321 911 135 915\r## 8 2013 6 27 959 899 1236 850\r## 9 2013 7 22 2257 898 121 895\r## 10 2013 12 5 756 896 1058 878\r## # ... with 336,766 more rows\r É basicamente isso, você pode especificar uma ou muitas colunas para organizar, decidir se a ordem é ascendente ou descendente e pronto.\nUtilizando mutate, você cria variáveis derivadas das originais. Como tibble, essa função avalia seus argumentos de maneira preguiçosa e sequencial, o que permite você criar variáveis derivadas umas das outras muito facilmente.\nflights %\u0026gt;% select(sched_dep_time, dep_time, sched_arr_time, arr_time) %\u0026gt;% mutate(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 8\r## sched_dep_time dep_time sched_arr_time arr_time atraso_decolagem atraso_pouso\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 515 517 819 830 2 11\r## 2 529 533 830 850 4 20\r## 3 540 542 850 923 2 73\r## 4 545 544 1022 1004 -1 -18\r## 5 600 554 837 812 -46 -25\r## 6 558 554 728 740 -4 12\r## 7 600 555 854 913 -45 59\r## 8 600 557 723 709 -43 -14\r## 9 600 557 846 838 -43 -8\r## 10 600 558 745 753 -42 8\r## # ... with 336,766 more rows, and 2 more variables: atraso_dec_horas \u0026lt;dbl\u0026gt;,\r## # atraso_pouso_horas \u0026lt;dbl\u0026gt;\r # Transmute é um atalho para quando você quer apenas as variáveis resultado e não está interessado nas intermediárias.\rflights %\u0026gt;% transmute(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 4\r## atraso_decolagem atraso_pouso atraso_dec_horas atraso_pouso_horas\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 11 0.0333 0.183\r## 2 4 20 0.0667 0.333\r## 3 2 73 0.0333 1.22 ## 4 -1 -18 -0.0167 -0.3 ## 5 -46 -25 -0.767 -0.417\r## 6 -4 12 -0.0667 0.2 ## 7 -45 59 -0.75 0.983\r## 8 -43 -14 -0.717 -0.233\r## 9 -43 -8 -0.717 -0.133\r## 10 -42 8 -0.7 0.133\r## # ... with 336,766 more rows\r Usando o pipe, é fazer diversas operações de transformação de variáveis simultâneamente em um único call sem a necessidade de repetir o nome do objeto e $ a cada referência. mutate é uma função extremamente flexível, você pode chamar qualquer função que retorne um vetor de tamanho 1 ou de tamanho do número de linhas do banco lá dentro para criar uma variável.\ndesabafo \u0026lt;- function(x) {\ry \u0026lt;- floor(x / 60)\rdplyr::case_when(\r# Condições ~ Resultados\ry \u0026lt; 0 ~ \u0026quot;Opa, vou chegar cedo!\u0026quot;,\ry \u0026lt; 1 ~ \u0026quot;Atraso de menos de 1 hora é tolerável\u0026quot;,\ry \u0026gt;= 1 ~ paste0(\u0026quot;Atraso de mais de \u0026quot;, y, \u0026quot; horas é f***.\u0026quot;),\rTRUE ~ \u0026quot;Ahn?\u0026quot; # Condição guarda-chuva\r)\r}\rflights %\u0026gt;% select(dep_delay) %\u0026gt;% mutate(desabafo = desabafo(dep_delay)) %\u0026gt;% sample_n(10)\r ## # A tibble: 10 x 2\r## dep_delay desabafo ## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 -5 Opa, vou chegar cedo! ## 2 23 Atraso de menos de 1 hora é tolerável\r## 3 -4 Opa, vou chegar cedo! ## 4 -3 Opa, vou chegar cedo! ## 5 -8 Opa, vou chegar cedo! ## 6 -3 Opa, vou chegar cedo! ## 7 -5 Opa, vou chegar cedo! ## 8 22 Atraso de menos de 1 hora é tolerável\r## 9 23 Atraso de menos de 1 hora é tolerável\r## 10 -2 Opa, vou chegar cedo!\r Utilizando summarize você tira medidas resumo das suas colunas de interesse:\nflights %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 1 x 5\r## atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~ n_voos\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 12.6 40.2 6.90 44.6 336776\r Parece uma bobagem, mas quando você junta isso com a última função, group_by, é possível obter diversas estatísticas de interesse muito rapidamente e para vários domínios:\n# Por mês\rflights %\u0026gt;% group_by(month) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 12 x 6\r## month atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 36.4 6.13 40.4\r## 2 2 10.8 36.3 5.61 39.5\r## 3 3 13.2 40.1 5.81 44.1\r## 4 4 13.9 43.0 11.2 47.5\r## 5 5 13.0 39.4 3.52 44.2\r## 6 6 20.8 51.5 16.5 56.1\r## 7 7 21.7 51.6 16.7 57.1\r## 8 8 12.6 37.7 6.04 42.6\r## 9 9 6.72 35.6 -4.02 39.7\r## 10 10 6.24 29.7 -0.167 32.6\r## 11 11 5.44 27.6 0.461 31.4\r## 12 12 16.6 41.9 14.9 46.1\r## # ... with 1 more variable: n_voos \u0026lt;int\u0026gt;\r # Por mês e aeroporto de origem\rflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 EWR 14.9 40.8 12.8 ## 2 1 JFK 8.62 36.0 1.37\r## 3 1 LGA 5.64 29.7 3.38\r## 4 2 EWR 13.1 37.2 8.78\r## 5 2 JFK 11.8 37.4 4.39\r## 6 2 LGA 6.96 33.4 3.15\r## 7 3 EWR 18.1 44.1 10.6 ## 8 3 JFK 10.7 35.3 2.58\r## 9 3 LGA 10.2 39.7 3.74\r## 10 4 EWR 17.4 43.9 14.1 ## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r Uma vez que você se familiariza com a gramática do dplyr, o processo de análise exploratória se torna bastante trivial e até certo ponto, prazeiroso. Mas o que eu realmente gosto é que ele também se torna visualmente óbvio para o leitor, com cada chamado podendo ser lido como uma declaração:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo.\n Você também pode rapidamente introduzir ou retirar passos em cada chamado deste utilizando o pipe, por exemplo:\nflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38\r## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r E a leitura fica:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo, então, ordene os resultados pelo maior atraso.\n De quebra, você ainda leva para casa um dado no formato “tabela,” fácil de exportar para outros softwares para embelezamento e publicação. Veja:\nresumo \u0026lt;- flights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r print(resumo, n = Inf)\r ## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38 ## 11 1 EWR 14.9 40.8 12.8 ## 12 12 JFK 14.8 39.1 12.7 ## 13 12 LGA 13.6 39.8 12.0 ## 14 8 EWR 13.5 37.6 6.71 ## 15 2 EWR 13.1 37.2 8.78 ## 16 8 JFK 12.9 36.3 5.91 ## 17 5 JFK 12.5 38.5 2.12 ## 18 4 JFK 12.2 41.2 7.01 ## 19 2 JFK 11.8 37.4 4.39 ## 20 4 LGA 11.5 43.4 12.0 ## 21 8 LGA 11.2 39.2 5.41 ## 22 3 JFK 10.7 35.3 2.58 ## 23 5 LGA 10.6 40.6 2.80 ## 24 3 LGA 10.2 39.7 3.74 ## 25 10 EWR 8.64 32.7 2.60 ## 26 1 JFK 8.62 36.0 1.37 ## 27 9 EWR 7.29 35.0 -4.73 ## 28 2 LGA 6.96 33.4 3.15 ## 29 11 EWR 6.72 28.8 0.672\r## 30 9 JFK 6.64 32.5 -4.46 ## 31 9 LGA 6.21 39.0 -2.83 ## 32 1 LGA 5.64 29.7 3.38 ## 33 10 LGA 5.31 30.1 0.186\r## 34 11 LGA 4.77 26.6 1.55 ## 35 11 JFK 4.68 27.1 -0.873\r## 36 10 JFK 4.59 25.2 -3.59 ## # ... with 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;, n_voos \u0026lt;int\u0026gt;\r Lembrem-se que é necessário atribuir \u0026lt;- os resultados das operações para que elas sejam salvas. Em geral, meu workflow é assim:\n# Começo com o banco\rflights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Seleciono algumas variáveis\rflights %\u0026gt;% select(month, dep_delay, arr_delay)\r ## # A tibble: 336,776 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 336,766 more rows\r # Recorto algumas observações\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6))\r ## # A tibble: 166,158 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 166,148 more rows\r # Escolho os dominios e calculo as medidas resumo\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T))\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 6.13\r## 2 2 10.8 5.61\r## 3 3 13.2 5.81\r## 4 4 13.9 11.2 ## 5 5 13.0 3.52\r## 6 6 20.8 16.5\r # Acho bom organizar pelos atrasos maiores\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r # Estou satisfeito, salvo meu resultado em outro objeto\ratrasos \u0026lt;- flights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\ratrasos\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r Desta forma, consigo construir interativamente meus cálculos, verificando a cada passo se estou obtendo o resultado esperado. Visto de outra perspectiva, se encontro um código programado desta forma que não funciona, posso ir apagando cada %\u0026gt;% para identificar onde o problema ocorreu.\nEspero que tenha ficado claro que o assunto não se encerra por aqui. Existem diversas outras funções úteis no pacote, como count, if_else, case_when, top_n, bind_rows, bind_cols, as novas funções across e c_across e muitas, muitas outras. Nos livros vocês encontram vários outros exemplos e funções para facilitar o processo de análise de dados, mas nossa expectativa é que essa apresentação seja um ponto de partida para vocês se aprofundarem no seu próprio ritmo.\ndplyr para bancos de dados relacionais Nesta seção, o nosso problema não é mais a análise de dados presentes em um banco, mas o problema de relacionar informações sobre uma mesma unidade de análise que estão presentes em vários bancos de dados distintos.\nO banco nycflights13 contém várias tabelas que se relacionam, e elas funcionam como um excelente exemplo de banco de dados relacionais.\nNote que além do banco de dados dos vôos, temos informações sobre clima, aviões e companhias aéreas. Para nós, pode ser relevante reunir informações de diferentes fontes em um mesmo banco de dados, algo que é possível através de joins. Por uma questão de tempo, não vamos entrar muito a fundo no assunto, mas vamos introduzir dois conceitos chave e partir pros exemplos.\n  chaves são as variáveis que identificam cada observação em um banco de dados de forma única. Uma chave é dita “primária” quando identifica uma observação na sua própria tabela e “externa” quando ela identifica uma observação em outra tabela. Assim, qualquer operação de join é uma forma de relacionar uma chave primária e uma chave externa. Essa junção de chaves é uma relação, e as relações podem ser 1 para 1, 1 para muitos ou muitos para 1.\n  joins são tipos de operação no qual se opta por priorizar um grupo de observações em detrimento de outras. Podemos vê-los didaticamente a partir de duas figuras:\n  A primeira figura é interessante porque nos dá uma ideia de quais observações serão mantidas e quais serão descartadas, podemos imaginá-la como uma abstração da nossa escolha.\n Quero todas as informações sobre os vôos e os aeroportos, e as duas são igualmente importantes (inner_join, x = flights, y = airports).\n  Quero todas as observações do banco vôos e as informações disponíveis sobre a aeronave (left_join, x = flights, y = planes).\n  Quero todas as informações tanto sobre os vôos quanto sobre o clima em cada dia (full_join, x = flights, y = weather).\n  Quero as informações dos vôos realizados pelas companhias aéreas - minha prioridade são as cias. áreas (right_join, x = flights, y = carriers).\n A segunda figura é interessante porque elas mostra a mecânica de um join: cada observação tem a sua chave marcada com a observação correspondente no outro banco. Se as chaves são iguais, a operação é realizada, se as chaves não são iguais, a operação não é realizada. Dependendo do tipo de join, uma, as duas ou nenhuma das observações é descartada do banco resultante.\n Antes de começar a trabalhar com bancos relacionais, é uma boa ideia dar uma explorada nas chaves, vendo suas contagens, se há erros de digitação, etc. Por uma questão de tempo, vamos pular essa fase.\n Se as nossas chaves forem perfeitinhas, e inclusive tiverem o mesmo nome nas duas tabelas, basta invocar o tipo de join desejado.\n# Vamos dar uma enxugada no flights para poder ver o efeito dos joins com maior facilidade.\rflights2 \u0026lt;- flights %\u0026gt;% select(year:day, hour, origin, dest, tailnum, carrier)\rflights2\r ## # A tibble: 336,776 x 8\r## year month day hour origin dest tailnum carrier\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA ## 2 2013 1 1 5 LGA IAH N24211 UA ## 3 2013 1 1 5 JFK MIA N619AA AA ## 4 2013 1 1 5 JFK BQN N804JB B6 ## 5 2013 1 1 6 LGA ATL N668DN DL ## 6 2013 1 1 5 EWR ORD N39463 UA ## 7 2013 1 1 6 EWR FLL N516JB B6 ## 8 2013 1 1 6 LGA IAD N829AS EV ## 9 2013 1 1 6 JFK MCO N593JB B6 ## 10 2013 1 1 6 LGA ORD N3ALAA AA ## # ... with 336,766 more rows\r # Chaves perfeitas, mesmo nome nos dois bancos = natural join\rflights2 %\u0026gt;% left_join(weather) # Moleza\r ## Joining, by = c(\u0026quot;year\u0026quot;, \u0026quot;month\u0026quot;, \u0026quot;day\u0026quot;, \u0026quot;hour\u0026quot;, \u0026quot;origin\u0026quot;)\r## # A tibble: 336,776 x 18\r## year month day hour origin dest tailnum carrier temp dewp humid\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 39.0 28.0 64.4\r## 2 2013 1 1 5 LGA IAH N24211 UA 39.9 25.0 54.8\r## 3 2013 1 1 5 JFK MIA N619AA AA 39.0 27.0 61.6\r## 4 2013 1 1 5 JFK BQN N804JB B6 39.0 27.0 61.6\r## 5 2013 1 1 6 LGA ATL N668DN DL 39.9 25.0 54.8\r## 6 2013 1 1 5 EWR ORD N39463 UA 39.0 28.0 64.4\r## 7 2013 1 1 6 EWR FLL N516JB B6 37.9 28.0 67.2\r## 8 2013 1 1 6 LGA IAD N829AS EV 39.9 25.0 54.8\r## 9 2013 1 1 6 JFK MCO N593JB B6 37.9 27.0 64.3\r## 10 2013 1 1 6 LGA ORD N3ALAA AA 39.9 25.0 54.8\r## # ... with 336,766 more rows, and 7 more variables: wind_dir \u0026lt;dbl\u0026gt;,\r## # wind_speed \u0026lt;dbl\u0026gt;, wind_gust \u0026lt;dbl\u0026gt;, precip \u0026lt;dbl\u0026gt;, pressure \u0026lt;dbl\u0026gt;,\r## # visib \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r flights2 %\u0026gt;% left_join(airlines) # Moleza\r ## Joining, by = \u0026quot;carrier\u0026quot;\r## # A tibble: 336,776 x 9\r## year month day hour origin dest tailnum carrier name ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. ## 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways ## 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Airways ## 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet Airlines Inc.\r## 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Airways ## 10 2013 1 1 6 LGA ORD N3ALAA AA American Airlines Inc. ## # ... with 336,766 more rows\r # Chaves perfeitas, mas há variáveis nos dois bancos com o mesmo nome e que não são chaves\r# É necessário especificar qual a chave\rflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;)\r ## # A tibble: 336,776 x 16\r## year.x month day hour origin dest tailnum carrier year.y type ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wing mult~\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wing mult~\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wing mult~\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wing mult~\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wing mult~\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wing mult~\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000 Fixed wing mult~\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998 Fixed wing mult~\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004 Fixed wing mult~\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA \u0026lt;NA\u0026gt; ## # ... with 336,766 more rows, and 6 more variables: manufacturer \u0026lt;chr\u0026gt;,\r## # model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;, engine \u0026lt;chr\u0026gt;\r Veja que tanto flights2 quanto planes tem uma variável chamada year, mas elas significados diferentes. Em flights2 é o ano do vôo, enquanto em planes é o ano em que a aeronave entra em serviço. Na hora que fazemos o join, uma recebe o sufixo “x” e a outra “y” para a indicar a diferença. Você pode especificar o sufixo desejado para evitar confusão:\nflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;, suffix = c(\u0026quot;_flight\u0026quot;, \u0026quot;_entered_service\u0026quot;))\r ## # A tibble: 336,776 x 16\r## year_flight month day hour origin dest tailnum carrier year_entered_serv~\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 1999\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA\r## # ... with 336,766 more rows, and 7 more variables: type \u0026lt;chr\u0026gt;,\r## # manufacturer \u0026lt;chr\u0026gt;, model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;,\r## # engine \u0026lt;chr\u0026gt;\r Um aviso: cuidado com os produtos cartesianos. Não há um bom exemplo aqui no caso do flights porque o banco já está limpinho, mas se você especificar chaves com uma relação “muitos para muitos,” ele vai registrar no banco novo uma linha para cada combinação possível de variáveis. Em bancos maiores, isso geralmente estoura sua memória e trava o R. Veja este pequeno exemplo de brinquedo.\nx \u0026lt;- tribble(\r~key, ~val_x,\r1, \u0026quot;x1\u0026quot;,\r2, \u0026quot;x2\u0026quot;,\r2, \u0026quot;x3\u0026quot;,\r3, \u0026quot;x4\u0026quot;\r)\ry \u0026lt;- tribble(\r~key, ~val_y,\r1, \u0026quot;y1\u0026quot;,\r2, \u0026quot;y2\u0026quot;,\r2, \u0026quot;y3\u0026quot;,\r3, \u0026quot;y4\u0026quot;\r)\rleft_join(x, y, by = \u0026quot;key\u0026quot;)\r ## # A tibble: 6 x 3\r## key val_x val_y\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 x1 y1 ## 2 2 x2 y2 ## 3 2 x2 y3 ## 4 2 x3 y2 ## 5 2 x3 y3 ## 6 3 x4 y4\r Veja que no resultado foi criada uma linha para cada combinação de val_x e val_y que tem a mesma chave repetida. Podem até existir situações em que isso seja o que você quer mesmo, mas na minha experiência até o momento isso é problema com as chaves duplicadas e é sinal de que há algo errado.\nMas peraí, se você falou que tem 4 tipos de join, porque só dá exemplo de left_join?\nNa prática, operações relacionais são feitas de forma intencional: escolhemos bancos de dados de acordo com o valor que atribuímos a informação presente nele e pinçamos informações relacionadas de outros lugares para adicionar aquilo que é nosso foco. Por isso, na maioria dos casos, o left_join é o mais usual, porque preserva todas as informações do meu banco x e adiciona apenas as informações do banco y que combinaram com sucesso. Isso garante que eu não vou perder nenhuma informação do meu banco principal.\nPra encerrar essa parte, mais exemplos de joins.\n# Minhas chaves tem nomes diferentes, então uso um vetor do tipo c(\u0026quot;chave_x\u0026quot; = \u0026quot;chave_y\u0026quot;)\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;dest\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Georg~ 30.0 -95.3 97\r## 2 2013 1 1 5 LGA IAH N24211 UA Georg~ 30.0 -95.3 97\r## 3 2013 1 1 5 JFK MIA N619AA AA Miami~ 25.8 -80.3 8\r## 4 2013 1 1 5 JFK BQN N804JB B6 \u0026lt;NA\u0026gt; NA NA NA\r## 5 2013 1 1 6 LGA ATL N668DN DL Harts~ 33.6 -84.4 1026\r## 6 2013 1 1 5 EWR ORD N39463 UA Chica~ 42.0 -87.9 668\r## 7 2013 1 1 6 EWR FLL N516JB B6 Fort ~ 26.1 -80.2 9\r## 8 2013 1 1 6 LGA IAD N829AS EV Washi~ 38.9 -77.5 313\r## 9 2013 1 1 6 JFK MCO N593JB B6 Orlan~ 28.4 -81.3 96\r## 10 2013 1 1 6 LGA ORD N3ALAA AA Chica~ 42.0 -87.9 668\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r # Mesma coisa, só que agora juntando as informações da origem ao invés do destino\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;origin\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Newar~ 40.7 -74.2 18\r## 2 2013 1 1 5 LGA IAH N24211 UA La Gu~ 40.8 -73.9 22\r## 3 2013 1 1 5 JFK MIA N619AA AA John ~ 40.6 -73.8 13\r## 4 2013 1 1 5 JFK BQN N804JB B6 John ~ 40.6 -73.8 13\r## 5 2013 1 1 6 LGA ATL N668DN DL La Gu~ 40.8 -73.9 22\r## 6 2013 1 1 5 EWR ORD N39463 UA Newar~ 40.7 -74.2 18\r## 7 2013 1 1 6 EWR FLL N516JB B6 Newar~ 40.7 -74.2 18\r## 8 2013 1 1 6 LGA IAD N829AS EV La Gu~ 40.8 -73.9 22\r## 9 2013 1 1 6 JFK MCO N593JB B6 John ~ 40.6 -73.8 13\r## 10 2013 1 1 6 LGA ORD N3ALAA AA La Gu~ 40.8 -73.9 22\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r O assunto, obviamente, não pára por aí. Nos livros vocês encontrarão mais exemplos e funções, como é o caso do semi_join e do anti_join e das operações “set,” intersect, union e setdiff, mas isso fica pra vocês explorarem por conta própria e virem tirar as dúvidas depois!\nstringr stringr contém uma família de funções, todas começadas em str_, cuja principal preocupação é a consistência. As funções do base para strings são muito úteis, porém, seus argumentos estão numa ordem um pouco estranha, algumas funções são vetorizadas e outras não. Quando você se acostuma, até que não é tão ruim, mas voltando para o assunto discutido ontem de tornar o seu código mais legível, é interessante ter a simplicidade oferecida.\nBasicão da string Como este curso já é pra praticantes de R, vou pular algumas coisas muito básicas de string, vamos ao que interessa.\nDeterminados caracteres tem um significado especial dentro das strings. Quem já tentou copiar e colar um caminho de arquivo do Windows pro R sabe disso. Então, nesses casos, é precisar “escapar” caracteres. Por exemplo, se você quiser escrever aspas, você usar a contrabarra \\ para “escapar” um caractere.\naspa_simples \u0026lt;- '\\'' # ou \u0026quot;'\u0026quot;\raspa_dupla \u0026lt;- \u0026quot;\\\u0026quot;\u0026quot; # ou '\u0026quot;'\r A regra do escape é simples, então se você quiser colocar uma contrabarra \\\nx \u0026lt;- c(\u0026quot;\\\\\u0026quot;, \u0026quot;\\\u0026quot;\u0026quot;)\rx\r ## [1] \u0026quot;\\\\\u0026quot; \u0026quot;\\\u0026quot;\u0026quot;\r writeLines(x)\r ## \\\r## \u0026quot;\r Outros caracteres especiais úteis: \u0026quot;\\n\u0026quot; para pular uma linha, \\t para Tab. Você pode ver os outros na ajuda das aspas \u0026quot;, basta digitar no console ?\u0026quot;'\u0026quot; ou ?'\u0026quot;'.\nOutra coisa que dá pra fazer, se você precisar incluir um caractere distinto, é usar unicode:\nx \u0026lt;- \u0026quot;\\u00b5\u0026quot;\rx\r ## [1] \u0026quot;µ\u0026quot;\r Ok, mas e o pacote stringr? Bem, ele tem o intuito de facilitar e dar consistência, então, todas as funções do pacote começam com as iniciais str_ justamente para serem utilizadas com o autocompletar do RStudio, que pode ser acessada com os atalhos Ctrl + Espaço ou Tab. Vamos ver agora alguns exemplos de funções do pacote.\nComprimento da string em caracteres:\nlibrary(stringr)\r# No RStudio, basta digitar 'str_' e apertar Tab ou Ctrl + Espaço\rx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_length(x)\r ## [1] 17\r x \u0026lt;- c(\u0026quot;Ministro Sinistro\u0026quot;, \u0026quot;Abelha Gulosa\u0026quot;, \u0026quot;p\u0026quot;)\rstr_length(x)\r ## [1] 17 13 1\r Concatenação de strings:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;xyz\u0026quot;\r Use o argumento sep para definir caracteres que aparecerão entre as strings originais:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;, sep = \u0026quot; + \u0026quot;)\r ## [1] \u0026quot;x + y + z\u0026quot;\r Você pode trabalhar com strings que contém NAs:\nx \u0026lt;- c(\u0026quot;abc\u0026quot;, NA)\rstr_c(\u0026quot;|-\u0026quot;, x, \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; NA\r str_c(\u0026quot;|-\u0026quot;, str_replace_na(x), \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; \u0026quot;|-NA-|\u0026quot;\r str_c é uma função vetorizada e automaticamente recicla seus argumentos pra ter o tamanho do maior:\n# Eu na graduação\rstr_c(\u0026quot;Profe, me dá mais \u0026quot;, c(\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;), \u0026quot; semanas pra entregar, por favor!\u0026quot;)\r ## [1] \u0026quot;Profe, me dá mais 1 semanas pra entregar, por favor!\u0026quot;\r## [2] \u0026quot;Profe, me dá mais 2 semanas pra entregar, por favor!\u0026quot;\r## [3] \u0026quot;Profe, me dá mais 3 semanas pra entregar, por favor!\u0026quot;\r # Eu de manhã\rstr_c(\u0026quot;Só mais \u0026quot;, c(\u0026quot;5\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;30\u0026quot;), \u0026quot; minutinhos e eu acordo!\u0026quot;)\r ## [1] \u0026quot;Só mais 5 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 10 minutinhos e eu acordo!\u0026quot;\r## [3] \u0026quot;Só mais 20 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 30 minutinhos e eu acordo!\u0026quot;\r Se algum dos objetos passados para str_c tiver tamanho 0, ele é descartado. Útil para usar com testes lógicos.\nnome \u0026lt;- \u0026quot;Vinicius\u0026quot;\rsobrenome \u0026lt;- \u0026quot;Maia\u0026quot;\rtem_nome_do_meio \u0026lt;- FALSE\rstr_c(\r\u0026quot;Meu nome é \u0026quot;, nome, \u0026quot; \u0026quot;,\r# isso aqui retorna um vetor tamanho 0\rif (tem_nome_do_meio) \u0026quot; de Souza\u0026quot;, sobrenome,\r\u0026quot;.\u0026quot;\r)\r ## [1] \u0026quot;Meu nome é Vinicius Maia.\u0026quot;\r Conhecedores de paste reconhecerão o argumento collapse, que serve para transformar vetores de strings em uma única string.\nstr_c(c(\u0026quot;Natália\u0026quot;, \u0026quot;Martins\u0026quot;, \u0026quot;Arruda\u0026quot;), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;Natália Martins Arruda\u0026quot;\r De forma similar, conhecedores de substring deverão imediatamente reconhecer essa:\nx \u0026lt;- c(\u0026quot;Maçã\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Abacaxi\u0026quot;)\rstr_sub(x, 1, 3)\r ## [1] \u0026quot;Maç\u0026quot; \u0026quot;Ban\u0026quot; \u0026quot;Aba\u0026quot;\r str_sub(x, -3, -1)\r ## [1] \u0026quot;açã\u0026quot; \u0026quot;ana\u0026quot; \u0026quot;axi\u0026quot;\r str_sub não vai dar erro se a string for muito curta:\nstr_sub(\u0026quot;a\u0026quot;, 1, 5)\r ## [1] \u0026quot;a\u0026quot;\r Dá pra usar a forma str_sub(x) \u0026lt;- para modificar partes de strings\nstr_sub(x, 1, 1) \u0026lt;- str_to_lower(str_sub(x, 1, 1))\rx\r ## [1] \u0026quot;maçã\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;abacaxi\u0026quot;\r Note o uso de str_to_lower para mudar para minúsculas. O contrário é str_to_upper, também há uma para títulos, str_to_title, e para a primeira letra de uma frase, str_to_sentence.\nx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_to_lower(x)\r ## [1] \u0026quot;ministro sinistro\u0026quot;\r str_to_upper(x)\r ## [1] \u0026quot;MINISTRO SINISTRO\u0026quot;\r str_to_sentence(x)\r ## [1] \u0026quot;Ministro sinistro\u0026quot;\r str_to_title(x)\r ## [1] \u0026quot;Ministro Sinistro\u0026quot;\r Como vimos no readr, algumas questões relacionadas a strings dependem da língua, ou, na linguagem do pacote, são “locale dependent.” Por isso nas funções onde isso é relevante, o argumento se chama locale. Isso não é super relevante para quem trabalha com o inglês ou as línguas do oeste europeu, considerando que a maioria das línguas tem raízes similares, mas pode ser muito importante para outros idiomas. Vejamos este exemplo com a mudança da ordem das strings.\nx \u0026lt;- c(\u0026quot;abacaxi\u0026quot;, \u0026quot;escarola\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_sort(x, locale = \u0026quot;en\u0026quot;) # Inglês\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;escarola\u0026quot;\r str_sort(x, locale = \u0026quot;haw\u0026quot;) # Havaiano\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;escarola\u0026quot; \u0026quot;banana\u0026quot;\r É justamente para esses casos que str_sort e str_order oferecem a alternativa de você especificar o locale.\nTrabalhando com padrões e “expressões regulares” Expressões regulares são quase uma linguagem de programação em si, aqui, vamos dar uma passada muito rápida e ver alguns exemplos simples. São uma ferramenta muito útil, mas talvez não do interesse de todos.\nBasicamente, a ideia é fazer uma pesquisa na string, em busca de um padrão específico. Pode ser uma palavra, um espaço em branco, uma quebra de linha. Pode ficar muito complexo ou ser bem básico. O nosso objetivo aqui é que todos tenham a capacidade de trabalhar com padrões simples para corrigir inconsistências em bancos de dados, como no exemplo da aula anterior das colunas do dataset da OMS.\nPara visualizar padrões, vamos usar duas helper functions, str_view e str_view_all.\nx \u0026lt;- c(\u0026quot;mamão\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;ananas\u0026quot;)\rstr_view(x, \u0026quot;an\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rO resultado sai na aba “Viewer” do seu RStudio.\nO primeiro padrão que podemos usar é o ., que identifica qualquer caractere. As vezes na documentação esse tipo de padrão genérico é chamado de “wildcard.”\nstr_view(x, \u0026quot;.a.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rA forma de ler essa operação é: “Identifique qualquer conjunto de caracteres que tenha uma letra a no meio deles.”\nSe você quiser identificar um . numa string, você precisa usar o escape \\. Porém, a barra também é um escape! Então, ao escrever expressões regulares, precisamos usar \\\\. Veja:\ndot \u0026lt;- \u0026quot;.\u0026quot;\rcat(dot)\r ## .\r # erro\rdot \u0026lt;- \u0026quot;\\.\u0026quot;\r ## Error: '\\.' é uma seqüência de escape não reconhecida na cadeia de caracteres começando com \u0026quot;\u0026quot;\\.\u0026quot;\r # agora sim\rdot \u0026lt;- \u0026quot;\\\\.\u0026quot;\rcat(dot)\r ## \\.\r Agora em um exemplo:\nx \u0026lt;- c(\u0026quot;Praia.\u0026quot;, \u0026quot;Agora.\u0026quot;, \u0026quot;Ou.\u0026quot;, \u0026quot;Me.\u0026quot;, \u0026quot;Rebelo.\u0026quot;)\rstr_view(x, \u0026quot;a\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;u\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;o\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rTá, mas se a contrabarra é utilizada para denotar uma expressão regular tipo o ., como eu faço para pesquisar uma contrabarra?\nx \u0026lt;- \u0026quot;Jake Peralta é o melhor detetive\\\\gênio\u0026quot;\rcat(x)\r ## Jake Peralta é o melhor detetive\\gênio\r A solução é escapar o escape do escape, sacou?\nstr_view(x, \u0026quot;\\\\\\\\\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Jake Peralta é o melhor detetive\\\\gênio\\n\"},\"evals\":[],\"jsHooks\":[]}\rÉ enrolado mesmo…\nPara não estender muito o assunto, vamos ver vários exemplos de caracteres especiais a ser usados em expressões regulares.\n^ encontra o início de uma string\nx \u0026lt;- c(\u0026quot;maçã\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;mamão\u0026quot;)\rstr_view(x, \u0026quot;^m\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\r$ encontra o final\nstr_view(x, \u0026quot;a$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\rPara forçar a expressão a achar apenas a palavra completa, use os dois\nx \u0026lt;- c(\u0026quot;vitamina de banana\u0026quot;, \u0026quot;sundae de banana\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_view(x, \u0026quot;banana\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;^banana$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rUse classes de caracteres para encontrar genéricos\nQualquer digito:\nx \u0026lt;- \u0026quot;15 de Maio de 2021.\u0026quot;\rstr_view(x, \u0026quot;\\\\d\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer espaço em branco:\nstr_view(x, \u0026quot;\\\\s\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere de um grupo: [abc]\nstr_view(x, \u0026quot;[M]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[eM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[deM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere menos esses: [^abc]\nstr_view(x, \u0026quot;[^15]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de Maio de ]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rUsar uma classe pra evitar digitar 5 milhões de contrabarras\nstr_view(x, \u0026quot;[.]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(\u0026quot;a*c\u0026quot;, \u0026quot;[*]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n a*c\\n\"},\"evals\":[],\"jsHooks\":[]}\rVocê pode misturar strings com classes também\nx \u0026lt;- c(\u0026quot;15 de Maio de 2021.\u0026quot;, \u0026quot;16 de Maio de 2021.\u0026quot;)\rstr_view(x, \u0026quot;1[56] de Maio\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n 16 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rInfelizmente, alguns caracteres tem significado especial dentro das classes, e você tem que usar contrabarras para fugir deles: ] \\ ^ e -.\nVocê pode lidar com repetições\nx \u0026lt;- c(\u0026quot;Mariele\u0026quot;, \u0026quot;Marielle\u0026quot;, \u0026quot;Mariellle\u0026quot;, \u0026quot;Marie\u0026quot;)\rstr_view(x, \u0026quot;Mariell?e\u0026quot;) # l aparece 0 ou 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel+e\u0026quot;) # l aparece 1 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel*\u0026quot;) # l aparece 0 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{0}\u0026quot;) # l aparece exatamente 0 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1}\u0026quot;) # l aparece exatamente 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2}\u0026quot;) # l aparece exatamente 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{3}\u0026quot;) # l aparece exatamente 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,}\u0026quot;) # l aparece exatamente 1 vez ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,}\u0026quot;) # l aparece exatamente 2 vezes ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,2}\u0026quot;) # l aparece de 1 a 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,3}\u0026quot;) # l aparece de 2 a 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rEsse assunto é enorme, e ainda estamos só na superfície. Há grupos, lookarounds, e muitos outros detalhes envolvendo expressões regulares, e vocês podem consultar os livros de referência para mergulhar mais fundo. Mas vamos parar por aqui para nos concentrar no que interessa.\nEm geral, temos um banco de dados com strings problemáticas, tipo erros de digitação, inconsistências etc. O primeiro passo, em geral, é detectar os problemas.\nx \u0026lt;- c(\u0026quot;São Paulo\u0026quot;, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;Sao Paulo\u0026quot;, \u0026quot;sp\u0026quot;, \u0026quot;SP\u0026quot;, \u0026quot;Sp\u0026quot;)\rstr_detect(x, \u0026quot;ã\u0026quot;)\r ## [1] TRUE FALSE FALSE FALSE FALSE FALSE\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] FALSE FALSE FALSE TRUE TRUE TRUE\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;)\r ## [1] FALSE TRUE TRUE FALSE FALSE FALSE\r Você pode se utilizar do fato da resposta ser um vetor lógico para descobrir quantos problemas você tem\n# Contagens\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% sum()\r ## [1] 1\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% sum()\r ## [1] 3\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% sum()\r ## [1] 2\r # Proporções\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.1666667\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.5\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.3333333\r Depois de detectar seus problemas, você pode querer extrair uma parte dos seus casos: use str_subset\nstr_subset(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Em geral, no entanto, você vai estar trabalhando num data frame. Então use dplyr::filter e str_detect.\ndf \u0026lt;- tibble::tibble(\rnome = c(\u0026quot;Marcos\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;cebolinha\u0026quot;, \u0026quot;Beiçola\u0026quot;, \u0026quot;nadir\u0026quot;, \u0026quot;Monica\u0026quot;),\ruf = x,\rdtnsc = c(\u0026quot;15 de Maio de 1980\u0026quot;, \u0026quot;1 de Jan de 2001\u0026quot;, \u0026quot;6 de Ago de 1993\u0026quot;, \u0026quot;20 de Abril de 1964\u0026quot;, \u0026quot;24 de Nov de 1975\u0026quot;, \u0026quot;14 de Dezembro de 1997\u0026quot;)\r)\rdf %\u0026gt;% dplyr::filter(str_detect(uf, \u0026quot;[Ss][Pp]\u0026quot;))\r ## # A tibble: 3 x 3\r## nome uf dtnsc ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Beiçola sp 20 de Abril de 1964 ## 2 nadir SP 24 de Nov de 1975 ## 3 Monica Sp 14 de Dezembro de 1997\r Você pode contar quantos matches você tem str_count\nstr_count(x, \u0026quot;o\u0026quot;)\r ## [1] 2 0 2 0 0 0\r str_count(x, \u0026quot;[Oo]\u0026quot;)\r ## [1] 2 2 2 0 0 0\r # e usar num data frame\rdf %\u0026gt;% dplyr::mutate(vogais = str_count(uf, \u0026quot;[aeiou]\u0026quot;),\rconsoantes = str_count(uf, \u0026quot;[^aeiou]\u0026quot;))\r ## # A tibble: 6 x 5\r## nome uf dtnsc vogais consoantes\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 4 5\r## 2 rogério SAO PAULO 1 de Jan de 2001 0 9\r## 3 cebolinha Sao Paulo 6 de Ago de 1993 5 4\r## 4 Beiçola sp 20 de Abril de 1964 0 2\r## 5 nadir SP 24 de Nov de 1975 0 2\r## 6 Monica Sp 14 de Dezembro de 1997 0 2\r Você pode extrair str_extract as informações que você quer\nstr_extract(df$dtnsc, \u0026quot;\\\\d+\u0026quot;)\r ## [1] \u0026quot;15\u0026quot; \u0026quot;1\u0026quot; \u0026quot;6\u0026quot; \u0026quot;20\u0026quot; \u0026quot;24\u0026quot; \u0026quot;14\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\d+$\u0026quot;)\r ## [1] \u0026quot;1980\u0026quot; \u0026quot;2001\u0026quot; \u0026quot;1993\u0026quot; \u0026quot;1964\u0026quot; \u0026quot;1975\u0026quot; \u0026quot;1997\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;)\r ## [1] \u0026quot; de Maio de \u0026quot; \u0026quot; de Jan de \u0026quot; \u0026quot; de Ago de \u0026quot; \u0026quot; de Abril de \u0026quot; ## [5] \u0026quot; de Nov de \u0026quot; \u0026quot; de Dezembro de \u0026quot;\r # Na tibble\rdf %\u0026gt;% dplyr::mutate(\rdia = str_extract(dtnsc, \u0026quot;\\\\d+\u0026quot;),\rmes = str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;),\rano = str_extract(dtnsc, \u0026quot;\\\\d+$\u0026quot;))\r ## # A tibble: 6 x 6\r## nome uf dtnsc dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 15 \u0026quot; de Maio de \u0026quot; 1980 ## 2 rogério SAO PAULO 1 de Jan de 2001 1 \u0026quot; de Jan de \u0026quot; 2001 ## 3 cebolinha Sao Paulo 6 de Ago de 1993 6 \u0026quot; de Ago de \u0026quot; 1993 ## 4 Beiçola sp 20 de Abril de 1964 20 \u0026quot; de Abril de \u0026quot; 1964 ## 5 nadir SP 24 de Nov de 1975 24 \u0026quot; de Nov de \u0026quot; 1975 ## 6 Monica Sp 14 de Dezembro de 1997 14 \u0026quot; de Dezembro de \u0026quot; 1997\r # Melhor ainda\rdf %\u0026gt;% tidyr::extract(\rdtnsc, c(\u0026quot;dia\u0026quot;, \u0026quot;mes\u0026quot;, \u0026quot;ano\u0026quot;), regex = \u0026quot;(\\\\d+) de (\\\\D+) de (\\\\d+$)\u0026quot;\r)\r ## # A tibble: 6 x 5\r## nome uf dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 Maio 1980 ## 2 rogério SAO PAULO 1 Jan 2001 ## 3 cebolinha Sao Paulo 6 Ago 1993 ## 4 Beiçola sp 20 Abril 1964 ## 5 nadir SP 24 Nov 1975 ## 6 Monica Sp 14 Dezembro 1997\r Similar a ideia de extração, podemos substituir com str_replace\nstr_replace(x, \u0026quot;[Ss][Pp]\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot;\r str_replace(x, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r str_replace(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Tanto str_extract quanto str_replace substituem apenas a primeira marca, se você quiser substituir todas, utilize str_..._all\nstr_extract_all(x, \u0026quot;a\u0026quot;, simplify = TRUE)\r ## [,1] [,2]\r## [1,] \u0026quot;a\u0026quot; \u0026quot;\u0026quot; ## [2,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [3,] \u0026quot;a\u0026quot; \u0026quot;a\u0026quot; ## [4,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [5,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [6,] \u0026quot;\u0026quot; \u0026quot;\u0026quot;\r str_replace_all(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Pãulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r O assunto não acaba, mas vamos parar por aqui. Novamente, recomendo consultarem os materiais para quem quiser ir mais a fundo nisso. É bem capaz de no andar da carruagem aparecerem outros exemplos nos quais a manipulação de strings pode ser importante.\nforcats Esse é um pacotinho muito que facilita bastante a vida de quem trabalha com variável categórica, ou, no R, os factors. Ele consiste em uma série de “helper functions” baseadas em funções do base e do stats que trabalham com os componentes de um factor, ou seja, seus levels e seus values.\nImagino que todos aqui estão familiarizados com fatores e com a sua criação, então vamos direto ao que interessa. Educação é um vetor de caracteres que vem com os níveis educacionais de um população.\neducacao \u0026lt;- c(\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;,\r\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;)\rx \u0026lt;- factor(educacao, levels = c(\u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;))\rx\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Fundamental Médio Superior\r levels(x)\r ## [1] \u0026quot;Fundamental\u0026quot; \u0026quot;Médio\u0026quot; \u0026quot;Superior\u0026quot;\r relevel(x, \u0026quot;Superior\u0026quot;)\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Superior Fundamental Médio\r Em geral, diversas tarefas envolvendo fatores no base não são muito simples. Por exemplo, se eu quiser modificar os nomes dos níveis de um fator depois dele já estar criado, modificar a ordem dos níveis, ou agrupar diversos níveis em um só. forcats vem justamente oferecer soluções nesse sentido. Normalmente, estamos trabalhando com bancos de dados, e não com um vetor solitário, por isso, vamos usar o gss_cat, uma amostra do General Social Survey aplicado pelo NORC e pela Universidade de Chicago, que vem no pacote forcats.\nlibrary(forcats)\rgss_cat\r ## # A tibble: 21,483 x 9\r## year marital age race rincome partyid relig denom tvhours\r## \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 2000 Never ma~ 26 White $8000 to ~ Ind,near r~ Protesta~ Souther~ 12\r## 2 2000 Divorced 48 White $8000 to ~ Not str re~ Protesta~ Baptist~ NA\r## 3 2000 Widowed 67 White Not appli~ Independent Protesta~ No deno~ 2\r## 4 2000 Never ma~ 39 White Not appli~ Ind,near r~ Orthodox~ Not app~ 4\r## 5 2000 Divorced 25 White Not appli~ Not str de~ None Not app~ 1\r## 6 2000 Married 25 White $20000 - ~ Strong dem~ Protesta~ Souther~ NA\r## 7 2000 Never ma~ 36 White $25000 or~ Not str re~ Christian Not app~ 3\r## 8 2000 Divorced 44 White $7000 to ~ Ind,near d~ Protesta~ Luthera~ NA\r## 9 2000 Married 44 White $25000 or~ Not str de~ Protesta~ Other 0\r## 10 2000 Married 47 White $25000 or~ Strong rep~ Protesta~ Souther~ 3\r## # ... with 21,473 more rows\r Contagens\nUma das primeiras coisas que interessa ao lidar com fatores, é obter suas contagens, o que é algo muito simples utilizando a gramática do dplyr.\n# Função count\rgss_cat %\u0026gt;% count(race)\r ## # A tibble: 3 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% count(race, .drop = FALSE)\r ## # A tibble: 4 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r## 4 Not applicable 0\r # Visualização com ggplot\rlibrary(ggplot2)\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar()\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar() + scale_x_discrete(drop = FALSE)\r Note o uso do argumento drop nos dois casos, para indicar que casos com 0 observações não devem ser removidos do resultado.\nModificando a ordem A segunda tarefa comum quando trabalhamos com fatores é modificar a ordem em que eles aparecem. Não é tanto o caso quando trabalhamos com fatores ordenados, mas diversos tipos de variáveis categóricas não possuem uma ordem lógica pre-definida e, mesmo assim, nos interessa apresentá-los de acordo com uma determinada hierarquia visual, seja porque eles são os mais frequentes ou porque queremos destacar algum elemento em particular. forcats implementa diversas estratégias de reordenamento de fatores. Vamos vê-las brevemente.\nDigamos que eu queira saber o tempo médio de televisão assistida por membros das diversas religiões. Eu poderia produzir um sumário e depois plotar isso num gráfico.\nrelig_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(relig) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r O display está técnicamente correto, mas a forma desorganizada dos níveis no eixo Y dificulta a nossa capacidade de fazer comparações. Talvez fosse mais interessante ordenar este resultado por ordem decrescente do número de horas de tv. Mas, como fazer isso de forma direta, sem precisar realizar diversas computações?\n# Direto no plot\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, fct_reorder(relig, tvhours))) + geom_point()\r # Antes de passar o data.frame para a plotagem\rrelig_summary %\u0026gt;% mutate(relig = fct_reorder(relig, tvhours)) %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r Note como posso aplicar a transformação diretamente na variável durante o processo de plotagem, ou antes, e uma invocação de mutate. Na minha opinião, o segundo jeito é o mais adequado, por duas razões: é mais fácil de digitar, inserir e retirar do código e é mais fácil para um leitor identificar que uma transformação foi feita na variável plotada.\nOutro exemplo: que tal exarminarmos a relação entre a idade e a renda declarada? Primeiro, é preciso construir um sumário, parecido com o primeiro:\nrincome_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(rincome) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrincome_summary %\u0026gt;% mutate(rincome = fct_reorder(rincome, age)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Aqui, o reordenamento das variáveis de acordo com a idade não faz muito sentido, porque os níveis de renda tem uma ordem própria. Nesse caso, não é recomendado utilizar fct_reorder.\nrincome_summary %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Só que ao plotar, notamos um problema: a categoria “Not applicable” ficou primeiro e isso desorganiza visualmente nosso gráfico. Sem problema! Utilizamos fct_relevel para modificar a ordem de uma variável arbitrariamente. O padrão é colocar pro começo (Parecido com o comportamento de stats::relevel), mas você pode especificar outra posição.\nrincome_summary %\u0026gt;% mutate(rincome = fct_relevel(rincome, \u0026quot;Not applicable\u0026quot;)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Notem como nos exemplos acima, o uso do %\u0026gt;% nos permite alterar partes do nosso código de maneira interativa para chegar no resultado desejado.\nOutro tipo de mudança de ordem interessante ocorre quando temos uma terceira “dimensão” no nosso gráfico. Em geral, utilizamos cores, formas ou linhas quebradas para diferenciar entre categorias e gostaríamos que a nossa legenda acompanhasse a tendência do gráfico. Compare:\nby_age \u0026lt;- gss_cat %\u0026gt;%\rfilter(!is.na(age)) %\u0026gt;%\rcount(age, marital) %\u0026gt;%\rgroup_by(age) %\u0026gt;%\rmutate(prop = n / sum(n))\r# Sem alteração na ordem\rby_age %\u0026gt;% ggplot(aes(age, prop, colour = marital)) +\rgeom_line(na.rm = TRUE)\r # Com alteração na ordem\rggplot(by_age, aes(age, prop, colour = fct_reorder2(marital, age, prop))) +\rgeom_line() +\rlabs(colour = \u0026quot;marital\u0026quot;)\r No caso de fct_reorder2, é melhor fazer a alteração de ordem dentro da função gráfica, pois dentro uma invocação de mutate, ela não funcionou durante meus testes.\nPor último, podemos querer ordenar um gráfico de barras de acordo com a frequência das categorias, o que podemos fazer com fct_infreq e fct_rev (opcional).\ngss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r # OU\rgss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq() %\u0026gt;% fct_rev()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r Notem o uso do pipe na hora de modificar a variável “marital.”\nModificando os níveis O outro tipo de operação bastante comum é a alteração nos níves do fator. Em geral, queremos que os nossos níveis sejam representativos das nossas categorias de análise, sejam de fácil leitura e entendimento e contenham um número significativo de observações. Por essa razão, frequentemente precisamos alterar os rótulos, agrupar categorias, etc.\nVejamos o exemplo da variável partyid, que registra a identificação do entrevistado com os partidos políticos dos EUA.\ngss_cat %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 154\r## 2 Don't know 1\r## 3 Other party 393\r## 4 Strong republican 2314\r## 5 Not str republican 3032\r## 6 Ind,near rep 1791\r## 7 Independent 4119\r## 8 Ind,near dem 2499\r## 9 Not str democrat 3690\r## 10 Strong democrat 3490\r Vamos supor que, por qualquer motivo, essa forma de representação das categorias não nos satisfaz. Vejamos algumas das ferramentas que podemos utilizar para modificar esse fator.\nPodemos, simplesmente, reescrever essas categorias de forma mais completa:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r\u0026quot;Outro partido\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Não sei\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Sem resposta\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Sem resposta 154\r## 2 Não sei 1\r## 3 Outro partido 393\r## 4 Republicano, forte 2314\r## 5 Republicano, fraco 3032\r## 6 Independente, próx. repub. 1791\r## 7 Independente 4119\r## 8 Independente, próx. democ. 2499\r## 9 Democrata, fraco 3690\r## 10 Democrata, forte 3490\r A função utilizada é fct_recode e ela é a mais genérica e flexível de todas, porém, exige que cada nível seja modificado individualmente. Dentro dela, é possível agrupar vários níveis associando vários níveis antigos a um mesmo nível novo. Veja o exemplo:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r# Note o nome\r\u0026quot;Outro\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 8 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano, forte 2314\r## 3 Republicano, fraco 3032\r## 4 Independente, próx. repub. 1791\r## 5 Independente 4119\r## 6 Independente, próx. democ. 2499\r## 7 Democrata, fraco 3690\r## 8 Democrata, forte 3490\r Se você quiser recategorizar um fator que tem muitos níveis para um menor, com poucos níveis, utilize fct_collapse:\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\rOutro = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\rRepublicano = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\rIndependente = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\rDemocrata = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Repare que do lado esquerdo, nos valores novos, não foi necessário usar aspas. É preciso cuidado com essa característica dos verbos do tidyverse. Ela se chama “tidy evaluation” e está um pouco fora do escopo do curso. Basicamente, se rolar dúvida ou der erros, se for usar acentos ou algum caractere diferente, use aspas.\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\r\u0026quot;Outro\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\r\u0026quot;Republicano\u0026quot; = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\r\u0026quot;Independente\u0026quot; = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\r\u0026quot;Democrata\u0026quot; = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Outro tipo de mudança importante no número de níveis é agrupar os níveis menos frequentes, por exemplo, para produzir uma visualização que dê maior destaque aos níveis mais frequentes. Esse é o trabalho de fct_lump.\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Other 913\r Note que usando o argumento n eu indico quantos níveis eu quero. No caso, escolhi os 5 níveis mais frequentes e todos os outros são automáticamente agrupados na categoria “Other.” Posso mudar esse nome também:\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5, other_level = \u0026quot;Outros\u0026quot;)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Outros 913\r Exercícios   Encontre os vôos que:\n Atrasaram mais de duas horas Com destino a Houston (IAH ou HOU) Operados pela United, American ou Delta Decolaram entre julho e setembro Chegaram com mais de duas horas de atraso, mas não decolaram com atraso Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo Decolaram entre a meia-noite e 6 da manhã (inclusive)    Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).\n  Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.\n  As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.\n  O que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?\n  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: “150,” “219,” “312,” “471.” Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;115\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;118\u0026quot; \u0026quot;116\u0026quot; \u0026quot;100\u0026quot; \u0026quot;108\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;103\u0026quot;\r## [13] \u0026quot;116\u0026quot; \u0026quot;111\u0026quot; \u0026quot;111\u0026quot; \u0026quot;115\u0026quot; \u0026quot;114\u0026quot; \u0026quot;102\u0026quot; \u0026quot;116\u0026quot; \u0026quot;103\u0026quot; \u0026quot;120\u0026quot; \u0026quot;115\u0026quot; \u0026quot;123\u0026quot; \u0026quot;103\u0026quot;\r## [25] \u0026quot;119\u0026quot; \u0026quot;230\u0026quot; \u0026quot;228\u0026quot; \u0026quot;225\u0026quot; \u0026quot;214\u0026quot; \u0026quot;225\u0026quot; \u0026quot;206\u0026quot; \u0026quot;207\u0026quot; \u0026quot;208\u0026quot; \u0026quot;202\u0026quot; \u0026quot;210\u0026quot; \u0026quot;229\u0026quot;\r## [37] \u0026quot;204\u0026quot; \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;218\u0026quot; \u0026quot;223\u0026quot; \u0026quot;221\u0026quot; \u0026quot;205\u0026quot; \u0026quot;214\u0026quot; \u0026quot;220\u0026quot; \u0026quot;227\u0026quot; \u0026quot;202\u0026quot; \u0026quot;224\u0026quot;\r## [49] \u0026quot;214\u0026quot; \u0026quot;201\u0026quot; \u0026quot;305\u0026quot; \u0026quot;310\u0026quot; \u0026quot;309\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;303\u0026quot; \u0026quot;312\u0026quot; \u0026quot;310\u0026quot;\r## [61] \u0026quot;303\u0026quot; \u0026quot;302\u0026quot; \u0026quot;305\u0026quot; \u0026quot;303\u0026quot; \u0026quot;304\u0026quot; \u0026quot;306\u0026quot; \u0026quot;309\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;309\u0026quot; \u0026quot;306\u0026quot; \u0026quot;311\u0026quot;\r## [73] \u0026quot;306\u0026quot; \u0026quot;307\u0026quot; \u0026quot;310\u0026quot; \u0026quot;417\u0026quot; \u0026quot;477\u0026quot; \u0026quot;470\u0026quot; \u0026quot;493\u0026quot; \u0026quot;414\u0026quot; \u0026quot;446\u0026quot; \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;476\u0026quot;\r## [85] \u0026quot;432\u0026quot; \u0026quot;490\u0026quot; \u0026quot;499\u0026quot; \u0026quot;429\u0026quot; \u0026quot;414\u0026quot; \u0026quot;455\u0026quot; \u0026quot;409\u0026quot; \u0026quot;462\u0026quot; \u0026quot;447\u0026quot; \u0026quot;483\u0026quot; \u0026quot;458\u0026quot; \u0026quot;471\u0026quot;\r## [97] \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;464\u0026quot; \u0026quot;483\u0026quot;\r  Explore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?\n  Qual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?\n  A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?\n  Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?\n  ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"fa0304036676bc16efc6e61759597fd7","permalink":"https://laddem.github.io/courses/tidyverse/dia2/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia2/","section":"courses","summary":"Operações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.","tags":null,"title":"stringr, forcats e dplyr","type":"book"},{"authors":null,"categories":null,"content":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.frame e o código utilizado para gerar o gráfico. Acho que se o termo sobrecarga infromacional não existisse, eu teria inventado ele na hora.\nAnedotas a parte, não é culpa do autor. O livro pressupõe um certo conhecimento prévio que eu não tinha quando o li pela primeira vez. Imagino que a maioria de vocês já viu gráficos na vida e até construiu um ou dois deles usando esse ou outros softwares estatísticos. O que talvez nem todos tenham claro na mente é que os gráficos são uma codificação num sistema de coordenadas das informações presentes em um banco de dados através de escalas. Vamos destrinchar um pouco melhor isso:\nSuponha que você tenha o banco de dados mpg, presente na biblioteca ggplot2.\nlibrary(ggplot2)\rmpg\r ## # A tibble: 234 x 11\r## manufacturer model displ year cyl trans drv cty hwy fl class\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 audi a4 1.8 1999 4 auto(l~ f 18 29 p comp~\r## 2 audi a4 1.8 1999 4 manual~ f 21 29 p comp~\r## 3 audi a4 2 2008 4 manual~ f 20 31 p comp~\r## 4 audi a4 2 2008 4 auto(a~ f 21 30 p comp~\r## 5 audi a4 2.8 1999 6 auto(l~ f 16 26 p comp~\r## 6 audi a4 2.8 1999 6 manual~ f 18 26 p comp~\r## 7 audi a4 3.1 2008 6 auto(a~ f 18 27 p comp~\r## 8 audi a4 quat~ 1.8 1999 4 manual~ 4 18 26 p comp~\r## 9 audi a4 quat~ 1.8 1999 4 auto(l~ 4 16 25 p comp~\r## 10 audi a4 quat~ 2 2008 4 manual~ 4 20 28 p comp~\r## # ... with 224 more rows\r De posse desse banco, você gostaria de construir um gráfico relacionando a eficiência do combustível de um carro (hwy) com o seu peso (displ). Sábio e malandro no ggplot2, você escreve o código a seguir:\nggplot(mpg, aes(displ,hwy, color = class)) +\rgeom_point()\r Mas fica a dúvida: que escolhas foram feitas no momento de traduzir a minha intenção de produzir um diagrama de dispersão (scatterplot) do peso com o consumo de gasolina para a representação gráfica diante de nós? Que unidades de medidas estão dispostas nos eixos X e Y? Qual o sistema de coordenadas no qual isto foi representado? Quem define os limites de início e fim de cada eixo? Como cada ponto recebeu a sua cor? Essas perguntas podem parecer óbvias ou tontas, dependendo da perspectiva e da experiência do usuário, mas elas são centrais para entender como construir e modificar gráficos no ggplot2.\nO pacote é inspirado pela Gramática dos Gráficos, e procura decompor o processo de produção de gráficos em uma sequência de camadas que vão se sobrepondo até chegar no objeto desejado.\n a camada dos dados e do mapeamento estético (que variáveis vão em quais eixos/escalas) a camada dos objetos geométricos (pontos, linhas, barras, etc.) a camada das escalas (natural? logarítmica? escala de cores?) a camada das facetas (mini gráficos separados por alguma característica) a camada das transformações estatísticas (distribuições de probabilidade, contagens, proporções, etc.) o sistema de coordenadas (cartesiano? polar?)  Obviamente, nem todo gráfico possui essa complexidade, e na verdade, a maioria dos gráficos que fazemos se encaixa num pequeno subgrupo de todas essas especificações, então porque toda essa complexidade?\nPorque não? Em primeiro lugar, se você está produzindo visualizações simples que cumprem seu propósito, você não precisa se preocupar com quase nada disso, os padrões do ggplot2, via de regra, se encaixam perfeitamente na maioria dos problemas e, em segundo lugar, se você sentir a necessidade de ir mais fundo e produzir visualizações mais complexas, as mesmas ferramentas que você já conhece estão a sua disposição.\nTrês gráficos para entender a mecânica do ggplot2 Scatterplots Voltemos para o nosso gráfico original, vamos decompô-lo em suas camadas como se estivéssemos construindo ele passo-a-passo:\n# Primeiro, a camada dos dados e mapeamentos estéticos\rggplot(\r# Dados\rdata = mpg,\r# Que variável vai em que eixo\rmapping = aes(x = displ, y = hwy)\r)\r Examinando a saída, vemos que ggplot desenhou um canvas com nossas variáveis, mas ainda nenhum objeto geométrico. Tudo bem, adicionamos (+) uma camada de objetos geométricos, no caso, pontos.\n# Objetos geométricos começam com \u0026quot;geom_\u0026quot;\rggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + # adicionamos\rgeom_point()\r Agora, nosso gráfico já tem uma cara de diagrama de dispersão. Mas ainda não tem as cores das classes de automóvel. Tudo bem, voltamos para a primeira camada e informamos que queremos um terceiro mapeamento estético.\n# A cor é mapeada a variável class\rggplot(data = mpg, mapping = aes(\rx = displ, y = hwy,\rcolor = class) # novo mapeamento estético\r) + # adicionamos\rgeom_point()\r Ok, chegamos no gráfico original. Mas como podem entender melhor as outras camadas? Vamos pensar, por exemplo, que talvez queiramos trabalhar a variável hwy numa escala logarítmica. Poderíamos transformar a variável original, claro, mas o ggplot2 nos permite especificar as transformações diretamente nas escalas do gráfico!\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() + # adicionando uma nova \u0026quot;camada\u0026quot;\rscale_y_continuous(trans = \u0026quot;log\u0026quot;)\r Mas você, leitor, não ficou satisfeito. Você queria era transformar a variável displ em raíz quadrada. Tudo bem:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;) # especificamos a transformação na escala de x\r Outro leitor não estava interessado nas escalas dos eixos x ou y, que são contínuas nesse caso, mas sim na seleção de cores utilizadas para representar a escala das cores. Por ser um leitor conhecedor das formas de deficiência visual cromática, ele optou pelas paletas de cores do Colorbrewer:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) # transformação da escala de cores\r Um geógrafo entrou na conversa e disse que o sistema cartesiano de coordenadas estava iludindo os leitores a pensar que a relação entre peso e consumo de combustível estava distorcida pelas diferenças entre as unidades de medida das variáveis, produzida pelo sistema cartesiano de coordenadas, então ele sugeriu que usássemos um sistema de coordenadas fixas:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) +\rcoord_fixed()\r Ficou horrível, esse geógrafo não sabe nada. Como recompensa pela sua ignorância, agora ele ocupa um cargo no primeiro escalão do Ministério da Saúde.\nOutro pesquisador estava interessado em visualizar as relações entre consumo, peso e classe, mas levando em consideração o fabricante do veículo, então, ele sugeriu que construíssemos um gráfico para cada. Você, que é preguiçoso, usou a capacidade do ggplot2 de dividir gráficos através da introdução de uma camada de facets.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + # adicionamos mais uma camada\rfacet_wrap(~manufacturer) # de facetas\r Agora, muito satisfeitos com o resultado do nosso trabalho, resolvemos incluir o gráfico numa publicação, mas do jeito que está, não dá. Então adicionamos mais algumas camadas para torná-lo apresentável.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + facet_wrap(~manufacturer) +\r# Colocamos os nomes nos eixos\rlabs(title = \u0026quot;Relação entre peso e economia de combustível de automóveis\u0026quot;,\rsubtitle = \u0026quot;Separado por categoria e fabricante\u0026quot;,\rx = \u0026quot;Peso do veículo em toneladas\u0026quot;,\ry = \u0026quot;Consumo em milhas por galão de 3,5l\u0026quot;,\rcolor = \u0026quot;Categoria\u0026quot;,\rcaption = \u0026quot;Fonte: Agência de Proteção Ambiental Estadunidense.\u0026quot;) +\r# Escolhemos um tema bonito\rtheme_light() +\r# Mudamos a posição da legenda, pra ficar mais jeitozinho\rtheme(legend.position = \u0026quot;bottom\u0026quot;)\r Pronto. Mamãe vai ficar orgulhosa.\nBrincadeiras a parte, entendendo um pouco melhor a gramática do gráfico, podemos construir nossas visualizações passo a passo, até chegar no resultado desejado.\nLineplots O segundo exemplo que quero mostrar pra vocês é a construção de gráficos com linhas. Eles são interessantes porque dão bastante dor de cabeça pra quem está começando. Vamos continuar brincando com o mpg.\nAgora que eu fiz meu diagrama de dispersão, estou interessado em começar um processo de modelagem, mas primeiro quero ter uma noção visual da relação entre as variáveis.\nggplot(mpg, aes(displ, hwy)) +\rgeom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r geom_smooth ajusta um modelo aos dados e desenha a linha com os valores preditos. Agora que temos dois objetos geométricos, talvez seja interessante ver o que acontece se eu colocar as cores das classes.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Veja que ele fez o possível para aplicar as escalas nos dois objetos geométricos. Eu pedi para geom_smooth tirar os intervalos de confiança para melhorar a visibilidade. Mas e seu eu quisesse ver a cor dos pontos, mas manter a linha de tendência geral? Você pode especificar mapeamentos estéticos gerais (na primeira camada) ou mapeamentos estéticos locais (dentro de cada camada geométrica).\nggplot(mpg, aes(displ, hwy)) + # mapeamentos gerais, se aplicam a todos os objetos\rgeom_point(aes(color = class)) + # mapeamento local, só se aplica aqui\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Ok, mas e se eu quisesse um modelo linear ao invés de um \u0026ldquo;Smoother de Loess\u0026rdquo;?\nggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Não vou entrar muito nos argumentos de cada objeto geométrico e função, vocês podem aprender isso na prática olhando a documentação das funções que são do interesse de vocês. ?geom_smooth para ver todas as possibilidades. Uma dica boa é usar geom_smooth para verificar interações entre variáveis numéricas e fatores.\nggplot(mpg, aes(displ, hwy, color = factor(cyl))) + geom_point() +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Ok, mas e se temos um gráfico de linhas mais tradicional, tipo uma série histórica?\neconomics\r ## # A tibble: 574 x 6\r## date pce pop psavert uempmed unemploy\r## \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 507. 198712 12.6 4.5 2944\r## 2 1967-08-01 510. 198911 12.6 4.7 2945\r## 3 1967-09-01 516. 199113 11.9 4.6 2958\r## 4 1967-10-01 512. 199311 12.9 4.9 3143\r## 5 1967-11-01 517. 199498 12.8 4.7 3066\r## 6 1967-12-01 525. 199657 11.8 4.8 3018\r## 7 1968-01-01 531. 199808 11.7 5.1 2878\r## 8 1968-02-01 534. 199920 12.3 4.5 3001\r## 9 1968-03-01 544. 200056 11.7 4.1 2877\r## 10 1968-04-01 544 200208 12.3 4.6 2709\r## # ... with 564 more rows\r Podemos criar um gráfico de linhas tendo como base a data (date) e alguma das variáveis registradas, como a taxa de desemprego.\nggplot(economics, aes(x = date, y = uempmed)) +\rgeom_line()\r Ou o consumo em bilhões de dólares\nggplot(economics, aes(x = date, y = pce)) +\rgeom_line()\r Ou a população\nggplot(economics, aes(x = date, y = pop)) +\rgeom_line()\r Ok, mas eu quero comparar visualmente o que ocorre com uma variável quando a outra muda. Podemos recorrer ao que aprendemos sobre mapeamentos estéticos globais e locais.\nggplot(economics, aes(x = date)) +\rgeom_line(aes(y = uempmed)) +\rgeom_line(aes(y = pce)) +\rgeom_line(aes(y = pop))\r Ficou meio ruim, porque as variável tem grandezas distintas. Podemos tentar resolver esse problema aplicando transformações na variável idade, mas meio que pra qualquer lugar onde caminhos, batemos numa parede ou noutra. Esse tipo de solução é muito frequente entre pessoas que vem do base pro ggplot2, porque no base estamos acostumado a ideia de adicionar mais objetos geométricos ao nosso gráfico original adicionando invocações à funções como lines ou text. Porém, a solução preferida no tidyverse é aplicar uma transformação no banco original de tal forma que as nossas variáveis numéricas caiam todas num par que especifica o nome da variável | e o valor dela.\nlibrary(tidyr)\reconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;)\r ## # A tibble: 2,870 x 3\r## date variavel valor\r## \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 pce 507. ## 2 1967-07-01 pop 198712 ## 3 1967-07-01 psavert 12.6\r## 4 1967-07-01 uempmed 4.5\r## 5 1967-07-01 unemploy 2944 ## 6 1967-08-01 pce 510. ## 7 1967-08-01 pop 198911 ## 8 1967-08-01 psavert 12.6\r## 9 1967-08-01 uempmed 4.7\r## 10 1967-08-01 unemploy 2945 ## # ... with 2,860 more rows\r Talvez não fique imediatamente claro para todos porque eu optei por esta solução, mas talvez essa próxima figura fale mais que mil palavras.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line() +\rfacet_wrap(~variavel, scales = \u0026quot;free_y\u0026quot;, ncol = 1)\r A ênfase em usar tidy data no tidyverse decorre do fato de que todos os pacotes são programados para usar a forma de organização do banco como uma alavanca para facilitar a análise de dados. Vejam esta outra pipeline.\n# Como vamos fazer algumas transformações nos dados, vamos carregar o dplyr aqui\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r ## The following objects are masked from 'package:stats':\r## ## filter, lag\r ## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, shape = variavel)) +\rgeom_line()\r E agora vejam um dos erros mais comuns de quem está começando:\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line()\r Ao não especificar uma separação entre grupos, o ggplot2 não interpreta meus dados! Ele simplesmente conecta as observações mais ou menos na ordem em que elas aparecem no eixo x. Para resolver esse problema, precisamos especificar grupos! Seja indiretamente, através de uma escala de cores, formas ou tipos de linha, seja diretamente através da estética groups.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, group = variavel)) +\rgeom_line()\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, linetype = variavel)) +\rgeom_line()\r Legal né?\nBarcharts Para terminar e ilustrar alguns exemplos de transformação estatística, vamos fazer alguns gráficos de barras usando o diamonds, um banco de dados para fazer a alegria das piores pessoas na história da humanidade.\ndiamonds\r ## # A tibble: 53,940 x 10\r## carat cut color clarity depth table price x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43\r## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31\r## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31\r## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63\r## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75\r## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48\r## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47\r## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53\r## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49\r## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39\r## # ... with 53,930 more rows\r Que tal um gráfico básico, do número de diamantes de acordo com a qualidade de seu corte (cut). Olhando a ajuda do ?geom_bar você vai na certeza de que você entendeu a aula e escreve o seguinte código:\nggplot(diamonds, aes(x = cut, color = cut)) +\rgeom_bar()\r E agora, você fica olhando pro seu computador com cara de tacho. O que aconteceu? Bom, no caso de geoms com duas dimensões, podem existir casos em que você quer dar mapeamentos estéticos distintos para as bordas e para o conteúdo deles. Por isso, existem as estéticas color e fill. Você pode pensar nelas como a casca do pão e o recheio.\nggplot(diamonds, aes(x = cut, fill = cut)) +\rgeom_bar()\r Mas, você ainda não está satisfeito. Pela sua ampla experiência com uma das indústrias mais sangrentas e retrógadas do planeta você entende que a qualidade do corte não é o suficiente para determinar o valor de um diamante, então você quer ver a distribuição também pelo nível de transparência do diamante, codificado na variável clarity.\nggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar()\r Esse é um primeiro passo interessante, e se tivessemos apenas duas ou três categorias, a gente poderia parar por aí. Mas no geral, para facilitar comparações, queremos poder controlar o posicionamento das barras. Isso é possível ajustando o argumento position dos geoms onde isso é necessário.\n# O padrão\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;stack\u0026quot;)\r # O certo\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;dodge\u0026quot;)\r # Empilhadas a 100%, para facilitar comparações entre categorias\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;fill\u0026quot;)\r Pode parecer jocoso, mas em 99% dos casos, o correto é você usar barras lado-a-lado, assim você visualmente pode comparar as categorias simplesmente comparando a altura das barras. Da próxima vez que você pensar em construir um gráfico de pizza, desista e faça um gráfico de barras com position = \u0026quot;dodge\u0026quot;. Seus leitores vão agradecer.\nEsse exemplo também é legal para gente olhar um pouco para a parte de transformações estatísticas nas variáveis:\ndiamonds2 \u0026lt;- diamonds %\u0026gt;% count(cut) %\u0026gt;% mutate(prop = n/sum(n))\rdiamonds2 %\u0026gt;% ggplot() +\rgeom_bar(aes(x = cut, y = prop), stat = \u0026quot;identity\u0026quot;)\r Por padrão, geom_bar já faz o primeiro passo e utiliza as contagens (stat_count) para produzir o gráfico de barras, mas eu posso mudar esse comportamento através do argumento stat. Eu também posso querer mostrar proprções ao invés de contagens de outra forma mais sucinta.\nggplot(diamonds, aes(x = cut, # ao fazer isso, eu mudo o padrão de contagens para proporções.\ry = stat(prop), # preciso especificar o grupo, se não todas as barras vão a 100%.\rgroup = 1)) +\rgeom_bar()\r Você pode construir seus gráficos a partir de transformações estatísticas ao invés de objetos geométricos:\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\rfun = median\r)\r As transformações estatísticas começam sempre com stat_ e cada uma tem um objeto geométrico padrão, que você pode mudar com o argumento geom.\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\r# Não dá pra mostrar a mediana com barras de erro, sorry\r#fun = median,\rgeom = \u0026quot;errorbar\u0026quot;\r)\r E era basicamente isso que eu tinha a dizer sobre como construir gráficos no ggplot2! Abaixo, uma seção com alguns detalhes para quem tiver interesse nessa parte de embelezamento dos gráficos.\nPerfumaria Essa seção pretende introduzir um pouco uma parte de customização dos gráficos. Frequentemente, as publicações de regras mais estritas sobre formatos, fontes, temas, etc. As opções padrão do ggplot2 podem não se acomodar, então, cabe a nós ajeitar essa reta final.\nTítulos e rótulos A melhor maneira de ajustar títulos e rótulos é através de labs, porque você resolve tudo em uma só invocação. Mas também há uma função ggtitle. Com ela, é possível setar apenas título e subtítulo.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;)\r A maioria das opções de customização mais fina está na camada theme. Internamente, cada elemento do gráfico é controlado por uma função element_, por exemplo, element_text desenha textos e recebe argumentos relativos a isso, como família da fonte, tamanho, cor, etc.\nAli, você tem um controle mais direto sobre a construção do gráfico. No que diz respeito aos rótulos, podemos mudar a fonte do título.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;))\r Usando uma síntaxe similar e os argumentos da função element_text, você pode mudar qual outro elemento textual do gráfico.\nEixos Continuando o nosso frankenstein, podemos fazer alterações nos eixos, como remover pedaços de um eixo, modificar sua forma, seu ângulo e ajustar sua posição.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;),\r# você pode remover pedaços inteiros do gráfico com \u0026quot;element_blank()\u0026quot;\raxis.ticks.y = element_blank(),\raxis.text.y = element_blank(),\raxis.title.y = element_blank(),\r# você pode mudar a orientação, angulo, posição e até formato de elementos\raxis.title = element_text(angle = 90, hjust = 1),\raxis.text.x = element_text(angle = 45, vjust = 1),\raxis.ticks.x = element_line(\rcolour = \u0026quot;royalblue3\u0026quot;,\rarrow = grid::arrow(angle = 45, length = unit(0.5, \u0026quot;cm\u0026quot;), ends = \u0026quot;first\u0026quot;, type = \u0026quot;closed\u0026quot;))\r)\r Realmente, o céu é o limite e você pode deixar o seu gráfico tão horrível quanto você quiser.\nLegendas Legendas no ggplot2 são controladas em alguns lugares diferentes. Elas são tratadas como guias (guides) no sentido de que são guias para o leitor. Vamos pegar outra variável de cores, para poder brincar com diferentes tipos de legenda.\nggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point()\r Por padrão, ele entende cilindros como numérico e faz uma barra de cores contínua. Mas eu quero uma legenda!\n# Jeito 1 - Simples e rápido\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = \u0026quot;legend\u0026quot;)\r # Jeito 2 - Posso mudar detalhes!\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;))\r # Jeito 3 - Mexendo diretamente nas escalas\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(guide = \u0026quot;legend\u0026quot;, option = \u0026quot;B\u0026quot;)\r # Jeito 3 - de novo, mas agora usando a especificação mais completa do guia\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(\rguide = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;), option = \u0026quot;B\u0026quot;)\r Em qualquer lugar onde você possa especificar guides, você pode passar o valor FALSE para remover a legenda.\n# Na camada \u0026quot;guides()\u0026quot;\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rguides(color = FALSE)\r # Na própria escala\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rscale_size(guide = FALSE)\r # Bônus = no tema, mas aí você remove todas\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rtheme(legend.position = \u0026quot;none\u0026quot;)\r Escalas Já dei uma palhinha de editar escalas, antes, então aqui vai um pouco mais de detalhe:\nggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point()\r # Mudar as cores manualmente\rcores \u0026lt;- c(\u0026quot;red\u0026quot;, \u0026quot;green\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;yellow\u0026quot;, \u0026quot;purple\u0026quot;, \u0026quot;tomato\u0026quot;, \u0026quot;wheat2\u0026quot;)\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores)\r # Mudar os tamanhos\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_radius para fazer proprcional ao raio\rscale_radius(range = c(3,6))\r ggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_size para fazer proprcional a área\rscale_size(range = c(2,4))\r É possível aplicar transformações na variável diretamente na escala, mudar o número de breaks e especificar labels e alterar os limites do gráfico manualmente.\nggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;, name = \u0026quot;Peso\u0026quot;) +\rscale_y_continuous(\rname = \u0026quot;Consumo (rodovia)\u0026quot;,\rlimits = c(0, 50),\rbreaks = c(10, 20, 30, 40, 50), labels = c(\u0026quot;fogo no clima\u0026quot;, \u0026quot;aquecimento global\u0026quot;, \u0026quot;caldeira planetária\u0026quot;, \u0026quot;deixa pra próxima geração\u0026quot;, \u0026quot;desastre em câmera lenta\u0026quot;))\r Cada escala vai ter argumentos específicos que fazem sentido em seu próprio contexto. Escalas contínuas tem argumentos para transformação estatística, escalas discretas não aceitam argumentos contínuos e etc.\nIsto encerra nossa parte de ggplot2, que tal uns exercícios pra esquentar?\nExercícios  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?\n  Utilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.\n  Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.\n  No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?\n  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  ggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r  Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.\n  Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.\n  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Tente recriar o seguinte gráfico  ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"b9e37b7e1055bb09bf3bd731ebee0b86","permalink":"https://laddem.github.io/courses/tidyverse/dia3/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia3/","section":"courses","summary":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.","tags":null,"title":"ggplot2","type":"book"},{"authors":null,"categories":null,"content":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer. Pra não ficar uma coisa solta no começo da aula, aqui uma foto de gatinho pra vocês:\nO assunto da aula de hoje é talvez um pouco mais abstrato do que as aulas anteriores. Vamos falar bastante de funções, loops e programação funcional. São termos que fazem parte do jargão da computação, mas que mesmo usuários veteranos do R como software estatístico para análise de dados podem ter pouca familiaridade. Ao invés de começar definindo o que vamos fazer, vou começar definindo o que não vamos.\n  Não vamos revisar a fundo o assunto de iterações. Os livros fazem um bom serviço, é um assunto espinhoso e não basta compreender os conceitos, tem que botar a mão na massa pra ter um entendimento não apenas da teoria, mas também para conseguir resolver os muitos problemas que aparecem quando você está construindo iterações com maior nível de complexidade.\n  Não vamos cavar fundo em todos os aspectos da programação funcional ou de todas as funções do purrr. São muitas e temos poucas horas.\n  Agora o que SIM vamos fazer é revisar muito brevemente a sintaxe de um for loop, ver em que situações a gente o utilizaria e como você pode substituir seus vários for loops por funções no purrr, com exemplos de aplicação quando possível. Se der tempo, vamos entrar um pouco na ideia de utilizar programação funcional para resolver problemas mais genéricos em que precisamos generalizar alguma tarefa.\n# Primeiro, nossos pacotes!\rlibrary(tidyverse) # o purrr já é carregado automaticamente junto com os outros,\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r # Se quiser carregar apenas o purrr, descomente a linha abaixo\r# library(purrr)\r Iterações Do ponto de vista prático, uma iteração é uma repetição uma linha de código de tal forma que apenas uma pequena parte previsível do código muda entre uma repetição e outra. Por exemplo, digamos que você vai calcular uma soma de x.\nx \u0026lt;- runif(100, 0, 1000)\rx\r ## [1] 225.093967 466.946190 883.812438 87.936952 817.297665 959.868374\r## [7] 238.111861 832.283389 517.254072 102.303256 429.861933 994.676597\r## [13] 80.038906 91.034775 315.595919 669.703517 666.710230 425.227435\r## [19] 497.996177 169.809868 677.356086 627.092270 59.883331 766.776678\r## [25] 149.171108 905.846157 544.019980 536.797568 155.848320 622.688184\r## [31] 967.633909 585.653757 699.380320 189.194041 768.424587 571.151547\r## [37] 794.404194 773.359030 59.930340 432.662018 560.213616 676.552325\r## [43] 865.665243 534.298338 184.087156 378.304177 979.344523 455.709585\r## [49] 385.905114 158.846492 508.830850 522.506361 611.013883 926.345360\r## [55] 476.592277 468.897322 559.445858 927.857062 424.459786 848.563421\r## [61] 690.474162 836.675233 226.751909 965.321906 42.961176 578.897402\r## [67] 278.689574 97.974729 847.269263 351.362806 617.868732 228.979437\r## [73] 217.598302 279.653980 602.528267 902.524905 109.103549 874.569871\r## [79] 3.867538 246.845225 971.238817 460.380726 858.708653 273.029658\r## [85] 79.749562 889.292917 775.435723 623.977954 376.979606 17.145635\r## [91] 648.954440 591.458843 806.026611 252.165876 22.365448 657.280677\r## [97] 999.726557 189.202339 267.494455 940.787127\r Esqueça, por um instante, a função sum. O cálculo da soma se dá pela soma de todos os elementos do vetor x. Então, é necessário repetir a operação de soma através da acumulação dos valores. Veja que é tudo totalmente previsível, cada nova repetição simplesmente adiciona mais um valor ao vetor original e esse valor pode ser encontrado na próxima posição de x. Esse é o típico caso de iteração. No R, a melhor prática é inicializar uma variável antes e salvar os resultados da iteração nela.\n# Inicialização\rresult \u0026lt;- x[[1]]\r# Sequência\rfor (i in 2:length(x)) {\r# Corpo\rresult \u0026lt;- result + x[[i]]\r}\r# Comparando os dois resultados\rresult\r ## [1] 51513.6\r sum(x)\r ## [1] 51513.6\r Outro exemplo de mesmo tipo é repetição de uma mesma operação em vários vetores/colunas/variáveis comuns. Por exemplo, se eu tenho um data.frame com três colunas numéricas e eu gostaria de calcular a soma de cada uma.\n# Data.frame\rdf \u0026lt;- tibble(x = rnorm(100, 50, 25),\ry = rnorm(100, 100, 25),\rz = rnorm(100, 200, 25))\r# Inicialização\rresult \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = length(df))\r# Sequência\rfor (i in seq_along(df)) {\rresult[[i]] \u0026lt;- sum(df[[i]])\r}\r# Resultado\rresult\r ## [1] 5143.487 9739.920 19452.666\r Essa é a minha revisão de 5 minutos de iteração em R usando for loops. Como já é de costume, tem muito mais. Por exemplo, existe um outro tipo de iterador no R básico chamado while, que tem um funcionamento diferente do for. Ao invés de você ter um resultado de tamanho previsível, você pode ter um resultado de tamanho desconhecido. Vou deixar o while para vocês pesquisarem porque o bom e velho for costuma cobrir a maioria dos casos de uso do cientista de dados.\nProgramação funcional Beleza, agora que já dominamos (ou não) o for loop, encontramos várias situações em que a gente gostaria de realizar a mesma operação várias vezes, mas, o for loop é como uma feijoada: é gostoso, mas é pesado. For loops em geral são \u0026ldquo;verbosos\u0026rdquo;, você precisa escrever bastante para chegar em um determinado resultado e, depois de escrever alguns, você cansa de ter que repetir todos os pedaços dele. E se você pudesse abstrair o loop para uma função? Aí você não precisaria escrever toda aquela parafernalha.\nsoma \u0026lt;- function(x) {\rresult \u0026lt;- 0\rfor (i in 1:length(x)) {\rresult \u0026lt;- result + x[[i]]\r}\rresult\r}\rsoma(x)\r ## [1] 51513.6\r Ao fazer isso, eu ganho duas vantagens:\n  Manutenção: sempre que eu precisar repetir a operação, eu consigo simplificar muito meu código. Não preciso escrever um for loop para cada soma que eu precisar fazer. Se meus requerimentos mudarem no futuro, eu só preciso mudar um pedaço de código.\n  Leitura: o humano que lê um for loop vai precisar de um minuto para se familiarizar com a operação e entender o que está sendo iterado, calculado, etc. O humano que lê \u0026ldquo;soma\u0026rdquo; sabe que ocorrerá uma soma. Você alinha a expectativa com a execução.\n  Outro exemplo.\nsoma_xyz \u0026lt;- function(x) {\rsoma_xyz \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = nrow(x))\rfor (i in seq_along(x[[1]])) {\rsoma_xyz[[i]] \u0026lt;- x[[1]][[i]] + x[[2]][[i]] + x[[3]][i]\r}\rsoma_xyz\r}\rdf$soma_xyz2 \u0026lt;- soma_xyz(df)\rdf\r ## # A tibble: 100 x 4\r## x y z soma_xyz2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 31.0 91.0 182. 304.\r## 2 51.9 91.1 188. 331.\r## 3 51.3 85.1 229. 365.\r## 4 80.0 139. 179. 398.\r## 5 80.5 50.1 228. 359.\r## 6 59.8 122. 231. 413.\r## 7 69.4 135. 242. 446.\r## 8 16.5 76.6 234. 327.\r## 9 69.2 107. 189. 365.\r## 10 51.6 75.2 234. 361.\r## # ... with 90 more rows\r Outra vantagem de ter na mão uma função, é que eu posso me apropriar das ferramentas de programação funcional do R. São as funções da família apply, que recebem uma lista de objetos e aplicam uma função em cada um. Basicamente, aquela abstração do for loop que estavamos buscando.\nVejam como eu posso recriar o exemplo das somas das colunas do data.frame usando a função soma.\nsapply(df, soma)\r ## x y z soma_xyz2 ## 5143.487 9739.920 19452.666 34336.074\r Eu sei, o exemplo é muito simples pra ter uma aplicação real. Até porque já vimos como fazer esse tipo de operação com summarize lá atrás. Mas talvez, na hora que você estiver realizando alguma operação de repetição, você se lembre dessa possibilidade e ela lhe seja útil.\no pacote purrr Até o momento, nos limitamos a utilizar funções presentes no base, mas o verdadeiro intuito dessa aula é introduzir as facilidade trazidas pelas funções do tidyverse. No pacote purrr, são importadas funções com diversas funcionalidades que facilitam o trabalho com objetos mais complexos, como listas (pense saída de modelo), iterações envolvendo mais de um argumento (pense escrever diversos objetos em diversos arquivos distintos) e assim sucessivamente. Abaixo, segue uma lista das funções do pacote com uma descrição curta.\n  a família map_(): similar a família apply do R base. Recebe uma lista de objetos de entrada e uma função e devolve uma lista com os resultados.\n  map2_(): mesma coisa, só que você pode passar duas listas de objetos e uma função que requer dois argumentos variáveis. pmap() é a generalização, em que você passa p listas e uma função que pede p argumentos.\n  imap(): aplica uma função tanto ao vetor, como a seu nome/índice. É meio louco, mas é muito útil para alguns casos de uso.\n  modify_(): permite aplicar alterações no objeto estilo o que você faria com uma pipeline de filter %\u0026gt;% mutate\n  safely(): e suas irmãs possibly() e quietly() ajudam a obter resultados mesmo quando há ocorre um erro na iteração.\n  transpose(), flatten_: manipulam e reformatam listas.\n  invoke_map(): aplica uma lista de funções a uma (opcional) segunda lista de parâmetros.\n  reduce() e accumulate(): generalizam as operações de sumarização (pense soma acumulada, média, limite, fatorial)\n  pluck(): pesca elementos de uma lista com uma sintaxe linear e bonitinha.\n  E muito mais coisas\n  No interesse de ir direto ao ponto e não tentar ser exaustivo, vamos ver algumas delas em mais detalhe.\nA função map Essa função é praticamente uma cópia de lapply.\ndf %\u0026gt;% lapply(sum)\r ## $x\r## [1] 5143.487\r## ## $y\r## [1] 9739.92\r## ## $z\r## [1] 19452.67\r## ## $soma_xyz2\r## [1] 34336.07\r df %\u0026gt;% map(sum)\r ## $x\r## [1] 5143.487\r## ## $y\r## [1] 9739.92\r## ## $z\r## [1] 19452.67\r## ## $soma_xyz2\r## [1] 34336.07\r Embora existam pequenas diferenças técnicas entre elas, a principal vantagem de map é a possibilidade de criar funções anônimas com uma síntaxe enxuta. Pense, por exemplo, em elevar ao quadrado.\ndf %\u0026gt;% lapply(function(x) x ^ 2)\r ## $x\r## [1] 963.798425 2689.631568 2636.289299 6407.686421 6483.401508\r## [6] 3576.407300 4821.200204 271.838261 4794.752257 2663.713324\r## [11] 1269.154807 2810.472272 7733.236266 6633.116709 5544.943339\r## [16] 1276.384278 474.645743 530.431720 3967.496532 3503.986006\r## [21] 4195.830138 6536.191280 2123.966230 1896.230863 320.311269\r## [26] 2713.855093 5381.268996 2205.452174 1047.781254 826.682084\r## [31] 2402.199045 5385.394322 2185.874731 5499.186633 8254.465662\r## [36] 3073.557849 5293.252928 2556.876189 3757.490933 1106.909116\r## [41] 1172.640022 7124.351428 875.948131 1428.390668 1426.113597\r## [46] 644.544767 3285.989441 853.645977 1.357369 2407.567674\r## [51] 5042.688807 5971.962098 4296.292935 124.644964 128.512784\r## [56] 7094.788796 6758.841939 3363.246840 881.306860 5323.336414\r## [61] 3396.128177 6276.881787 1185.356939 2587.379920 838.544288\r## [66] 882.065801 3046.336401 2404.123388 1843.174212 5069.910793\r## [71] 1426.091409 911.092383 12730.733608 6053.560724 3040.006719\r## [76] 658.250295 3402.752115 1192.989288 702.982204 959.240469\r## [81] 2427.061850 2819.283784 10924.963453 2645.464063 561.923775\r## [86] 12385.985694 3377.797601 1343.722757 383.297474 176.408849\r## [91] 4730.214023 955.567165 199.646662 6515.078501 1036.390327\r## [96] 1897.596732 2503.095741 236.412280 5393.150328 7001.526245\r## ## $y\r## [1] 8284.074 8303.088 7248.696 19391.930 2513.737 14851.220 18185.189\r## [8] 5865.938 11469.122 5650.669 10981.344 9473.321 9651.519 4452.080\r## [15] 6911.495 5374.510 11412.073 8851.945 10147.838 8415.336 6150.245\r## [22] 10513.858 11171.249 7657.689 3992.072 5309.097 9101.852 5460.790\r## [29] 10432.513 18788.381 4017.091 4116.322 3185.162 17520.537 3186.135\r## [36] 20143.963 10421.231 13894.456 7658.279 13681.015 15217.759 7052.142\r## [43] 12370.005 18450.451 5580.275 27559.470 9870.916 16777.651 14345.106\r## [50] 12084.487 11485.295 8327.790 26203.364 5477.594 8668.665 13172.393\r## [57] 12254.427 8711.024 9961.140 1268.758 7689.774 15604.880 9159.717\r## [64] 2758.645 10634.015 7599.150 14277.682 9006.049 11517.774 14155.260\r## [71] 10073.476 9203.164 4397.964 9118.102 6600.212 22169.380 7813.854\r## [78] 4461.388 10345.651 18106.926 7387.860 4662.773 20930.433 20457.998\r## [85] 9300.546 10149.361 7864.841 7646.981 7404.943 7709.098 7451.508\r## [92] 6907.973 6798.440 2214.701 12265.324 8910.786 8559.719 5810.114\r## [99] 4509.739 24625.748\r## ## $z\r## [1] 33154.90 35301.39 52433.74 32066.30 52077.27 53418.40 58521.86 54728.30\r## [9] 35690.17 54670.05 30497.10 29415.67 43156.04 32921.73 41698.45 55566.30\r## [17] 43630.23 49193.06 54089.95 38195.18 34639.45 30576.09 49807.56 40702.65\r## [25] 20512.02 30184.61 36949.72 58733.16 26796.23 47936.82 51652.77 33534.37\r## [33] 35970.26 23678.10 48648.95 33974.30 52570.99 30830.01 35836.79 36227.24\r## [41] 35372.95 34173.24 33564.92 31669.90 26779.00 31282.84 48986.23 43579.62\r## [49] 35944.99 29879.19 35826.63 26734.84 28090.00 20681.89 27921.49 40456.99\r## [57] 41507.86 24353.79 46273.41 42284.43 40001.73 41300.76 39745.56 27884.99\r## [65] 34581.60 34593.96 51853.12 50778.22 30045.59 37364.14 40176.84 20330.91\r## [73] 20957.48 43953.10 53487.80 33438.31 33781.46 47470.47 32914.79 33808.00\r## [81] 44550.95 32464.52 44696.09 36404.34 41732.33 17360.01 46148.44 55470.45\r## [89] 33890.15 31730.22 36964.04 47231.90 24258.20 36893.01 42387.00 48762.97\r## [97] 37281.18 43244.78 34961.56 34329.15\r## ## $soma_xyz2\r## [1] 92505.32 109474.68 133567.02 158701.52 128781.37 170397.94 199094.67\r## [8] 106940.59 133412.35 130031.19 99257.32 103590.54 155173.98 108643.62\r## [15] 130900.51 118861.27 113900.96 114860.63 157051.32 119969.06 108448.68\r## [22] 128338.79 140592.54 110757.80 50310.62 89218.94 130309.35 131920.52\r## [29] 88926.02 148046.10 115372.46 102827.80 85760.45 129887.12 135324.67\r## [36] 145687.48 163315.25 118353.26 114322.46 115988.37 119495.42 124780.60\r## [43] 104991.71 123613.33 76235.66 135621.24 142887.30 135058.53 96427.49\r## [50] 110126.02 135027.30 110252.64 156041.87 52435.15 73733.57 160112.69\r## [57] 157328.59 94484.55 118752.53 98729.56 119696.62 165952.07 108569.13\r## [64] 73103.77 101149.61 91728.55 161922.28 136362.02 104710.31 147054.80\r## [71] 114630.97 72201.81 104920.71 146645.60 135168.17 127743.12 109247.74\r## [78] 101895.35 95884.19 122082.54 119915.96 90938.77 212162.11 148428.93\r## [85] 105254.30 118194.15 130772.38 129330.50 83939.26 77959.99 120658.28\r## [92] 109796.45 63671.81 102305.42 121677.47 128724.35 112649.55 89732.36\r## [99] 107303.92 181375.75\r df %\u0026gt;% map(~ .x ^ 2)\r ## $x\r## [1] 963.798425 2689.631568 2636.289299 6407.686421 6483.401508\r## [6] 3576.407300 4821.200204 271.838261 4794.752257 2663.713324\r## [11] 1269.154807 2810.472272 7733.236266 6633.116709 5544.943339\r## [16] 1276.384278 474.645743 530.431720 3967.496532 3503.986006\r## [21] 4195.830138 6536.191280 2123.966230 1896.230863 320.311269\r## [26] 2713.855093 5381.268996 2205.452174 1047.781254 826.682084\r## [31] 2402.199045 5385.394322 2185.874731 5499.186633 8254.465662\r## [36] 3073.557849 5293.252928 2556.876189 3757.490933 1106.909116\r## [41] 1172.640022 7124.351428 875.948131 1428.390668 1426.113597\r## [46] 644.544767 3285.989441 853.645977 1.357369 2407.567674\r## [51] 5042.688807 5971.962098 4296.292935 124.644964 128.512784\r## [56] 7094.788796 6758.841939 3363.246840 881.306860 5323.336414\r## [61] 3396.128177 6276.881787 1185.356939 2587.379920 838.544288\r## [66] 882.065801 3046.336401 2404.123388 1843.174212 5069.910793\r## [71] 1426.091409 911.092383 12730.733608 6053.560724 3040.006719\r## [76] 658.250295 3402.752115 1192.989288 702.982204 959.240469\r## [81] 2427.061850 2819.283784 10924.963453 2645.464063 561.923775\r## [86] 12385.985694 3377.797601 1343.722757 383.297474 176.408849\r## [91] 4730.214023 955.567165 199.646662 6515.078501 1036.390327\r## [96] 1897.596732 2503.095741 236.412280 5393.150328 7001.526245\r## ## $y\r## [1] 8284.074 8303.088 7248.696 19391.930 2513.737 14851.220 18185.189\r## [8] 5865.938 11469.122 5650.669 10981.344 9473.321 9651.519 4452.080\r## [15] 6911.495 5374.510 11412.073 8851.945 10147.838 8415.336 6150.245\r## [22] 10513.858 11171.249 7657.689 3992.072 5309.097 9101.852 5460.790\r## [29] 10432.513 18788.381 4017.091 4116.322 3185.162 17520.537 3186.135\r## [36] 20143.963 10421.231 13894.456 7658.279 13681.015 15217.759 7052.142\r## [43] 12370.005 18450.451 5580.275 27559.470 9870.916 16777.651 14345.106\r## [50] 12084.487 11485.295 8327.790 26203.364 5477.594 8668.665 13172.393\r## [57] 12254.427 8711.024 9961.140 1268.758 7689.774 15604.880 9159.717\r## [64] 2758.645 10634.015 7599.150 14277.682 9006.049 11517.774 14155.260\r## [71] 10073.476 9203.164 4397.964 9118.102 6600.212 22169.380 7813.854\r## [78] 4461.388 10345.651 18106.926 7387.860 4662.773 20930.433 20457.998\r## [85] 9300.546 10149.361 7864.841 7646.981 7404.943 7709.098 7451.508\r## [92] 6907.973 6798.440 2214.701 12265.324 8910.786 8559.719 5810.114\r## [99] 4509.739 24625.748\r## ## $z\r## [1] 33154.90 35301.39 52433.74 32066.30 52077.27 53418.40 58521.86 54728.30\r## [9] 35690.17 54670.05 30497.10 29415.67 43156.04 32921.73 41698.45 55566.30\r## [17] 43630.23 49193.06 54089.95 38195.18 34639.45 30576.09 49807.56 40702.65\r## [25] 20512.02 30184.61 36949.72 58733.16 26796.23 47936.82 51652.77 33534.37\r## [33] 35970.26 23678.10 48648.95 33974.30 52570.99 30830.01 35836.79 36227.24\r## [41] 35372.95 34173.24 33564.92 31669.90 26779.00 31282.84 48986.23 43579.62\r## [49] 35944.99 29879.19 35826.63 26734.84 28090.00 20681.89 27921.49 40456.99\r## [57] 41507.86 24353.79 46273.41 42284.43 40001.73 41300.76 39745.56 27884.99\r## [65] 34581.60 34593.96 51853.12 50778.22 30045.59 37364.14 40176.84 20330.91\r## [73] 20957.48 43953.10 53487.80 33438.31 33781.46 47470.47 32914.79 33808.00\r## [81] 44550.95 32464.52 44696.09 36404.34 41732.33 17360.01 46148.44 55470.45\r## [89] 33890.15 31730.22 36964.04 47231.90 24258.20 36893.01 42387.00 48762.97\r## [97] 37281.18 43244.78 34961.56 34329.15\r## ## $soma_xyz2\r## [1] 92505.32 109474.68 133567.02 158701.52 128781.37 170397.94 199094.67\r## [8] 106940.59 133412.35 130031.19 99257.32 103590.54 155173.98 108643.62\r## [15] 130900.51 118861.27 113900.96 114860.63 157051.32 119969.06 108448.68\r## [22] 128338.79 140592.54 110757.80 50310.62 89218.94 130309.35 131920.52\r## [29] 88926.02 148046.10 115372.46 102827.80 85760.45 129887.12 135324.67\r## [36] 145687.48 163315.25 118353.26 114322.46 115988.37 119495.42 124780.60\r## [43] 104991.71 123613.33 76235.66 135621.24 142887.30 135058.53 96427.49\r## [50] 110126.02 135027.30 110252.64 156041.87 52435.15 73733.57 160112.69\r## [57] 157328.59 94484.55 118752.53 98729.56 119696.62 165952.07 108569.13\r## [64] 73103.77 101149.61 91728.55 161922.28 136362.02 104710.31 147054.80\r## [71] 114630.97 72201.81 104920.71 146645.60 135168.17 127743.12 109247.74\r## [78] 101895.35 95884.19 122082.54 119915.96 90938.77 212162.11 148428.93\r## [85] 105254.30 118194.15 130772.38 129330.50 83939.26 77959.99 120658.28\r## [92] 109796.45 63671.81 102305.42 121677.47 128724.35 112649.55 89732.36\r## [99] 107303.92 181375.75\r Através do uso de fórmulas ~ é possível especificar funções anônimas simples economizando caracteres e utilizando o autocompletar.\nQue tal esta pipeline?\nlibrary(nycflights13)\r# Médias de todas as variáveis numéricas usando where()\rflights %\u0026gt;% select(where(is.numeric)) %\u0026gt;% map(mean)\r ## $year\r## [1] 2013\r## ## $month\r## [1] 6.54851\r## ## $day\r## [1] 15.71079\r## ## $dep_time\r## [1] NA\r## ## $sched_dep_time\r## [1] 1344.255\r## ## $dep_delay\r## [1] NA\r## ## $arr_time\r## [1] NA\r## ## $sched_arr_time\r## [1] 1536.38\r## ## $arr_delay\r## [1] NA\r## ## $flight\r## [1] 1971.924\r## ## $air_time\r## [1] NA\r## ## $distance\r## [1] 1039.913\r## ## $hour\r## [1] 13.18025\r## ## $minute\r## [1] 26.2301\r Ou esta\n# Proporção de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(mean)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 0.02451184\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 0.02451184\r## ## $arr_time\r## [1] 0.0258718\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 0.02800081\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 0.007458964\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 0.02800081\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r # Contagem de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(sum)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 8255\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 8255\r## ## $arr_time\r## [1] 8713\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 9430\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 2512\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 9430\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r A outra grande vantagem do map é ter acesso fácil ao controle do tipo de saída.\n# Vetor numérico\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_dbl(mean)\r ## year month day dep_time sched_dep_time ## 0.000000000 0.000000000 0.000000000 0.024511842 0.000000000 ## dep_delay arr_time sched_arr_time arr_delay carrier ## 0.024511842 0.025871796 0.000000000 0.028000808 0.000000000 ## flight tailnum origin dest air_time ## 0.000000000 0.007458964 0.000000000 0.000000000 0.028000808 ## distance hour minute time_hour ## 0.000000000 0.000000000 0.000000000 0.000000000\r # Vetor de caracteres\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_chr(mean)\r ## year month day dep_time sched_dep_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.024512\u0026quot; \u0026quot;0.000000\u0026quot; ## dep_delay arr_time sched_arr_time arr_delay carrier ## \u0026quot;0.024512\u0026quot; \u0026quot;0.025872\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; \u0026quot;0.000000\u0026quot; ## flight tailnum origin dest air_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.007459\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; ## distance hour minute time_hour ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot;\r Um exemplo um pouco mais elaborado: avaliação inicial de variáveis em um modelo. Em geral, é comum rodar um modelo para cada variável numérica para ver como elas se comportam.\nrespvar \u0026lt;- \u0026quot;hwy\u0026quot;\rpredvars \u0026lt;- names(select(mpg, where(is.numeric), -hwy))\rtibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rsummary = map(fit, summary),\rr2 = map_dbl(summary, \u0026quot;r.squared\u0026quot;),\rFStat = map_df(summary, \u0026quot;fstatistic\u0026quot;),\rcoefs = map_df(fit, coef),\r)\r ## # A tibble: 4 x 6\r## names fit summary r2 FStat$value $numdf $dendf coefs$`(Interce~ $displ\r## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.87e-1 329. 1 232 35.7 -3.53\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;smmry~ 4.66e-6 0.00108 1 232 17.7 NA ## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.81e-1 321. 1 232 40.0 NA ## 4 cty \u0026lt;lm\u0026gt; \u0026lt;smmry~ 9.14e-1 2459. 1 232 0.892 NA\r Ok, a saída não está muito bonitinha! Mas com um pouco mais de trabalho, programadores melhores que eu fizeram isso:\nmodels \u0026lt;- tibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rtidied = fit %\u0026gt;% map(broom::tidy),\rglanced = fit %\u0026gt;% map(broom::glance),\raugmented = fit %\u0026gt;% map(broom::augment)\r)\rmodels\r ## # A tibble: 4 x 5\r## names fit tidied glanced augmented ## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; ## 1 displ \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 4 cty \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r Grande coisa, Vinícius, o output é ilegível! Calma! Lembram da primeira aula em que eu comentei que havia mais funções no tidyr?\n# Coeficientes\rmodels %\u0026gt;% select(tidied) %\u0026gt;%\rtidyr::unnest(tidied) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)\r ## # A tibble: 4 x 5\r## term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ -3.53 0.195 -18.2 2.04e- 46\r## 2 year 0.00285 0.0867 0.0329 9.74e- 1\r## 3 cyl -2.82 0.157 -17.9 1.18e- 45\r## 4 cty 1.34 0.0270 49.6 1.87e-125\r # Estatísticas do modelo\rmodels %\u0026gt;% select(names, glanced) %\u0026gt;% unnest(glanced)\r ## # A tibble: 4 x 13\r## names r.squared adj.r.squared sigma statistic p.value df logLik AIC\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 0.587 0.585 3.84 329. 2.04e- 46 1 -646. 1297.\r## 2 year 0.00000466 -0.00431 5.97 0.00108 9.74e- 1 1 -749. 1504.\r## 3 cyl 0.581 0.579 3.87 321. 1.18e- 45 1 -647. 1301.\r## 4 cty 0.914 0.913 1.75 2459. 1.87e-125 1 -462. 931.\r## # ... with 4 more variables: BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;, df.residual \u0026lt;int\u0026gt;,\r## # nobs \u0026lt;int\u0026gt;\r # Bancos \u0026quot;aumentados\u0026quot; com valores ajustados, resíduos, distâncias de cook, etc.\rmodels %\u0026gt;% filter(names == \u0026quot;displ\u0026quot;) %\u0026gt;% select(names, augmented) %\u0026gt;% unnest(augmented)\r ## # A tibble: 234 x 9\r## names hwy displ .fitted .resid .hat .sigma .cooksd .std.resid\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 2 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 3 displ 31 2 28.6 2.36 0.00984 3.84 0.00191 0.619 ## 4 displ 30 2 28.6 1.36 0.00984 3.84 0.000634 0.357 ## 5 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 6 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 7 displ 27 3.1 24.8 2.25 0.00463 3.84 0.000802 0.587 ## 8 displ 26 1.8 29.3 -3.34 0.0115 3.84 0.00445 -0.876 ## 9 displ 25 1.8 29.3 -4.34 0.0115 3.83 0.00751 -1.14 ## 10 displ 28 2 28.6 -0.636 0.00984 3.84 0.000138 -0.167 ## # ... with 224 more rows\r Isso aqui é só uma palhinha de modelagem com o tidyverse, mas acho que é uma demonstração muito convincente da aplicabilidade dos exemplos que vimos usando programação funcional.\nOutro exemplo mais simples com map2: salvar vários arquivos de uma vez só.\ndf1 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf2 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf3 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf4 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdfs \u0026lt;- list(df1, df2, df3, df4)\rdfs\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.142 -0.924 0.762 ## 2 0.405 -1.33 -0.196 ## 3 -0.0639 -0.399 -0.260 ## 4 -0.0699 0.0876 1.57 ## 5 0.827 -0.335 1.01 ## 6 0.187 0.419 -0.442 ## 7 1.14 -0.224 -0.0744\r## 8 -0.514 -1.27 0.896 ## 9 0.645 0.510 1.10 ## 10 -0.810 -0.246 0.589 ## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.54 0.923 -1.32 ## 2 -0.0135 -0.975 -0.0527\r## 3 1.36 -0.369 -0.434 ## 4 2.25 -0.254 0.207 ## 5 1.41 -1.43 -1.19 ## 6 0.357 0.408 -0.183 ## 7 1.32 0.773 0.427 ## 8 0.622 0.379 -1.06 ## 9 1.09 -1.27 -0.699 ## 10 1.66 1.75 -1.14 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.306 1.11 1.28 ## 2 2.70 1.65 0.579\r## 3 0.904 0.558 2.16 ## 4 -0.335 1.92 -0.144\r## 5 0.443 0.521 1.07 ## 6 0.744 0.241 -1.57 ## 7 -1.48 -0.941 0.268\r## 8 -0.00240 0.304 1.13 ## 9 0.368 -0.987 0.577\r## 10 -2.07 0.0147 1.22 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.753 0.894 -1.85 ## 2 0.960 1.53 1.12 ## 3 2.23 2.12 -0.230\r## 4 -1.15 -0.968 0.190\r## 5 1.34 1.73 0.459\r## 6 -1.44 -1.94 0.200\r## 7 0.170 -2.97 0.692\r## 8 -0.627 0.702 -0.512\r## 9 -1.50 -0.0865 -0.407\r## 10 0.633 1.15 -0.273\r## # ... with 90 more rows\r paths \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:4)\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r map2(dfs, paths, ~write_csv(x = .x, file = .y))\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.142 -0.924 0.762 ## 2 0.405 -1.33 -0.196 ## 3 -0.0639 -0.399 -0.260 ## 4 -0.0699 0.0876 1.57 ## 5 0.827 -0.335 1.01 ## 6 0.187 0.419 -0.442 ## 7 1.14 -0.224 -0.0744\r## 8 -0.514 -1.27 0.896 ## 9 0.645 0.510 1.10 ## 10 -0.810 -0.246 0.589 ## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.54 0.923 -1.32 ## 2 -0.0135 -0.975 -0.0527\r## 3 1.36 -0.369 -0.434 ## 4 2.25 -0.254 0.207 ## 5 1.41 -1.43 -1.19 ## 6 0.357 0.408 -0.183 ## 7 1.32 0.773 0.427 ## 8 0.622 0.379 -1.06 ## 9 1.09 -1.27 -0.699 ## 10 1.66 1.75 -1.14 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.306 1.11 1.28 ## 2 2.70 1.65 0.579\r## 3 0.904 0.558 2.16 ## 4 -0.335 1.92 -0.144\r## 5 0.443 0.521 1.07 ## 6 0.744 0.241 -1.57 ## 7 -1.48 -0.941 0.268\r## 8 -0.00240 0.304 1.13 ## 9 0.368 -0.987 0.577\r## 10 -2.07 0.0147 1.22 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.753 0.894 -1.85 ## 2 0.960 1.53 1.12 ## 3 2.23 2.12 -0.230\r## 4 -1.15 -0.968 0.190\r## 5 1.34 1.73 0.459\r## 6 -1.44 -1.94 0.200\r## 7 0.170 -2.97 0.692\r## 8 -0.627 0.702 -0.512\r## 9 -1.50 -0.0865 -0.407\r## 10 0.633 1.15 -0.273\r## # ... with 90 more rows\r E se eu quiser ler um banco de dados que está em vários arquivos diferentes? Vamos usar os que acabamos de criar\n# Bum! Uma linha\rpaths %\u0026gt;% map_dfr(read_csv, .id = \u0026quot;arquivo\u0026quot;)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r ## # A tibble: 400 x 4\r## arquivo x y z\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 -0.142 -0.924 0.762 ## 2 1 0.405 -1.33 -0.196 ## 3 1 -0.0639 -0.399 -0.260 ## 4 1 -0.0699 0.0876 1.57 ## 5 1 0.827 -0.335 1.01 ## 6 1 0.187 0.419 -0.442 ## 7 1 1.14 -0.224 -0.0744\r## 8 1 -0.514 -1.27 0.896 ## 9 1 0.645 0.510 1.10 ## 10 1 -0.810 -0.246 0.589 ## # ... with 390 more rows\r As possibilidades são inúmeras. A regra é a seguinte: viu uma tarefa que precisa ser repetida muitas vezes? Pense com carinho em usar uma função vetorizada através de map_.\nPredicados O objetivo de um função predicado é selecionar elementos de uma lista com base em uma função. Em geral, são funções simples que retornam um valor TRUE ou FALSE com base em alguma característica do objeto, como o tipo.\nl \u0026lt;- list(c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c(1, 2, 3))\rl %\u0026gt;% str()\r ## List of 2\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.numeric) %\u0026gt;% str()\r ## List of 1\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.character) %\u0026gt;% str()\r ## List of 1\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r O uso mais frequente que vejo de keep e discard é como uma espécie de atalho para select. Como data.frames são secretamente listas, você pode rapidamente selecionar todas as variáveis do banco que tenham o mesmo tipo.\nflights %\u0026gt;% keep(is.numeric)\r ## # A tibble: 336,776 x 14\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 6 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;\r flights %\u0026gt;% discard(is.character)\r ## # A tibble: 336,776 x 15\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 7 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;,\r## # time_hour \u0026lt;dttm\u0026gt;\r Como outros aspectos do purrr, a grande vantagem aqui é a generalidade. Essas funções funcionam em qualquer lista de objetos e não apenas em data.frames.\nLidando com a presença de erros A próxima dica forte é utilizar os advérbios (chique) safely() e companhia para lidar com erros.\nx \u0026lt;- list(a = c(1,2,3), b = c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c = c(99, 88, 77))\rx %\u0026gt;% map(sum)\r ## Error in .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm): 'type' inválido (character) do argumento\r Não conseguimos nada! A mensagem de erro nem nos informa onde o problema ocorreu. E agora?\nx %\u0026gt;% map(safely(sum)) %\u0026gt;% str()\r ## List of 3\r## $ a:List of 2\r## ..$ result: num 6\r## ..$ error : NULL\r## $ b:List of 2\r## ..$ result: NULL\r## ..$ error :List of 2\r## .. ..$ message: chr \u0026quot;'type' inválido (character) do argumento\u0026quot;\r## .. ..$ call : language .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm)\r## .. ..- attr(*, \u0026quot;class\u0026quot;)= chr [1:3] \u0026quot;simpleError\u0026quot; \u0026quot;error\u0026quot; \u0026quot;condition\u0026quot;\r## $ c:List of 2\r## ..$ result: num 264\r## ..$ error : NULL\r x %\u0026gt;% map(possibly(sum, otherwise = NA_real_)) %\u0026gt;% str()\r ## List of 3\r## $ a: num 6\r## $ b: num NA\r## $ c: num 264\r Essas funções permitem alterar a saída de uma função quando ocorrer um erro. quietly é parecido, mas ela captura mais a saída do R, o texto em si.\nx \u0026lt;- list(1, -1)\rx %\u0026gt;% map(quietly(log)) %\u0026gt;% str()\r ## List of 2\r## $ :List of 4\r## ..$ result : num 0\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr(0) ## ..$ messages: chr(0) ## $ :List of 4\r## ..$ result : num NaN\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr \u0026quot;NaNs produzidos\u0026quot;\r## ..$ messages: chr(0)\r Chamando listas de funções Vamos supor que você tem um vetor de números e você quer aplicar um monte de funções diferentes nele, mas você não quer ter que ficar copiando e colando tudo.\nnumeros \u0026lt;- rnorm(25, 50, 10)\rnumeros\r ## [1] 42.20048 38.07047 40.98823 66.99693 47.80056 45.23199 58.43128 45.39271\r## [9] 58.51740 57.56044 61.02015 34.67480 57.13596 49.33671 21.79235 48.01163\r## [17] 48.88481 55.32602 33.49729 49.72942 34.46436 56.32152 67.10447 53.74201\r## [25] 48.43169\r Nessas situações, você gostaria de chamar várias funções no mesmo objeto ou grupo de objetos, mas você não sabe bem como fazer isso\u0026hellip; Então, invoke_map vem ao resgate.\nfuncs \u0026lt;- list(\u0026quot;mean\u0026quot;, \u0026quot;sd\u0026quot;, \u0026quot;IQR\u0026quot;, \u0026quot;sum\u0026quot;, \u0026quot;length\u0026quot;, \u0026quot;range\u0026quot;, \u0026quot;min\u0026quot;, \u0026quot;max\u0026quot;)\rargs \u0026lt;- list(list(na.rm = T, trim = 0.05),\rlist(na.rm=T), list(type = 2),\rlist(na.rm = T), list(),\rlist(na.rm = T), list(na.rm = T), list(na.rm = T))\rfuncs %\u0026gt;% str()\r ## List of 8\r## $ : chr \u0026quot;mean\u0026quot;\r## $ : chr \u0026quot;sd\u0026quot;\r## $ : chr \u0026quot;IQR\u0026quot;\r## $ : chr \u0026quot;sum\u0026quot;\r## $ : chr \u0026quot;length\u0026quot;\r## $ : chr \u0026quot;range\u0026quot;\r## $ : chr \u0026quot;min\u0026quot;\r## $ : chr \u0026quot;max\u0026quot;\r args %\u0026gt;% str()\r ## List of 8\r## $ :List of 2\r## ..$ na.rm: logi TRUE\r## ..$ trim : num 0.05\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ type: num 2\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ : list()\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r invoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ : num 49.2\r## $ : num 11\r## $ : num 14.9\r## $ : num 1221\r## $ : int 25\r## $ : num [1:2] 21.8 67.1\r## $ : num 21.8\r## $ : num 67.1\r Fica mais bonito se você nomear os argumentos, ai o output fica melhorzinho.\nnames(funcs) \u0026lt;- unlist(funcs)\rinvoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ mean : num 49.2\r## $ sd : num 11\r## $ IQR : num 14.9\r## $ sum : num 1221\r## $ length: int 25\r## $ range : num [1:2] 21.8 67.1\r## $ min : num 21.8\r## $ max : num 67.1\r Claro que esse exemplo aqui talvez não seja útil para vocês, mas espero que quando vocês encontrarem uma situação em que você gostaria de aplicar uma bateria de funções no mesmo objeto ou grupo de objetos, vocês se lembrem dessa possibilidade.\nreduce e accumulate Essas duas funções são desenhadas para fazer aplicações recursivas de funções que recebem dois argumentos (operadores matemáticos, _joins, etc. Recursividade em linhas gerais, é você repetir uma operação com o resultado da repetição anterior. Pense em somas ou produtos acumulados, em que o próximo valor é determinado pela aplicação de uma regra sobre o anterior.\naccumulate(1:10, `+`)\r ## [1] 1 3 6 10 15 21 28 36 45 55\r accumulate(1:10, `*`)\r ## [1] 1 2 6 24 120 720 5040 40320 362880\r## [10] 3628800\r A principal diferença entre accumulate e reduce é que a primeira guarda os resultados intermediários, enquanto a segunda retorna apenas o último.\nreduce(1:10, `+`)\r ## [1] 55\r reduce(1:10, `*`)\r ## [1] 3628800\r Uma aplicação bastante prática dessas funções é a produção de um único banco de dados a partir de vários arquivos separados.\n# Lembra dos nossos arquivos lá em cima?\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r Vamos fingir que não temos acesso a map_dfr e precisamos importar esses objetos e todos compõem um único banco. Imaginaem que tratam-se de dados por ano.\ndfs \u0026lt;- map(paths, read_csv)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r glimpse(dfs)\r ## List of 4\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.1423 0.405 -0.0639 -0.0699 0.8265 ...\r## ..$ y: num [1:100] -0.9244 -1.3257 -0.3995 0.0876 -0.3349 ...\r## ..$ z: num [1:100] 0.762 -0.196 -0.26 1.568 1.009 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] 1.5431 -0.0135 1.3621 2.2513 1.4092 ...\r## ..$ y: num [1:100] 0.923 -0.975 -0.369 -0.254 -1.433 ...\r## ..$ z: num [1:100] -1.3211 -0.0527 -0.4336 0.2069 -1.1874 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.306 2.702 0.904 -0.335 0.443 ...\r## ..$ y: num [1:100] 1.109 1.646 0.558 1.918 0.521 ...\r## ..$ z: num [1:100] 1.276 0.579 2.159 -0.144 1.069 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.753 0.96 2.231 -1.145 1.338 ...\r## ..$ y: num [1:100] 0.894 1.526 2.123 -0.968 1.732 ...\r## ..$ z: num [1:100] -1.849 1.123 -0.23 0.19 0.459 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r new_df \u0026lt;- reduce(dfs, bind_rows)\rnew_df\r ## # A tibble: 400 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.142 -0.924 0.762 ## 2 0.405 -1.33 -0.196 ## 3 -0.0639 -0.399 -0.260 ## 4 -0.0699 0.0876 1.57 ## 5 0.827 -0.335 1.01 ## 6 0.187 0.419 -0.442 ## 7 1.14 -0.224 -0.0744\r## 8 -0.514 -1.27 0.896 ## 9 0.645 0.510 1.10 ## 10 -0.810 -0.246 0.589 ## # ... with 390 more rows\r O resultado é o mesmo observado em map_dfr, mas essa abordagem é genérica, ou seja, ela se aplica para qualquer grupo de objetos e para qualquer função que recebe dois argumentos e precisa ser repetida de maneira recursiva.\n# Apaga os arquivos pra eles não ficarem ai gastando memória a toa\rfile.remove(paths)\r ## [1] TRUE TRUE TRUE TRUE\r pluck Esta função é um atalho para as tesouras duplas do r [[. Seu objeto é facilitar a leitura de códigos que pescam elementos profundos de uma lista aninhada.\nl \u0026lt;- list(\rlist(-1, x = 1, y = c(2), z = \u0026quot;a\u0026quot;),\rlist(-2, x = 4, y = c(5, 6), z = \u0026quot;b\u0026quot;),\rlist(-3, x = 8, y = c(9, 10, 11))\r)\rglimpse(l)\r ## List of 3\r## $ :List of 4\r## ..$ : num -1\r## ..$ x: num 1\r## ..$ y: num 2\r## ..$ z: chr \u0026quot;a\u0026quot;\r## $ :List of 4\r## ..$ : num -2\r## ..$ x: num 4\r## ..$ y: num [1:2] 5 6\r## ..$ z: chr \u0026quot;b\u0026quot;\r## $ :List of 3\r## ..$ : num -3\r## ..$ x: num 8\r## ..$ y: num [1:3] 9 10 11\r Se você chamar map_ nessa lista, você pode extrair os elementos delas pelo nome.\nmap_dbl(l, \u0026quot;x\u0026quot;)\r ## [1] 1 4 8\r map(l, \u0026quot;y\u0026quot;)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r map(l, \u0026quot;z\u0026quot;)\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r Ou pela posição na lista\nmap_dbl(l, 1)\r ## [1] -1 -2 -3\r map_dbl(l, 2)\r ## [1] 1 4 8\r map(l, 3)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r Ou os dois\nmap_dbl(l, list(\u0026quot;x\u0026quot;, 1))\r ## [1] 1 4 8\r map(l, list(\u0026quot;z\u0026quot;, 1))\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r map(l, list(\u0026quot;y\u0026quot;, 3))\r ## [[1]]\r## NULL\r## ## [[2]]\r## NULL\r## ## [[3]]\r## [1] 11\r Se um componente não existir, você recebe um erro\nmap_chr(l, \u0026quot;z\u0026quot;)\r ## Error: Result 3 must be a single string, not NULL of length 0\r Mas você pode resolver isso passando um valor padrão\nmap_chr(l, \u0026quot;z\u0026quot;, .default = NA_character_)\r ## [1] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; NA\r Tudo isso funciona com base na função pluck\npluck(l, 1)\r ## [[1]]\r## [1] -1\r## ## $x\r## [1] 1\r## ## $y\r## [1] 2\r## ## $z\r## [1] \u0026quot;a\u0026quot;\r pluck(l, 1, 2)\r ## [1] 1\r pluck(l, 2, 3)\r ## [1] 5 6\r pluck(l, 1, \u0026quot;x\u0026quot;)\r ## [1] 1\r pluck(l, 2, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;b\u0026quot;\r pluck(l, 3, \u0026quot;y\u0026quot;)\r ## [1] 9 10 11\r Exercícios   Utilize uma das funções map_ para:\n  Calcular a média de cada coluna em mtcars.\n  Determinar o tipo de cada coluna em flights.\n  Computar o número de valores únicos em cada coluna de iris.\n  Gere 10 distribuições aleatórias (rnorm) com médias -10, 0, 10 e 100.\n  Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?\n  Usando as funções predicado keep e discard:\n  Selecione todas as colunas caractere no banco flights.\n  Descarte os caracteres em mpg.\n  Selecione os fatores ordenados em diamonds.\n  Descarte as variáveis não-numéricas em iris\n  Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.\n  Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.\n  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"8fc2c9a43ba39b58554f36d137f8df4b","permalink":"https://laddem.github.io/courses/tidyverse/dia4/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia4/","section":"courses","summary":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.","tags":null,"title":"purrr","type":"book"},{"authors":null,"categories":null,"content":"Soluções dos exercícios.\nreadr, tibble, tidyr # Não esqueça dos pacotes!\rlibrary(tidyverse)\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Primeiro, é bom verificar como estão dispostas as informações no arquivo texto\nread_lines(file, n_max = 10)\r ## [1] \u0026quot;ALFA ROMEO ALFA ROMEO 78010003\u0026quot;\r## [2] \u0026quot;ALFETTA 03 81 8 74 7 89 9 ALFETTA 78010053\u0026quot;\r## [3] \u0026quot;SPIDER 2000 01 SPIDER 2000 78010103\u0026quot;\r## [4] \u0026quot;AMC AMC 78020002\u0026quot;\r## [5] \u0026quot;GREMLIN 03 79 9 79 9 GREMLIN 78020053\u0026quot;\r## [6] \u0026quot;PACER 04 89 11 89 11 PACER 78020103\u0026quot;\r## [7] \u0026quot;PACER WAGON 07 90 26 91 26 PACER WAGON 78020153\u0026quot;\r## [8] \u0026quot;CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 78020203\u0026quot;\r## [9] \u0026quot;CONCORD WAGON 07 91 30 91 30 CONCORD WAGON 78020253\u0026quot;\r## [10] \u0026quot;MATADOR COUPE 05 97 14 97 14 MATADOR COUPE 78020303\u0026quot;\r Ao identificar que se trata de um arquivo colunado, mas que as colunas são separadas por espaços, escolho o read_fwf com o fwf_empty.\ndic \u0026lt;- fwf_empty(file)\rdf \u0026lt;- read_fwf(file, col_positions = dic)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_double(),\r## X4 = col_double(),\r## X5 = col_double(),\r## X6 = col_double(),\r## X7 = col_double(),\r## X8 = col_double(),\r## X9 = col_double(),\r## X10 = col_double(),\r## X11 = col_character(),\r## X12 = col_double()\r## )\r df\r ## # A tibble: 20 x 12\r## X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 ALFA RO~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ALFA R~ 7.80e7\r## 2 ALFETTA 03 81 8 74 7 89 9 NA NA ALFETTA 7.80e7\r## 3 SPIDER ~ 01 NA NA NA NA NA NA NA NA SPIDER~ 7.80e7\r## 4 AMC \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AMC 7.80e7\r## 5 GREMLIN 03 79 9 NA NA NA NA 79 9 GREMLIN 7.80e7\r## 6 PACER 04 89 11 NA NA NA NA 89 11 PACER 7.80e7\r## 7 PACER W~ 07 90 26 91 26 NA NA NA NA PACER ~ 7.80e7\r## 8 CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 7.80e7\r## 9 CONCORD~ 07 91 30 NA NA 91 30 NA NA CONCOR~ 7.80e7\r## 10 MATADOR~ 05 97 14 97 14 NA NA NA NA MATADO~ 7.80e7\r## 11 MATADOR~ 06 110 20 NA NA 110 20 NA NA MATADO~ 7.80e7\r## 12 MATADOR~ 09 112 50 NA NA 112 50 NA NA MATADO~ 7.80e7\r## 13 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 14 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 15 AUDI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AUDI 7.81e7\r## 16 FOX 03 84 11 84 11 84 11 NA NA FOX 7.81e7\r## 17 FOX WAG~ 07 83 40 NA NA 83 40 NA NA FOX WA~ 7.81e7\r## 18 5000 04 90 15 NA NA 90 15 NA NA 5000 7.81e7\r## 19 AVANTI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AVANTI 7.81e7\r## 20 AVANTI ~ 02 75 8 75 8 NA NA NA NA AVANTI~ 7.81e7\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  Ao verificar as primeiras 10 linhas do banco, podemos notar algo estranho\nfile \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\rread_lines(file, n_max = 10)\r ## [1] \u0026quot;x,y\u0026quot; \u0026quot;404,NA\u0026quot; \u0026quot;4172,NA\u0026quot; \u0026quot;3004,NA\u0026quot; \u0026quot;787,NA\u0026quot; \u0026quot;37,NA\u0026quot; \u0026quot;2332,NA\u0026quot;\r## [8] \u0026quot;2489,NA\u0026quot; \u0026quot;1449,NA\u0026quot; \u0026quot;3665,NA\u0026quot;\r Parece ser um arquivo csv comum, com duas colunas, mas uma delas parece ter apenas NAs. Se a gente proceder com a importação padrão, chegaremos em\ndf \u0026lt;- read_csv(file)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_logical()\r## )\r ## Warning: 1000 parsing failures.\r## row col expected actual file\r## 1001 y 1/0/T/F/TRUE/FALSE 2015-01-16 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1002 y 1/0/T/F/TRUE/FALSE 2018-05-18 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1003 y 1/0/T/F/TRUE/FALSE 2015-09-05 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1004 y 1/0/T/F/TRUE/FALSE 2012-11-28 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1005 y 1/0/T/F/TRUE/FALSE 2020-01-13 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## .... ... .................. .......... ........................................................................\r## See problems(...) for more details.\r df\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;lgl\u0026gt;\r## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r No console de vocês, deve aparecer que foram importadas as colunas x como double e y como logical. Mas uma chuva de \u0026ldquo;parsing failures\u0026rdquo;, indicando que expected = 1/0/T/F/TRUE/FALSE, actual = 2015-01-16.\nNa verdade, ao tentar adivinhar o tipo de colunas, o readr lê as primeiras 1000 observações em busca de um padrão. Você pode resolver esse problema:\n# 1. Aumentando o número de observações utilizadas para adivinhar as colunas\rdf \u0026lt;- read_csv(file, guess_max = 1001)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_date(format = \u0026quot;\u0026quot;)\r## )\r # A específicação da coluna Y agora é \u0026lt;date\u0026gt;\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r # 2. escolhendo diretamente o tipo de coluna antes da importação\rtipos \u0026lt;- cols(\ry = col_date()\r)\rdf \u0026lt;- read_csv(file, col_types = tipos)\r# Mesmo resultado\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r É sempre bom começar planejando o banco que queremos construir. Queremos um banco que tenha 3 variáveis: o nome, o tipo de prova aplicada e a nota de cada aluno. Para isso, precisamos colocar os nomes das colunas teste1, teste2 e prova1 numa variável e os valores das células em outra. Vamos chamar essas colunas de \u0026ldquo;avaliação\u0026rdquo; e \u0026ldquo;nota\u0026rdquo;, elas formam um par.\nAgora vamos chamar pivot_wider e especificar esses argumentos.\nsala_aula %\u0026gt;% pivot_longer(\r# Primeiro, identificamos as colunas que serão modificadas\rcols = c(teste1, teste2, prova1),\r# Agora, indicamos os nomes das colunas que receberão\r# os nomes das colunas transformadas\rnames_to = \u0026quot;avaliacao\u0026quot;,\r# os valores das células\rvalues_to = \u0026quot;nota\u0026quot;\r)\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r O banco relig_income parece ter uma organização em que temos 2 variáveis, mas uma delas está numa coluna \u0026ldquo;religion\u0026rdquo; e a outra está em 10 colunas, \u0026ldquo;income\u0026rdquo;. Queremos um banco que tenha 3 colunas: a religião, o nível de renda, e o número de pessoas em cada combinação das duas primeiras.\nComo no exerício anterior, vamos chamar pivot_longer e especificar\nrelig_income %\u0026gt;% pivot_longer(\r# As colunas a serem modificadas, notem o uso de ':' para selecionar várias\r# colunas em sequência\rcols = `\u0026lt;$10k`:`Don't know/refused`,\r# Variável recebe os nomes da antiga coluna\rnames_to = \u0026quot;nivel_renda\u0026quot;,\r# Variável recebe os valores das células\rvalues_to = \u0026quot;contagem\u0026quot;\r)\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.   Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\n billboard\r ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r Da mesma forma como fizemos nos anteriores, queremos transformar as várias wk1:wk76 em um par de colunas, uma que me diga a semana e a outra que me diga em que posição no ranking a música estava.\nbillboard %\u0026gt;% pivot_longer(\r# Colunas que serão transformadas\rcols = wk1:wk76,\r# Nome da variável que receberá os nomes das colunas\rnames_to = \u0026quot;semana\u0026quot;,\r# Nome da variável que receberá os valores das células\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\r# Nesse caso, uso o argumento opcional para eliminar os NAs\rvalues_drop_na = TRUE\r# Experimente mudar este argumento para FALSE e veja o resultado\r# Quando uma música não está mais nas paradas, ela recebe NA. Acho\r# justificado excluir os NAs nesse caso.\r)\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?  Vou começar enxugando os códigos anteriores para criar os resultados que produzimos e salvá-los em objetos.\nsala_aula_long \u0026lt;- sala_aula %\u0026gt;% pivot_longer(\rcols = c(teste1, teste2, prova1),\rnames_to = \u0026quot;avaliacao\u0026quot;,\rvalues_to = \u0026quot;nota\u0026quot;\r)\rrelig_income_long \u0026lt;- relig_income %\u0026gt;% pivot_longer(\rcols = `\u0026lt;$10k`:`Don't know/refused`,\rnames_to = \u0026quot;nivel_renda\u0026quot;,\rvalues_to = \u0026quot;contagem\u0026quot;\r)\rbillboard_long \u0026lt;- billboard %\u0026gt;% pivot_longer(\rcols = wk1:wk76,\rnames_to = \u0026quot;semana\u0026quot;,\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\rvalues_drop_na = TRUE\r)\rsala_aula_long\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r relig_income_long\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r billboard_long\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r O caminho inverso desses bancos de dados, é utilizar pivot_wider. Aqui, vamos escolher um par de colunas que contém:\n O nome das colunas que queremos criar O valor que queremos passar para as células dessas novas colunas  Vamos ver exemplos comentados como no anterior\nsala_aula_long %\u0026gt;% pivot_wider(\r# Aqui, identificamos colunas que NÃO SERÃO MODIFICADAS\r# É o contrário de pivot_longer. Por padrão, são todas as que não são\r# mencionadas na transformação, mas para deixar bem claro, # vou deixar explícito.\rid_cols = name,\r# Variável com os nomes para as novas colunas\rnames_from = avaliacao,\r# Variável com os valores para as células\rvalues_from = nota\r)\r ## # A tibble: 4 x 4\r## name teste1 teste2 prova1\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Billy \u0026lt;NA\u0026gt; D C ## 2 Suzy F \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; ## 3 Lionel B C B ## 4 Jenny A A B\r relig_income_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = religion,\r# Variável com os nomes para as novas colunas\rnames_from = nivel_renda,\r# Variável com os valores para as células\rvalues_from = contagem\r)\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r billboard_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = c(artist, track, date.entered),\r# Variável com os nomes para as novas colunas\rnames_from = semana,\r# Variável com os valores para as células\rvalues_from = posicao_rank\r)\r ## # A tibble: 317 x 68\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 57 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;\r Tanto pivot_longer quanto pivot_wider tem mais argumentos para lidar com situações complexas, como quando você precisa aplicar transformações em variáveis antes de reformatar o banco ou precisa utilizar múltiplas colunas, mas eu deixo isso para vocês descobrirem por conta própria quando estiverem confortáveis com a sintaxe básica.\nO que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r Por padrão, separate espera que todas as colunas sendo separadas tenham o mesmo comprimento. Por exemplo, no primeiro caso, indicamos que vamos criar três novas colunas, chamadas de \u0026ldquo;um\u0026rdquo;, \u0026ldquo;dois\u0026rdquo; e \u0026ldquo;tres\u0026rdquo;. Mas os vetores tem tamanhos diferentes. Um deles tem 4 letras ao invés de 3. No segundo exemplo, um deles tem duas letras ao invés de três. Esse tipo de situação é bastante comum quando lidamos com erros de digitação. Então, o que fazer com o elemento que está sobrando ou faltando?\n# Sobrando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;warn\u0026quot;) # avise que ocorreu (padrão)\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;drop\u0026quot;) # descarte o que sobrou\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;merge\u0026quot;) # junte com o último\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f,g ## 3 h i j\r # Note especialmente no último caso o que ocorreu com as colunas.\r# Faltando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;warn\u0026quot;) # avise e preencha a direita\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;left\u0026quot;) # preencha a esquerda\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 \u0026lt;NA\u0026gt; d e ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;right\u0026quot;) # preencha a direta\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r # Note na sua saída do R como ficou a tibble e onde foram colocados NAs\r# em cada caso\r Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?  Acho que a melhor forma de compreender isso é utilizar um banco de dados. Vamos pegar aquele da população retirado da Wikipédia.\npopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Vamos ver dois exemplos, um com unite e outro com separate para exemplificar o que remove faz.\n# Unir as colunas Day, Month, Year, remove = TRUE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = TRUE) # padrão\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19_May_20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19_May_20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31_Dec_20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19_May_20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19_May_20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1_Jan_2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2_Mar_2020 2020 census result[9]\r # Unir as colunas Day, Month, Year, remove = FALSE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = FALSE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Data Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_~ 1 Nov 2020 Seventh Ce~\r## 2 2 India 1377123716 17.5% 19_May~ 19 May 2021 National p~\r## 3 3 United S~ 331695937 4.22% 19_May~ 19 May 2021 National p~\r## 4 4 Indonesia 271350000 3.45% 31_Dec~ 31 Dec 2020 National a~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_~ 1 Jul 2021 UN project~\r## 6 6 Brazil 213154869 2.71% 19_May~ 19 May 2021 National p~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_~ 1 Jul 2021 UN project~\r## 8 8 Banglade~ 170689832 2.17% 19_May~ 19 May 2021 National p~\r## 9 9 Russia 146171015 1.86% 1_Jan_~ 1 Jan 2021 National a~\r## 10 10 Mexico 126014024 1.60% 2_Mar_~ 2 Mar 2020 2020 censu~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Agora com separate: Separar a coluna year em século e ano, apenas como exemplo\n# remove = TRUE, padrão\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = TRUE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Day Month seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 20 20 Seventh Cen~\r## 2 2 India 1377123716 17.5% 19 May 20 21 National po~\r## 3 3 United S~ 331695937 4.22% 19 May 20 21 National po~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20 20 National an~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 20 21 UN projecti~\r## 6 6 Brazil 213154869 2.71% 19 May 20 21 National po~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 20 21 UN projecti~\r## 8 8 Banglade~ 170689832 2.17% 19 May 20 21 National po~\r## 9 9 Russia 146171015 1.86% 1 Jan 20 21 National an~\r## 10 10 Mexico 126014024 1.60% 2 Mar 20 20 2020 census~\r # remove = FALSE\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = FALSE)\r ## # A tibble: 10 x 10\r## Rank Country Population `% of world` Day Month Year seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 20 20 Sevent~\r## 2 2 India 1377123716 17.5% 19 May 2021 20 21 Nation~\r## 3 3 United ~ 331695937 4.22% 19 May 2021 20 21 Nation~\r## 4 4 Indones~ 271350000 3.45% 31 Dec 2020 20 20 Nation~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 20 21 UN pro~\r## 6 6 Brazil 213154869 2.71% 19 May 2021 20 21 Nation~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 20 21 UN pro~\r## 8 8 Banglad~ 170689832 2.17% 19 May 2021 20 21 Nation~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 20 21 Nation~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 20 20 2020 c~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Eu gosto de utilizar esse argumento quando eu tenho dúvida sobre o resultado e quero fazer inspeção visual para detectar eventuais problemas na separação ou junção. Uma vez que estou satisfeito com o resultado, em geral eu uso o remove=TRUE. Vocês tem que decidir se precisam manter as colunas originais ou se a coluna transformada é o suficiente.\nCompare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?  A resposta curta é simples: em pivot_wider, podemos ter aqueles missings \u0026ldquo;implícitos\u0026rdquo; que não apareciam no nosso banco longo e, durante a transformação, eles viram NAs nas colunas. Ó argumento values_fill indica um valor para ser preenchido no lugar de NA.\nEm complete, temos uma situação similar. O que fazer quando for encontrada uma combinação de valores no banco longo que é um \u0026ldquo;missing implícito\u0026rdquo;? Você pode especificar um valor padrão para preenchê-lo.\nSão funções similares, mas uma funciona sem reformatar o banco e a outra durante o processo de reformatação. Veja um exemplo abaixo com aquela tibble das ações.\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\racoes\r ## # A tibble: 7 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 2 0.92\r## 6 2016 3 0.17\r## 7 2016 4 2.66\r # Vamos supor que o NA implícito significa que a empresa teve # lucro = 0 naquele quadrimestre.\r# pivot_wider, values_fill\racoes %\u0026gt;% pivot_wider(\rid_cols = ano,\rnames_from = qdr,\rvalues_from = lucro,\rvalues_fill = 0\r)\r ## # A tibble: 2 x 5\r## ano `1` `2` `3` `4`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1.88 0.59 0.35 NA ## 2 2016 0 0.92 0.17 2.66\r # complete, fill\racoes %\u0026gt;% complete(ano, qdr, fill = list(lucro = 0))\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 0 ## 5 2016 1 0 ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Note o resultado. E note também que values_fill em pivot_wider é um pouco mais criterioso na hora de fazer as transformações.\nstringr, forcats e dplyr library(nycflights13)\r   Encontre os vôos que:\n  Atrasaram mais de duas horas\n  flights %\u0026gt;% filter(dep_delay \u0026gt; 120)\r ## # A tibble: 9,723 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 848 1835 853 1001 1950\r## 2 2013 1 1 957 733 144 1056 853\r## 3 2013 1 1 1114 900 134 1447 1222\r## 4 2013 1 1 1540 1338 122 2020 1825\r## 5 2013 1 1 1815 1325 290 2120 1542\r## 6 2013 1 1 1842 1422 260 1958 1535\r## 7 2013 1 1 1856 1645 131 2212 2005\r## 8 2013 1 1 1934 1725 129 2126 1855\r## 9 2013 1 1 1938 1703 155 2109 1823\r## 10 2013 1 1 1942 1705 157 2124 1830\r## # ... with 9,713 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Com destino a Houston (IAH ou HOU)  flights %\u0026gt;% filter(dest %in% c(\u0026quot;IAH\u0026quot;, \u0026quot;HOU\u0026quot;))\r ## # A tibble: 9,313 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 623 627 -4 933 932\r## 4 2013 1 1 728 732 -4 1041 1038\r## 5 2013 1 1 739 739 0 1104 1038\r## 6 2013 1 1 908 908 0 1228 1219\r## 7 2013 1 1 1028 1026 2 1350 1339\r## 8 2013 1 1 1044 1045 -1 1352 1351\r## 9 2013 1 1 1114 900 134 1447 1222\r## 10 2013 1 1 1205 1200 5 1503 1505\r## # ... with 9,303 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Operados pela United, American ou Delta  unique(flights$carrier)\r ## [1] \u0026quot;UA\u0026quot; \u0026quot;AA\u0026quot; \u0026quot;B6\u0026quot; \u0026quot;DL\u0026quot; \u0026quot;EV\u0026quot; \u0026quot;MQ\u0026quot; \u0026quot;US\u0026quot; \u0026quot;WN\u0026quot; \u0026quot;VX\u0026quot; \u0026quot;FL\u0026quot; \u0026quot;AS\u0026quot; \u0026quot;9E\u0026quot; \u0026quot;F9\u0026quot; \u0026quot;HA\u0026quot; \u0026quot;YV\u0026quot;\r## [16] \u0026quot;OO\u0026quot;\r flights %\u0026gt;% filter(carrier %in% c(\u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;DL\u0026quot;))\r ## # A tibble: 139,504 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 554 600 -6 812 837\r## 5 2013 1 1 554 558 -4 740 728\r## 6 2013 1 1 558 600 -2 753 745\r## 7 2013 1 1 558 600 -2 924 917\r## 8 2013 1 1 558 600 -2 923 937\r## 9 2013 1 1 559 600 -1 941 910\r## 10 2013 1 1 559 600 -1 854 902\r## # ... with 139,494 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre julho e setembro  flights %\u0026gt;% filter(between(month, 7, 9))\r ## # A tibble: 86,326 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 7 1 1 2029 212 236 2359\r## 2 2013 7 1 2 2359 3 344 344\r## 3 2013 7 1 29 2245 104 151 1\r## 4 2013 7 1 43 2130 193 322 14\r## 5 2013 7 1 44 2150 174 300 100\r## 6 2013 7 1 46 2051 235 304 2358\r## 7 2013 7 1 48 2001 287 308 2305\r## 8 2013 7 1 58 2155 183 335 43\r## 9 2013 7 1 100 2146 194 327 30\r## 10 2013 7 1 100 2245 135 337 135\r## # ... with 86,316 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Chegaram com mais de duas horas de atraso, mas não decolaram com atraso  flights %\u0026gt;% filter(arr_delay \u0026gt; 120, dep_delay \u0026lt;= 0)\r ## # A tibble: 29 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 27 1419 1420 -1 1754 1550\r## 2 2013 10 7 1350 1350 0 1736 1526\r## 3 2013 10 7 1357 1359 -2 1858 1654\r## 4 2013 10 16 657 700 -3 1258 1056\r## 5 2013 11 1 658 700 -2 1329 1015\r## 6 2013 3 18 1844 1847 -3 39 2219\r## 7 2013 4 17 1635 1640 -5 2049 1845\r## 8 2013 4 18 558 600 -2 1149 850\r## 9 2013 4 18 655 700 -5 1213 950\r## 10 2013 5 22 1827 1830 -3 2217 2010\r## # ... with 19 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo  flights %\u0026gt;% filter(dep_delay \u0026gt; 60, dep_delay - arr_delay \u0026gt;= 30)\r ## # A tibble: 2,046 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 1716 1545 91 2140 2039\r## 2 2013 1 1 2205 1720 285 46 2040\r## 3 2013 1 1 2326 2130 116 131 18\r## 4 2013 1 3 1503 1221 162 1803 1555\r## 5 2013 1 3 1821 1530 171 2131 1910\r## 6 2013 1 3 1839 1700 99 2056 1950\r## 7 2013 1 3 1850 1745 65 2148 2120\r## 8 2013 1 3 1923 1815 68 2036 1958\r## 9 2013 1 3 1941 1759 102 2246 2139\r## 10 2013 1 3 1950 1845 65 2228 2227\r## # ... with 2,036 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre a meia-noite e 6 da manhã (inclusive)  flights %\u0026gt;% filter(between(hour, 0, 5) | (hour == 6 \u0026amp; minute == 0))\r ## # A tibble: 8,970 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 8,960 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).  flights %\u0026gt;% select(air_time, distance) %\u0026gt;% mutate(speed = distance/air_time) %\u0026gt;% arrange(desc(speed))\r ## # A tibble: 336,776 x 3\r## air_time distance speed\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 65 762 11.7 ## 2 93 1008 10.8 ## 3 55 594 10.8 ## 4 70 748 10.7 ## 5 105 1035 9.86\r## 6 170 1598 9.4 ## 7 172 1598 9.29\r## 8 175 1623 9.27\r## 9 173 1598 9.24\r## 10 173 1598 9.24\r## # ... with 336,766 more rows\r Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.  flights %\u0026gt;% select(dep_time, dep_delay, arr_time, arr_delay)\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(matches(\u0026quot;^arr|^dep\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(!starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;car\u0026quot;)) \u0026amp; contains(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(ends_with(c(\u0026quot;time\u0026quot;, \u0026quot;delay\u0026quot;)) \u0026amp; !starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;air\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time arr_time dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 830 2 11\r## 2 533 850 4 20\r## 3 542 923 2 33\r## 4 544 1004 -1 -18\r## 5 554 812 -6 -25\r## 6 554 740 -4 12\r## 7 555 913 -5 19\r## 8 557 709 -3 -14\r## 9 557 838 -3 -8\r## 10 558 753 -2 8\r## # ... with 336,766 more rows\r As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.  flights %\u0026gt;% mutate(\rdep_hour = dep_time %/% 100,\rdep_minute = dep_time %% 100,\rsched_dep_hour = sched_dep_time %/% 100,\rsched_arr_minute = sched_arr_time %% 100\r)\r ## # A tibble: 336,776 x 23\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 15 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;,\r## # dep_hour \u0026lt;dbl\u0026gt;, dep_minute \u0026lt;dbl\u0026gt;, sched_dep_hour \u0026lt;dbl\u0026gt;,\r## # sched_arr_minute \u0026lt;dbl\u0026gt;\r # Há uma outra solução com separate!\rflights %\u0026gt;% separate(\rcol = dep_time,\rinto = c(\u0026quot;dep_hour\u0026quot;, \u0026quot;dep_minute\u0026quot;),\rsep = 1,\r# Esse argumento é importante! Teste com FALSE para ver a diferença\rconvert = TRUE) %\u0026gt;% separate(\rcol = sched_dep_time,\rinto = c(\u0026quot;sched_dep_hour\u0026quot;, \u0026quot;sched_dep_minute\u0026quot;),\rsep = 1,\rconvert = TRUE)\r ## # A tibble: 336,776 x 21\r## year month day dep_hour dep_minute sched_dep_hour sched_dep_minute\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 17 5 15\r## 2 2013 1 1 5 33 5 29\r## 3 2013 1 1 5 42 5 40\r## 4 2013 1 1 5 44 5 45\r## 5 2013 1 1 5 54 6 0\r## 6 2013 1 1 5 54 5 58\r## 7 2013 1 1 5 55 6 0\r## 8 2013 1 1 5 57 6 0\r## 9 2013 1 1 5 57 6 0\r## 10 2013 1 1 5 58 6 0\r## # ... with 336,766 more rows, and 14 more variables: dep_delay \u0026lt;dbl\u0026gt;,\r## # arr_time \u0026lt;int\u0026gt;, sched_arr_time \u0026lt;int\u0026gt;, arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Existe uma outra solução possível para essa questão usando manipulação de strings, com str_sub também. Fica como desafio!\nPensando na legibilidade do código e na flexibilidade da abordagem, qual das duas soluções acima você implementaria? mutate ou duas separate? Reflita.\nO que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Essa tem uma resposta mais qualitativa. A primeira parte é parecida com a questão anterior, mas estamos manualmente tentando calcular os tempos de viagem. Acontece que os valores não batem com os tempos de vôo identificados no banco. Isso se deve a pelo menos três questões distintas.\n Uma delas diz respeito ao registro dos tempos, a definição de air_time pode não estar considerando tempos em que o avião está manobrando ou em solo ou mesmo podem existir erros de preenchimento. A segunda diz respeito ao fuso horário distinto entre aeroportos de saída e chegada, que complica o cálculo dos tempos reais, então nosso cálculo está muito cru para identificar isso. A última questão são os vôos longos, que começam em um dia e terminam no dia seguinte, que podem prejudicar nosso método de cálculo. Para corrigir alguns desses problemas, você precisaria escrever um código que minimamente levasse essas questões em consideração. Como esse não é o objetivo do curso, eu deixo para quem quiser tentar. Há uma solução postada aqui.  Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\rstr_c(z, w, y, sep = \u0026quot; \u0026quot;) %\u0026gt;% str_c(x, sep = \u0026quot;\u0026quot;) %\u0026gt;% str_to_sentence()\r ## [1] \u0026quot;Hoje acordei feliz.\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r# Sem dplyr\rdf$pais \u0026lt;- str_to_title(df$pais)\rdf$primeiro_nome \u0026lt;- str_to_title(df$primeiro_nome)\rdf$segundo_nome \u0026lt;- str_to_title(df$segundo_nome)\rdf \u0026lt;- df %\u0026gt;% tidyr::unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;)\rdf[ str_order(df$nomes), ]\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r # Com dplyr\rdf \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\rdf %\u0026gt;% mutate(pais = str_to_title(pais),\rprimeiro_nome = str_to_title(primeiro_nome),\rsegundo_nome = str_to_title(segundo_nome)) %\u0026gt;% unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;) %\u0026gt;% arrange(str_order(nomes))\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r x \u0026lt;- c(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\rx[1] \u0026lt;- str_sub(x[1], 1, 1) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[2] \u0026lt;- str_sub(x[2], 4, 4) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[3] \u0026lt;- str_to_upper(x[3])\rstr_c(c(x[3], x[1], x[2]), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;MAIA V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: \u0026ldquo;150\u0026rdquo;, \u0026ldquo;219\u0026rdquo;, \u0026ldquo;312\u0026rdquo;, \u0026ldquo;471\u0026rdquo;. Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;118\u0026quot; \u0026quot;114\u0026quot; \u0026quot;118\u0026quot; \u0026quot;120\u0026quot; \u0026quot;109\u0026quot; \u0026quot;104\u0026quot; \u0026quot;114\u0026quot; \u0026quot;117\u0026quot; \u0026quot;122\u0026quot; \u0026quot;109\u0026quot; \u0026quot;110\u0026quot; \u0026quot;113\u0026quot;\r## [13] \u0026quot;106\u0026quot; \u0026quot;100\u0026quot; \u0026quot;122\u0026quot; \u0026quot;121\u0026quot; \u0026quot;124\u0026quot; \u0026quot;124\u0026quot; \u0026quot;110\u0026quot; \u0026quot;100\u0026quot; \u0026quot;117\u0026quot; \u0026quot;119\u0026quot; \u0026quot;105\u0026quot; \u0026quot;118\u0026quot;\r## [25] \u0026quot;122\u0026quot; \u0026quot;201\u0026quot; \u0026quot;205\u0026quot; \u0026quot;212\u0026quot; \u0026quot;216\u0026quot; \u0026quot;228\u0026quot; \u0026quot;213\u0026quot; \u0026quot;227\u0026quot; \u0026quot;221\u0026quot; \u0026quot;214\u0026quot; \u0026quot;227\u0026quot; \u0026quot;206\u0026quot;\r## [37] \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;224\u0026quot; \u0026quot;223\u0026quot; \u0026quot;203\u0026quot; \u0026quot;221\u0026quot; \u0026quot;215\u0026quot; \u0026quot;225\u0026quot; \u0026quot;210\u0026quot; \u0026quot;208\u0026quot; \u0026quot;219\u0026quot; \u0026quot;207\u0026quot;\r## [49] \u0026quot;221\u0026quot; \u0026quot;227\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;301\u0026quot; \u0026quot;304\u0026quot; \u0026quot;310\u0026quot; \u0026quot;307\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;308\u0026quot; \u0026quot;306\u0026quot;\r## [61] \u0026quot;308\u0026quot; \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;306\u0026quot; \u0026quot;302\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;301\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;304\u0026quot;\r## [73] \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;307\u0026quot; \u0026quot;401\u0026quot; \u0026quot;459\u0026quot; \u0026quot;429\u0026quot; \u0026quot;435\u0026quot; \u0026quot;435\u0026quot; \u0026quot;415\u0026quot; \u0026quot;475\u0026quot; \u0026quot;414\u0026quot; \u0026quot;419\u0026quot;\r## [85] \u0026quot;495\u0026quot; \u0026quot;475\u0026quot; \u0026quot;431\u0026quot; \u0026quot;460\u0026quot; \u0026quot;478\u0026quot; \u0026quot;447\u0026quot; \u0026quot;436\u0026quot; \u0026quot;412\u0026quot; \u0026quot;403\u0026quot; \u0026quot;423\u0026quot; \u0026quot;467\u0026quot; \u0026quot;438\u0026quot;\r## [97] \u0026quot;475\u0026quot; \u0026quot;467\u0026quot; \u0026quot;418\u0026quot; \u0026quot;476\u0026quot;\r # Esse exercício é um pouco mais difícil mesmo!\rx %\u0026gt;% str_extract(\u0026quot;\\\\d\u0026quot;)\r ## [1] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot;\r## [19] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot;\r## [37] \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [55] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [73] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r## [91] \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r tibble(\rtipo_idade = str_sub(x, 1, 1),\ridade = str_sub(x, 2, 3),\ridade_anos =\rif_else(\rstr_detect(tipo_idade, \u0026quot;1\u0026quot;),\ras.numeric(idade) / (24 * 30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;2\u0026quot;),\ras.numeric(idade) / (30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;3\u0026quot;),\ras.numeric(idade) / 12,\ras.numeric(idade)\r)\r)\r)\r) %\u0026gt;% print(n = Inf)\r ## # A tibble: 100 x 3\r## tipo_idade idade idade_anos\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 18 0.00208 ## 2 1 14 0.00162 ## 3 1 18 0.00208 ## 4 1 20 0.00231 ## 5 1 09 0.00104 ## 6 1 04 0.000463\r## 7 1 14 0.00162 ## 8 1 17 0.00197 ## 9 1 22 0.00255 ## 10 1 09 0.00104 ## 11 1 10 0.00116 ## 12 1 13 0.00150 ## 13 1 06 0.000694\r## 14 1 00 0 ## 15 1 22 0.00255 ## 16 1 21 0.00243 ## 17 1 24 0.00278 ## 18 1 24 0.00278 ## 19 1 10 0.00116 ## 20 1 00 0 ## 21 1 17 0.00197 ## 22 1 19 0.00220 ## 23 1 05 0.000579\r## 24 1 18 0.00208 ## 25 1 22 0.00255 ## 26 2 01 0.00278 ## 27 2 05 0.0139 ## 28 2 12 0.0333 ## 29 2 16 0.0444 ## 30 2 28 0.0778 ## 31 2 13 0.0361 ## 32 2 27 0.075 ## 33 2 21 0.0583 ## 34 2 14 0.0389 ## 35 2 27 0.075 ## 36 2 06 0.0167 ## 37 2 07 0.0194 ## 38 2 15 0.0417 ## 39 2 24 0.0667 ## 40 2 23 0.0639 ## 41 2 03 0.00833 ## 42 2 21 0.0583 ## 43 2 15 0.0417 ## 44 2 25 0.0694 ## 45 2 10 0.0278 ## 46 2 08 0.0222 ## 47 2 19 0.0528 ## 48 2 07 0.0194 ## 49 2 21 0.0583 ## 50 2 27 0.075 ## 51 3 10 0.833 ## 52 3 05 0.417 ## 53 3 01 0.0833 ## 54 3 04 0.333 ## 55 3 10 0.833 ## 56 3 07 0.583 ## 57 3 05 0.417 ## 58 3 09 0.75 ## 59 3 08 0.667 ## 60 3 06 0.5 ## 61 3 08 0.667 ## 62 3 05 0.417 ## 63 3 04 0.333 ## 64 3 03 0.25 ## 65 3 06 0.5 ## 66 3 02 0.167 ## 67 3 10 0.833 ## 68 3 06 0.5 ## 69 3 01 0.0833 ## 70 3 10 0.833 ## 71 3 06 0.5 ## 72 3 04 0.333 ## 73 3 05 0.417 ## 74 3 04 0.333 ## 75 3 07 0.583 ## 76 4 01 1 ## 77 4 59 59 ## 78 4 29 29 ## 79 4 35 35 ## 80 4 35 35 ## 81 4 15 15 ## 82 4 75 75 ## 83 4 14 14 ## 84 4 19 19 ## 85 4 95 95 ## 86 4 75 75 ## 87 4 31 31 ## 88 4 60 60 ## 89 4 78 78 ## 90 4 47 47 ## 91 4 36 36 ## 92 4 12 12 ## 93 4 03 3 ## 94 4 23 23 ## 95 4 67 67 ## 96 4 38 38 ## 97 4 75 75 ## 98 4 67 67 ## 99 4 18 18 ## 100 4 76 76\r Ao invés de utilizar essas chamadas recursivas de if_else, que são muito ruins de ler, como você poderia reescrever a condição usando case_when?\nExplore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?  gss_cat %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r Em geral, contagens de variáveis ficam bem em gráficos de barras ou visualizações equivalentes, em que é possível comparar visualmente as contagens das diversas categorias. Mais sobre isso na aula do ggplot2.\nQual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?  # Religião\rgss_cat %\u0026gt;% count(relig) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 15 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Protestant 10846\r## 2 Catholic 5124\r## 3 None 3523\r## 4 Christian 689\r## 5 Jewish 388\r## 6 Other 224\r## 7 Buddhism 147\r## 8 Inter-nondenominational 109\r## 9 Moslem/islam 104\r## 10 Orthodox-christian 95\r## 11 No answer 93\r## 12 Hinduism 71\r## 13 Other eastern 32\r## 14 Native american 23\r## 15 Don't know 15\r # Partido\rgss_cat %\u0026gt;% count(partyid) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Independent 4119\r## 2 Not str democrat 3690\r## 3 Strong democrat 3490\r## 4 Not str republican 3032\r## 5 Ind,near dem 2499\r## 6 Strong republican 2314\r## 7 Ind,near rep 1791\r## 8 Other party 393\r## 9 No answer 154\r## 10 Don't know 1\r A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?  Você pode chamar count com várias variáveis para fazer uma tabulação cruzada.\ngss_cat %\u0026gt;% count(relig, denom) %\u0026gt;% print(n = Inf)\r ## # A tibble: 47 x 3\r## relig denom n\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer No answer 93\r## 2 Don't know Not applicable 15\r## 3 Inter-nondenominational Not applicable 109\r## 4 Native american Not applicable 23\r## 5 Christian No answer 2\r## 6 Christian Don't know 11\r## 7 Christian No denomination 452\r## 8 Christian Not applicable 224\r## 9 Orthodox-christian Not applicable 95\r## 10 Moslem/islam Not applicable 104\r## 11 Other eastern Not applicable 32\r## 12 Hinduism Not applicable 71\r## 13 Buddhism Not applicable 147\r## 14 Other No denomination 7\r## 15 Other Not applicable 217\r## 16 None Not applicable 3523\r## 17 Jewish Not applicable 388\r## 18 Catholic Not applicable 5124\r## 19 Protestant No answer 22\r## 20 Protestant Don't know 41\r## 21 Protestant No denomination 1224\r## 22 Protestant Other 2534\r## 23 Protestant Episcopal 397\r## 24 Protestant Presbyterian-dk wh 244\r## 25 Protestant Presbyterian, merged 67\r## 26 Protestant Other presbyterian 47\r## 27 Protestant United pres ch in us 110\r## 28 Protestant Presbyterian c in us 104\r## 29 Protestant Lutheran-dk which 267\r## 30 Protestant Evangelical luth 122\r## 31 Protestant Other lutheran 30\r## 32 Protestant Wi evan luth synod 71\r## 33 Protestant Lutheran-mo synod 212\r## 34 Protestant Luth ch in america 71\r## 35 Protestant Am lutheran 146\r## 36 Protestant Methodist-dk which 239\r## 37 Protestant Other methodist 33\r## 38 Protestant United methodist 1067\r## 39 Protestant Afr meth ep zion 32\r## 40 Protestant Afr meth episcopal 77\r## 41 Protestant Baptist-dk which 1457\r## 42 Protestant Other baptists 213\r## 43 Protestant Southern baptist 1536\r## 44 Protestant Nat bapt conv usa 40\r## 45 Protestant Nat bapt conv of am 76\r## 46 Protestant Am bapt ch in usa 130\r## 47 Protestant Am baptist asso 237\r Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?  A melhor função para redução de fatores é fct_collapse. Veja como ficam a coluna original e a transformada.\ngss_cat2 \u0026lt;- gss_cat %\u0026gt;% # Aqui vou salvar em \u0026quot;rincome2\u0026quot; para a gente poder ver as duas\rmutate(rincome2 = fct_collapse(\rrincome,\r\u0026quot;Non-response\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Refused\u0026quot;, \u0026quot;Not applicable\u0026quot;),\r\u0026quot;Até 5k\u0026quot; = c(\u0026quot;$4000 to 4999\u0026quot;, \u0026quot;$3000 to 3999\u0026quot;, \u0026quot;$1000 to 2999\u0026quot;, \u0026quot;Lt $1000\u0026quot;),\r\u0026quot;5k-10k\u0026quot; = c( \u0026quot;$8000 to 9999\u0026quot;, \u0026quot;$7000 to 7999\u0026quot;, \u0026quot;$6000 to 6999\u0026quot;, \u0026quot;$5000 to 5999\u0026quot;),\r\u0026quot;10k-20k\u0026quot; = c(\u0026quot;$15000 - 19999\u0026quot;, \u0026quot;$10000 - 14999\u0026quot;),\r\u0026quot;20k+\u0026quot; = c(\u0026quot;$25000 or more\u0026quot;, \u0026quot;$20000 - 24999\u0026quot;))) %\u0026gt;% select(rincome, rincome2)\r# E veja as contagens\rgss_cat2 %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r gss_cat2 %\u0026gt;% count(rincome2)\r ## # A tibble: 5 x 2\r## rincome2 n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Non-response 8468\r## 2 20k+ 8646\r## 3 10k-20k 2216\r## 4 5k-10k 970\r## 5 Até 5k 1183\r ggplot2  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r Os pontos não ficam azuis porque você não está especificando cores! Dentro da função aes() você está especificando variáveis para serem mapeadas a uma escala de cores. Portanto, o ggplot interpreta \u0026ldquo;blue\u0026rdquo; como uma variável sem nome que tem o valor \u0026ldquo;blue\u0026rdquo; e mapeia ela para a escala de cores padrão, que é vermelha. Se você quer controlar apenas a \u0026ldquo;aparência\u0026rdquo; dos pontos e não está preocupada em mapear nenhuma variável, você pode passar essa estética fora da função aes().\nggplot(data = mpg) + geom_point(\rmapping = aes(x = displ, y = hwy), # aqui acabam os mapeamentos estéticos\rcolor = \u0026quot;blue\u0026quot;, # alteração apenas na aparência do geom\rsize = 2, # alteração apenas na aparência do geom\rshape = 6 # alteração apenas na aparência do geom\r)  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?  ggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point()\r ## Warning: The shape palette can deal with a maximum of 6 discrete values because\r## more than 6 becomes difficult to discriminate; you have 15. Consider\r## specifying shapes manually if you must have them.\r ## Warning: Removed 112 rows containing missing values (geom_point).\r Ao cumprir as instruções como dadas, logo de cara você recebe um aviso do ggplot2. A paleta de \u0026ldquo;shapes\u0026rdquo; só recebe por padrão 6 shapes diferentes, porque de acordo com o autor, mais de 6 torna difícil de distinguir. Mas eu sou teimoso.\nggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point() +\rscale_shape_manual(values = 1:15, guide = \u0026quot;legend\u0026quot;)\r Esse gráfico é mais um exemplo para vocês verem como diferentes escalas se comportam. A variável cyl é numérica e ordenada, então faz sentido colocá-la num mapeamento como size, já que visualmente é possível indicar que a grandeza aumenta com o tamanho. Classe é uma variável categórica, então ela fica melhor em mapeamentos que ressaltam diferenças entre as categorias, como colors ou shapes. O pacote também impõe algumas restrições sobre o que é possível mapear. Por exemplo, ele retorna erro se você tenta mapear uma variável discreta para uma escala contínua.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rscale_color_continuous()\r ## Error: Discrete value supplied to continuous scale\r Experimentem tentar mapear diferentes variáveis no banco mpg para as diferentes escalas e vejam os resultados. Em alguns casos, é possível, mas o gráfico é pouco informativo, em outros, você verá mensagens de erro.\nUtilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.  Esse exercício não tem uma resposta correta. O objetivo era que vocês explorassem as transformações estatísticas e as escalas de cores diferentes presentes no ggplot, através do argumento trans, ou mesmo fazer outras transformações que interessassem vocês nas variáveis. Abaixo um exemplo de transformação de Yeo-Johnson, um tipo de transformação BoxCox que aceita valores negativos e uma das escalas de cor do pacote viridis.\nggplot(diamonds, aes(carat, price, color = clarity)) +\rgeom_point() +\rscale_x_continuous(trans = scales::yj_trans(p = 2)) +\rscale_color_viridis_d(option = \u0026quot;magma\u0026quot;)\r Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.  Segundo a mesma lógica, o objetivo era explorar as opções de visualização de modelos simples através do argumento method. Abaixo um exemplo de gam. Uma mudança que fiz foi usar a variável cut ao invés de clarity, porque o gráfico não-transformado de clarity estava muito poluído.\nggplot(diamonds, aes(carat, price, color = cut)) +\rgeom_point(alpha = 0.1) + # pontos translúcidos para reduzir a poluição\rgeom_smooth(method = \u0026quot;gam\u0026quot;, se = FALSE) +\rscale_color_viridis_d(option = \u0026quot;plasma\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ s(x, bs = \u0026quot;cs\u0026quot;)'\r No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r Acabei explicando isso na aula, devido a uma pergunta, mas para quem perdeu, trata-se do comportamento padrão quando há proporções: cada barra terá sua própria proporção e todas somarão a 100%. O uso de group = 1 indica à função que as proporções que somam a 100% são o total dos níveis do fator e não cada nível individualmente.\nggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop), group = 1))\r # No caso em que há um \u0026quot;fill\u0026quot;, precisamos normalizar as alturas das barras\rggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(prop),\rfill = clarity\r))\r ggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(count)/sum(stat(count)),\rfill = clarity\r))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  geom_smooth chama stat_smooth quando você utiliza a função para calcular as \u0026ldquo;médias condicionais\u0026rdquo; que correspondem a linha de tendência desenhada no gráfico. É assim com todos os geoms no pacote. Há uma conexão entre o objeto geométrico e uma transformação estatística. Mesmo que seja a transformação _identity, que mantém a variável exatamente como ela estava no dado. A grande vantagem de construir um gráfico com stat_smooth ao invés de geom_smooth é que você pode especificar outro objeto geométrico que não seja o padrão (geom_line + geom_ribbon). É isso que os gráficos abaixo demonstram.\nggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.  Esse aqui é para demonstrar o uso de facet_grid, que permite especificar fatores de classificação diferentes nas linhas e colunas, diferente de facet_wrap mostrado na aula, que só permite especificar uma dimensão.\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rfacet_grid(cyl ~ drv)\r Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Mesmo antes de rodar o código, o observador astuto notará que os mapeamentos locais no segundo gráfico são idênticos entre si e aos mapeamentos globais, então os dois gráficos são iguais.\nTente recriar o seguinte gráfico  O objetivo dessa era fazer vocês fuçarem um pouco na ajuda para tentar recriar o mais fielmente possível o gráfico final. Não precisava ter acertado, o objetivo era chegar o mais próximo possível.\nggplot(mpg, aes(displ, hwy, color = drv)) +\rgeom_point() +\rgeom_smooth(method = lm, se = FALSE) +\rlabs(x = \u0026quot;Rodovia\u0026quot;, y = \u0026quot;Toneladas\u0026quot;, color = \u0026quot;Tração\u0026quot;) +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r Depois de simplesmente especificar coord_polar, em geral o gráfico fica meio estranho, não tem aquela cara bonita de pizza. É preciso corrigir os seguintes problemas:\n A largura das barras deve ser igual a proporção das contagens, mas a altura deve ser igual a 1! Portanto, eu inverto as coisas e passo as contagens/proporções para \u0026ldquo;x\u0026rdquo; e \u0026ldquo;y\u0026rdquo; fica com o valor fixo = 1.  ggplot(diamonds, aes(\r# calculando as proporções do total,\r# também funciona com o padrão stat(count)\rx = stat(count)/sum(stat(count)),\ry = 1, # altura igual a 1\rfill = cut)) + # cores\rgeom_bar() +\rcoord_polar() + # coordenadas polares\r# opcional: remover aspectos do tema para um visual mais clean\rtheme_void()\r Como desafio, tentem adicionar elementos textuais das proporções no gráfico. O problema a ser resolvido é como posicionar o texto num sistema de coordenadas polares. Boa sorte!\nGráficos de pizza são polêmicos na análise de dados porque nossos olhos não captam bem diferenças entre formatos curvos e complexos, então a comparação entre as categorias fica prejudicada se houverem mais de 2 ou 3. Eu sempre dou preferência para barras. Há um tipo de gráfico de pizza melhorzinho chamado \u0026ldquo;donut plot\u0026rdquo;, em que o meio do círculo é oco, mas eu ainda prefiro as barras.\npurrr  Utilize uma das funções map_ para:  Nos exemplos abaixo, eu utilizo sempre str() no final para facilitar a visualização das listas, mas não é obrigatório utilizar esse comando.\n1. Calcular a média de cada coluna em `mtcars`.\r map(mtcars, mean) %\u0026gt;% str()\r ## List of 11\r## $ mpg : num 20.1\r## $ cyl : num 6.19\r## $ disp: num 231\r## $ hp : num 147\r## $ drat: num 3.6\r## $ wt : num 3.22\r## $ qsec: num 17.8\r## $ vs : num 0.438\r## $ am : num 0.406\r## $ gear: num 3.69\r## $ carb: num 2.81\r 2. Determinar o tipo de cada coluna em `flights`.\r flights %\u0026gt;% map(class) %\u0026gt;% str()\r ## List of 19\r## $ year : chr \u0026quot;integer\u0026quot;\r## $ month : chr \u0026quot;integer\u0026quot;\r## $ day : chr \u0026quot;integer\u0026quot;\r## $ dep_time : chr \u0026quot;integer\u0026quot;\r## $ sched_dep_time: chr \u0026quot;integer\u0026quot;\r## $ dep_delay : chr \u0026quot;numeric\u0026quot;\r## $ arr_time : chr \u0026quot;integer\u0026quot;\r## $ sched_arr_time: chr \u0026quot;integer\u0026quot;\r## $ arr_delay : chr \u0026quot;numeric\u0026quot;\r## $ carrier : chr \u0026quot;character\u0026quot;\r## $ flight : chr \u0026quot;integer\u0026quot;\r## $ tailnum : chr \u0026quot;character\u0026quot;\r## $ origin : chr \u0026quot;character\u0026quot;\r## $ dest : chr \u0026quot;character\u0026quot;\r## $ air_time : chr \u0026quot;numeric\u0026quot;\r## $ distance : chr \u0026quot;numeric\u0026quot;\r## $ hour : chr \u0026quot;numeric\u0026quot;\r## $ minute : chr \u0026quot;numeric\u0026quot;\r## $ time_hour : chr [1:2] \u0026quot;POSIXct\u0026quot; \u0026quot;POSIXt\u0026quot;\r 3. Computar o número de valores únicos em cada coluna de `iris`.\r flights %\u0026gt;% map(unique) %\u0026gt;% map(length) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r # Sugestão do Pedro Gomes\rflights %\u0026gt;% map(n_distinct) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r 4. Gere 10 distribuições aleatórias (`rnorm`) com médias -10, 0, 10 e 100.\r x \u0026lt;- rep(100, 40)\rmedias \u0026lt;- rep(c(-10, 0, 10, 100), each = 10)\rmap2(x, medias, ~rnorm(.x, mean = .y)) %\u0026gt;% str()\r ## List of 40\r## $ : num [1:100] -9.96 -9.53 -9.12 -9.64 -10.36 ...\r## $ : num [1:100] -11.71 -10.76 -9.41 -9.22 -10.53 ...\r## $ : num [1:100] -11.33 -9.51 -8.98 -10.91 -9.52 ...\r## $ : num [1:100] -11.4 -10.9 -10.7 -12.1 -9.8 ...\r## $ : num [1:100] -11.06 -10.66 -10.33 -9.13 -9.13 ...\r## $ : num [1:100] -10.22 -9.59 -9.81 -10.71 -10.24 ...\r## $ : num [1:100] -11 -9.14 -10.91 -9.38 -9.63 ...\r## $ : num [1:100] -9.83 -9.61 -11.23 -9.68 -10.47 ...\r## $ : num [1:100] -9.11 -10.03 -10.62 -9.65 -10.2 ...\r## $ : num [1:100] -9.06 -10.41 -10.84 -9.16 -9.41 ...\r## $ : num [1:100] -0.8378 0.1102 0.7519 -0.2477 0.0342 ...\r## $ : num [1:100] 0.607 -0.902 -2.185 -0.397 -1.019 ...\r## $ : num [1:100] -0.452 2.067 1.45 -1.184 0.893 ...\r## $ : num [1:100] -0.604 -0.783 1.767 -0.632 1.322 ...\r## $ : num [1:100] -2.515 0.43 0.694 1.239 1.091 ...\r## $ : num [1:100] -1.462 1.177 -0.376 0.037 0.387 ...\r## $ : num [1:100] -0.0803 -0.0421 2.4765 0.0509 -0.1479 ...\r## $ : num [1:100] 1.118 0.662 -1.439 -1.074 0.493 ...\r## $ : num [1:100] -0.3136 0.4455 -0.947 2.0658 -0.0188 ...\r## $ : num [1:100] 0.193 0.625 2.281 0.297 -0.629 ...\r## $ : num [1:100] 9.29 9.1 9.54 9.99 10.2 ...\r## $ : num [1:100] 7.96 7.32 10.7 9.13 10.3 ...\r## $ : num [1:100] 9.96 10.24 10.31 10.54 11.65 ...\r## $ : num [1:100] 10.88 10.41 8.19 10.37 10.28 ...\r## $ : num [1:100] 11.27 9.74 11.75 11.7 9.31 ...\r## $ : num [1:100] 9.62 11.35 10.78 10.79 9.7 ...\r## $ : num [1:100] 9.04 10.24 11.85 9.82 10.66 ...\r## $ : num [1:100] 10.48 6.97 8.97 9.69 11.03 ...\r## $ : num [1:100] 8.48 10.12 9.09 8.18 10.11 ...\r## $ : num [1:100] 9.97 9.27 10.19 10.93 11.07 ...\r## $ : num [1:100] 100 99.2 99.6 100.3 99.2 ...\r## $ : num [1:100] 99 99.9 100.7 98.7 99.7 ...\r## $ : num [1:100] 99.6 99.2 100.1 100 99.9 ...\r## $ : num [1:100] 100.5 100.4 100.2 98.4 98.9 ...\r## $ : num [1:100] 99.8 99.8 100 99.1 101.1 ...\r## $ : num [1:100] 100.7 100 100.1 98.6 100 ...\r## $ : num [1:100] 99 99.4 100.5 100.1 99.3 ...\r## $ : num [1:100] 99.2 98.6 99.2 100.9 97.4 ...\r## $ : num [1:100] 99.7 99.8 100.9 100.5 99.9 ...\r## $ : num [1:100] 99.5 100.9 98.5 99.7 100 ...\r Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?  # Flights por exemplo\rflights %\u0026gt;% # Lembrem-se que a pergunta pedia para criar um vetor!\rmap_lgl(is.factor)\r ## year month day dep_time sched_dep_time ## FALSE FALSE FALSE FALSE FALSE ## dep_delay arr_time sched_arr_time arr_delay carrier ## FALSE FALSE FALSE FALSE FALSE ## flight tailnum origin dest air_time ## FALSE FALSE FALSE FALSE FALSE ## distance hour minute time_hour ## FALSE FALSE FALSE FALSE\r  Usando as funções predicado keep e discard:\n Selecione todas as colunas caractere no banco flights.    flights %\u0026gt;% keep(is.character)\r ## # A tibble: 336,776 x 4\r## carrier tailnum origin dest ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 UA N14228 EWR IAH ## 2 UA N24211 LGA IAH ## 3 AA N619AA JFK MIA ## 4 B6 N804JB JFK BQN ## 5 DL N668DN LGA ATL ## 6 UA N39463 EWR ORD ## 7 B6 N516JB EWR FLL ## 8 EV N829AS LGA IAD ## 9 B6 N593JB JFK MCO ## 10 AA N3ALAA LGA ORD ## # ... with 336,766 more rows\r 2. Descarte os caracteres em `mpg`.\r mpg %\u0026gt;% discard(is.character)\r ## # A tibble: 234 x 5\r## displ year cyl cty hwy\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1.8 1999 4 18 29\r## 2 1.8 1999 4 21 29\r## 3 2 2008 4 20 31\r## 4 2 2008 4 21 30\r## 5 2.8 1999 6 16 26\r## 6 2.8 1999 6 18 26\r## 7 3.1 2008 6 18 27\r## 8 1.8 1999 4 18 26\r## 9 1.8 1999 4 16 25\r## 10 2 2008 4 20 28\r## # ... with 224 more rows\r 3. Selecione os fatores ordenados em `diamonds`.\r diamonds %\u0026gt;% keep(is.ordered)\r ## # A tibble: 53,940 x 3\r## cut color clarity\r## \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; ## 1 Ideal E SI2 ## 2 Premium E SI1 ## 3 Good E VS1 ## 4 Premium I VS2 ## 5 Good J SI2 ## 6 Very Good J VVS2 ## 7 Very Good I VVS1 ## 8 Very Good H SI1 ## 9 Fair E VS2 ## 10 Very Good H VS1 ## # ... with 53,930 more rows\r 4. Descarte as variáveis não-numéricas em `iris`\r iris %\u0026gt;% discard(negate(is.numeric))\r ## Sepal.Length Sepal.Width Petal.Length Petal.Width\r## 1 5.1 3.5 1.4 0.2\r## 2 4.9 3.0 1.4 0.2\r## 3 4.7 3.2 1.3 0.2\r## 4 4.6 3.1 1.5 0.2\r## 5 5.0 3.6 1.4 0.2\r## 6 5.4 3.9 1.7 0.4\r## 7 4.6 3.4 1.4 0.3\r## 8 5.0 3.4 1.5 0.2\r## 9 4.4 2.9 1.4 0.2\r## 10 4.9 3.1 1.5 0.1\r## 11 5.4 3.7 1.5 0.2\r## 12 4.8 3.4 1.6 0.2\r## 13 4.8 3.0 1.4 0.1\r## 14 4.3 3.0 1.1 0.1\r## 15 5.8 4.0 1.2 0.2\r## 16 5.7 4.4 1.5 0.4\r## 17 5.4 3.9 1.3 0.4\r## 18 5.1 3.5 1.4 0.3\r## 19 5.7 3.8 1.7 0.3\r## 20 5.1 3.8 1.5 0.3\r## 21 5.4 3.4 1.7 0.2\r## 22 5.1 3.7 1.5 0.4\r## 23 4.6 3.6 1.0 0.2\r## 24 5.1 3.3 1.7 0.5\r## 25 4.8 3.4 1.9 0.2\r## 26 5.0 3.0 1.6 0.2\r## 27 5.0 3.4 1.6 0.4\r## 28 5.2 3.5 1.5 0.2\r## 29 5.2 3.4 1.4 0.2\r## 30 4.7 3.2 1.6 0.2\r## 31 4.8 3.1 1.6 0.2\r## 32 5.4 3.4 1.5 0.4\r## 33 5.2 4.1 1.5 0.1\r## 34 5.5 4.2 1.4 0.2\r## 35 4.9 3.1 1.5 0.2\r## 36 5.0 3.2 1.2 0.2\r## 37 5.5 3.5 1.3 0.2\r## 38 4.9 3.6 1.4 0.1\r## 39 4.4 3.0 1.3 0.2\r## 40 5.1 3.4 1.5 0.2\r## 41 5.0 3.5 1.3 0.3\r## 42 4.5 2.3 1.3 0.3\r## 43 4.4 3.2 1.3 0.2\r## 44 5.0 3.5 1.6 0.6\r## 45 5.1 3.8 1.9 0.4\r## 46 4.8 3.0 1.4 0.3\r## 47 5.1 3.8 1.6 0.2\r## 48 4.6 3.2 1.4 0.2\r## 49 5.3 3.7 1.5 0.2\r## 50 5.0 3.3 1.4 0.2\r## 51 7.0 3.2 4.7 1.4\r## 52 6.4 3.2 4.5 1.5\r## 53 6.9 3.1 4.9 1.5\r## 54 5.5 2.3 4.0 1.3\r## 55 6.5 2.8 4.6 1.5\r## 56 5.7 2.8 4.5 1.3\r## 57 6.3 3.3 4.7 1.6\r## 58 4.9 2.4 3.3 1.0\r## 59 6.6 2.9 4.6 1.3\r## 60 5.2 2.7 3.9 1.4\r## 61 5.0 2.0 3.5 1.0\r## 62 5.9 3.0 4.2 1.5\r## 63 6.0 2.2 4.0 1.0\r## 64 6.1 2.9 4.7 1.4\r## 65 5.6 2.9 3.6 1.3\r## 66 6.7 3.1 4.4 1.4\r## 67 5.6 3.0 4.5 1.5\r## 68 5.8 2.7 4.1 1.0\r## 69 6.2 2.2 4.5 1.5\r## 70 5.6 2.5 3.9 1.1\r## 71 5.9 3.2 4.8 1.8\r## 72 6.1 2.8 4.0 1.3\r## 73 6.3 2.5 4.9 1.5\r## 74 6.1 2.8 4.7 1.2\r## 75 6.4 2.9 4.3 1.3\r## 76 6.6 3.0 4.4 1.4\r## 77 6.8 2.8 4.8 1.4\r## 78 6.7 3.0 5.0 1.7\r## 79 6.0 2.9 4.5 1.5\r## 80 5.7 2.6 3.5 1.0\r## 81 5.5 2.4 3.8 1.1\r## 82 5.5 2.4 3.7 1.0\r## 83 5.8 2.7 3.9 1.2\r## 84 6.0 2.7 5.1 1.6\r## 85 5.4 3.0 4.5 1.5\r## 86 6.0 3.4 4.5 1.6\r## 87 6.7 3.1 4.7 1.5\r## 88 6.3 2.3 4.4 1.3\r## 89 5.6 3.0 4.1 1.3\r## 90 5.5 2.5 4.0 1.3\r## 91 5.5 2.6 4.4 1.2\r## 92 6.1 3.0 4.6 1.4\r## 93 5.8 2.6 4.0 1.2\r## 94 5.0 2.3 3.3 1.0\r## 95 5.6 2.7 4.2 1.3\r## 96 5.7 3.0 4.2 1.2\r## 97 5.7 2.9 4.2 1.3\r## 98 6.2 2.9 4.3 1.3\r## 99 5.1 2.5 3.0 1.1\r## 100 5.7 2.8 4.1 1.3\r## 101 6.3 3.3 6.0 2.5\r## 102 5.8 2.7 5.1 1.9\r## 103 7.1 3.0 5.9 2.1\r## 104 6.3 2.9 5.6 1.8\r## 105 6.5 3.0 5.8 2.2\r## 106 7.6 3.0 6.6 2.1\r## 107 4.9 2.5 4.5 1.7\r## 108 7.3 2.9 6.3 1.8\r## 109 6.7 2.5 5.8 1.8\r## 110 7.2 3.6 6.1 2.5\r## 111 6.5 3.2 5.1 2.0\r## 112 6.4 2.7 5.3 1.9\r## 113 6.8 3.0 5.5 2.1\r## 114 5.7 2.5 5.0 2.0\r## 115 5.8 2.8 5.1 2.4\r## 116 6.4 3.2 5.3 2.3\r## 117 6.5 3.0 5.5 1.8\r## 118 7.7 3.8 6.7 2.2\r## 119 7.7 2.6 6.9 2.3\r## 120 6.0 2.2 5.0 1.5\r## 121 6.9 3.2 5.7 2.3\r## 122 5.6 2.8 4.9 2.0\r## 123 7.7 2.8 6.7 2.0\r## 124 6.3 2.7 4.9 1.8\r## 125 6.7 3.3 5.7 2.1\r## 126 7.2 3.2 6.0 1.8\r## 127 6.2 2.8 4.8 1.8\r## 128 6.1 3.0 4.9 1.8\r## 129 6.4 2.8 5.6 2.1\r## 130 7.2 3.0 5.8 1.6\r## 131 7.4 2.8 6.1 1.9\r## 132 7.9 3.8 6.4 2.0\r## 133 6.4 2.8 5.6 2.2\r## 134 6.3 2.8 5.1 1.5\r## 135 6.1 2.6 5.6 1.4\r## 136 7.7 3.0 6.1 2.3\r## 137 6.3 3.4 5.6 2.4\r## 138 6.4 3.1 5.5 1.8\r## 139 6.0 3.0 4.8 1.8\r## 140 6.9 3.1 5.4 2.1\r## 141 6.7 3.1 5.6 2.4\r## 142 6.9 3.1 5.1 2.3\r## 143 5.8 2.7 5.1 1.9\r## 144 6.8 3.2 5.9 2.3\r## 145 6.7 3.3 5.7 2.5\r## 146 6.7 3.0 5.2 2.3\r## 147 6.3 2.5 5.0 1.9\r## 148 6.5 3.0 5.2 2.0\r## 149 6.2 3.4 5.4 2.3\r## 150 5.9 3.0 5.1 1.8\r Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.  # Vamos usar um diretório temporário que vamos preencher com vários tibbles\rpasta \u0026lt;- tempdir()\r# Criamos 100 tibbles e guardamos em 100 arquivos csv.\rx \u0026lt;- rep(10, 100)\rarqs \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:100)\rmap(x, ~tibble(var1 = rnorm(.x), var2 = rnorm(.x))) %\u0026gt;% map2(arqs, ~write_csv(.x, file.path(pasta, .y))) %\u0026gt;% str()\r # Nossos arquivos estão salvos no diretório temporário:\rdir(pasta)\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo10.csv\u0026quot; \u0026quot;arquivo100.csv\u0026quot; \u0026quot;arquivo11.csv\u0026quot; ## [5] \u0026quot;arquivo12.csv\u0026quot; \u0026quot;arquivo13.csv\u0026quot; \u0026quot;arquivo14.csv\u0026quot; \u0026quot;arquivo15.csv\u0026quot; ## [9] \u0026quot;arquivo16.csv\u0026quot; \u0026quot;arquivo17.csv\u0026quot; \u0026quot;arquivo18.csv\u0026quot; \u0026quot;arquivo19.csv\u0026quot; ## [13] \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo20.csv\u0026quot; \u0026quot;arquivo21.csv\u0026quot; \u0026quot;arquivo22.csv\u0026quot; ## [17] \u0026quot;arquivo23.csv\u0026quot; \u0026quot;arquivo24.csv\u0026quot; \u0026quot;arquivo25.csv\u0026quot; \u0026quot;arquivo26.csv\u0026quot; ## [21] \u0026quot;arquivo27.csv\u0026quot; \u0026quot;arquivo28.csv\u0026quot; \u0026quot;arquivo29.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; ## [25] \u0026quot;arquivo30.csv\u0026quot; \u0026quot;arquivo31.csv\u0026quot; \u0026quot;arquivo32.csv\u0026quot; \u0026quot;arquivo33.csv\u0026quot; ## [29] \u0026quot;arquivo34.csv\u0026quot; \u0026quot;arquivo35.csv\u0026quot; \u0026quot;arquivo36.csv\u0026quot; \u0026quot;arquivo37.csv\u0026quot; ## [33] \u0026quot;arquivo38.csv\u0026quot; \u0026quot;arquivo39.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot; \u0026quot;arquivo40.csv\u0026quot; ## [37] \u0026quot;arquivo41.csv\u0026quot; \u0026quot;arquivo42.csv\u0026quot; \u0026quot;arquivo43.csv\u0026quot; \u0026quot;arquivo44.csv\u0026quot; ## [41] \u0026quot;arquivo45.csv\u0026quot; \u0026quot;arquivo46.csv\u0026quot; \u0026quot;arquivo47.csv\u0026quot; \u0026quot;arquivo48.csv\u0026quot; ## [45] \u0026quot;arquivo49.csv\u0026quot; \u0026quot;arquivo5.csv\u0026quot; \u0026quot;arquivo50.csv\u0026quot; \u0026quot;arquivo51.csv\u0026quot; ## [49] \u0026quot;arquivo52.csv\u0026quot; \u0026quot;arquivo53.csv\u0026quot; \u0026quot;arquivo54.csv\u0026quot; \u0026quot;arquivo55.csv\u0026quot; ## [53] \u0026quot;arquivo56.csv\u0026quot; \u0026quot;arquivo57.csv\u0026quot; \u0026quot;arquivo58.csv\u0026quot; \u0026quot;arquivo59.csv\u0026quot; ## [57] \u0026quot;arquivo6.csv\u0026quot; \u0026quot;arquivo60.csv\u0026quot; \u0026quot;arquivo61.csv\u0026quot; \u0026quot;arquivo62.csv\u0026quot; ## [61] \u0026quot;arquivo63.csv\u0026quot; \u0026quot;arquivo64.csv\u0026quot; \u0026quot;arquivo65.csv\u0026quot; \u0026quot;arquivo66.csv\u0026quot; ## [65] \u0026quot;arquivo67.csv\u0026quot; \u0026quot;arquivo68.csv\u0026quot; \u0026quot;arquivo69.csv\u0026quot; \u0026quot;arquivo7.csv\u0026quot; ## [69] \u0026quot;arquivo70.csv\u0026quot; \u0026quot;arquivo71.csv\u0026quot; \u0026quot;arquivo72.csv\u0026quot; \u0026quot;arquivo73.csv\u0026quot; ## [73] \u0026quot;arquivo74.csv\u0026quot; \u0026quot;arquivo75.csv\u0026quot; \u0026quot;arquivo76.csv\u0026quot; \u0026quot;arquivo77.csv\u0026quot; ## [77] \u0026quot;arquivo78.csv\u0026quot; \u0026quot;arquivo79.csv\u0026quot; \u0026quot;arquivo8.csv\u0026quot; \u0026quot;arquivo80.csv\u0026quot; ## [81] \u0026quot;arquivo81.csv\u0026quot; \u0026quot;arquivo82.csv\u0026quot; \u0026quot;arquivo83.csv\u0026quot; \u0026quot;arquivo84.csv\u0026quot; ## [85] \u0026quot;arquivo85.csv\u0026quot; \u0026quot;arquivo86.csv\u0026quot; \u0026quot;arquivo87.csv\u0026quot; \u0026quot;arquivo88.csv\u0026quot; ## [89] \u0026quot;arquivo89.csv\u0026quot; \u0026quot;arquivo9.csv\u0026quot; \u0026quot;arquivo90.csv\u0026quot; \u0026quot;arquivo91.csv\u0026quot; ## [93] \u0026quot;arquivo92.csv\u0026quot; \u0026quot;arquivo93.csv\u0026quot; \u0026quot;arquivo94.csv\u0026quot; \u0026quot;arquivo95.csv\u0026quot; ## [97] \u0026quot;arquivo96.csv\u0026quot; \u0026quot;arquivo97.csv\u0026quot; \u0026quot;arquivo98.csv\u0026quot; \u0026quot;arquivo99.csv\u0026quot; ## [101] \u0026quot;filecf810bd36a5\u0026quot; \u0026quot;filecf81149221d\u0026quot; \u0026quot;filecf81164e23\u0026quot; \u0026quot;filecf8161f65f7\u0026quot;\r## [105] \u0026quot;filecf8171030fd\u0026quot; \u0026quot;filecf819e43f49\u0026quot; \u0026quot;filecf81ad26a9f\u0026quot; \u0026quot;filecf81bed9f1\u0026quot; ## [109] \u0026quot;filecf81e7a7e68\u0026quot; \u0026quot;filecf81ef03542\u0026quot; \u0026quot;filecf81fa64a3e\u0026quot; \u0026quot;filecf8239d75ab\u0026quot;\r## [113] \u0026quot;filecf8261936\u0026quot; \u0026quot;filecf826d55378\u0026quot; \u0026quot;filecf8291061a0\u0026quot; \u0026quot;filecf82b985019\u0026quot;\r## [117] \u0026quot;filecf82c00737b\u0026quot; \u0026quot;filecf8339f5\u0026quot; \u0026quot;filecf8341e67d6\u0026quot; \u0026quot;filecf8344158ac\u0026quot;\r## [121] \u0026quot;filecf837a47cc7\u0026quot; \u0026quot;filecf837f15510\u0026quot; \u0026quot;filecf8387a3d29\u0026quot; \u0026quot;filecf83a71232b\u0026quot;\r## [125] \u0026quot;filecf83ac3253a\u0026quot; \u0026quot;filecf83af94598\u0026quot; \u0026quot;filecf83f794f64\u0026quot; \u0026quot;filecf8402156c1\u0026quot;\r## [129] \u0026quot;filecf840c15566\u0026quot; \u0026quot;filecf84163761c\u0026quot; \u0026quot;filecf841d3b53\u0026quot; \u0026quot;filecf844d5642\u0026quot; ## [133] \u0026quot;filecf845e73bac\u0026quot; \u0026quot;filecf8462819d6\u0026quot; \u0026quot;filecf84b8b3144\u0026quot; \u0026quot;filecf84ddc73a0\u0026quot;\r## [137] \u0026quot;filecf84fe515d4\u0026quot; \u0026quot;filecf8500a5a10\u0026quot; \u0026quot;filecf8512766ea\u0026quot; \u0026quot;filecf852fe119b\u0026quot;\r## [141] \u0026quot;filecf8550a39d\u0026quot; \u0026quot;filecf85b14fec\u0026quot; \u0026quot;filecf85e053c83\u0026quot; \u0026quot;filecf85e6a12f4\u0026quot;\r## [145] \u0026quot;filecf8639c6053\u0026quot; \u0026quot;filecf863dc5f3b\u0026quot; \u0026quot;filecf8646e477f\u0026quot; \u0026quot;filecf865645c5d\u0026quot;\r## [149] \u0026quot;filecf868634c0d\u0026quot; \u0026quot;filecf869137c8a\u0026quot; \u0026quot;filecf86a7852d4\u0026quot; \u0026quot;filecf86b5b250\u0026quot; ## [153] \u0026quot;filecf86b9e3bb7\u0026quot; \u0026quot;filecf86d216ac\u0026quot; \u0026quot;filecf86e894a16\u0026quot; \u0026quot;filecf86ea916d3\u0026quot;\r## [157] \u0026quot;filecf86f22266\u0026quot; \u0026quot;filecf86f975377\u0026quot; \u0026quot;filecf8757a72be\u0026quot; \u0026quot;filecf876956e82\u0026quot;\r## [161] \u0026quot;filecf876967b1\u0026quot; \u0026quot;filecf8787a1370\u0026quot; \u0026quot;filecf879037c39\u0026quot; \u0026quot;filecf87964711\u0026quot; ## [165] \u0026quot;filecf87afe7046\u0026quot; \u0026quot;filecf88456ae0\u0026quot; \u0026quot;filecf898344ab\u0026quot;\r # Agora vamos ler todos de volta para uma tibble só.\rarqs \u0026lt;- dir(pasta, pattern = \u0026quot;.csv\u0026quot;, full.names = T)\r # Juntando linhas\rdf \u0026lt;- map_dfr(arqs, read_csv)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # Juntando colunas\rdf \u0026lt;- map_dfc(arqs, read_csv)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r # Usando reduce\r# linhas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_rows)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # colunas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_cols)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r# Estou usando funções do pacote broom, mas você não era obrigado a apresentar\r# os resultados bonitinho. O objetivo era treinar esse tipo de workflow.\rmodelos_saida \u0026lt;- tibble(\respecificacao = modelos,\rajuste = map(especificacao, lm, data = mtcars),\rcoefs = map(ajuste, broom::tidy),\rstats = map(ajuste, broom::glance),\raums = map(ajuste, broom::augment)\r)\rmodelos_saida %\u0026gt;% select(especificacao, coefs) %\u0026gt;% unnest(coefs) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)  ## # A tibble: 10 x 6\r## especificacao term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt wt -5.34 0.559 -9.56 1.29e-10\r## 2 mpg ~ wt + cyl wt -3.19 0.757 -4.22 2.22e- 4\r## 3 mpg ~ wt + cyl cyl -1.51 0.415 -3.64 1.06e- 3\r## 4 mpg ~ wt + cyl + drat wt -3.19 0.829 -3.85 6.24e- 4\r## 5 mpg ~ wt + cyl + drat cyl -1.51 0.446 -3.38 2.14e- 3\r## 6 mpg ~ wt + cyl + drat drat -0.0162 1.32 -0.0122 9.90e- 1\r## 7 mpg ~ wt + cyl + drat + am wt -3.13 0.932 -3.36 2.32e- 3\r## 8 mpg ~ wt + cyl + drat + am cyl -1.53 0.465 -3.28 2.88e- 3\r## 9 mpg ~ wt + cyl + drat + am drat -0.130 1.53 -0.0851 9.33e- 1\r## 10 mpg ~ wt + cyl + drat + am am 0.237 1.51 0.157 8.76e- 1\r modelos_saida %\u0026gt;% select(especificacao, stats) %\u0026gt;% unnest(stats)\r ## # A tibble: 4 x 13\r## especificacao r.squared adj.r.squared sigma statistic p.value df logLik\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt 0.753 0.745 3.05 91.4 1.29e-10 1 -80.0\r## 2 mpg ~ wt + cyl 0.830 0.819 2.57 70.9 6.81e-12 2 -74.0\r## 3 mpg ~ wt + cyl ~ 0.830 0.812 2.61 45.6 6.57e-11 3 -74.0\r## 4 mpg ~ wt + cyl ~ 0.830 0.805 2.66 33.0 4.84e-10 4 -74.0\r## # ... with 5 more variables: AIC \u0026lt;dbl\u0026gt;, BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;,\r## # df.residual \u0026lt;int\u0026gt;, nobs \u0026lt;int\u0026gt;\r modelos_saida %\u0026gt;% select(especificacao, aums) %\u0026gt;% filter(especificacao == \u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;) %\u0026gt;% unnest(aums)\r ## # A tibble: 32 x 13\r## especificacao .rownames mpg wt cyl drat am .fitted .resid .hat\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt + cyl~ Mazda RX4 21 2.62 6 3.9 1 22.3 -1.35 0.0899\r## 2 mpg ~ wt + cyl~ Mazda RX~ 21 2.88 6 3.9 1 21.6 -0.550 0.0924\r## 3 mpg ~ wt + cyl~ Datsun 7~ 22.8 2.32 4 3.85 1 26.3 -3.55 0.137 ## 4 mpg ~ wt + cyl~ Hornet 4~ 21.4 3.22 6 3.08 0 20.4 1.05 0.113 ## 5 mpg ~ wt + cyl~ Hornet S~ 18.7 3.44 8 3.15 0 16.6 2.11 0.122 ## 6 mpg ~ wt + cyl~ Valiant 18.1 3.46 6 2.76 0 19.6 -1.53 0.207 ## 7 mpg ~ wt + cyl~ Duster 3~ 14.3 3.57 8 3.21 0 16.2 -1.87 0.103 ## 8 mpg ~ wt + cyl~ Merc 240D 24.4 3.19 4 3.69 0 23.4 0.996 0.189 ## 9 mpg ~ wt + cyl~ Merc 230 22.8 3.15 4 3.92 0 23.5 -0.700 0.207 ## 10 mpg ~ wt + cyl~ Merc 280 19.2 3.44 6 3.92 0 19.5 -0.340 0.149 ## # ... with 22 more rows, and 3 more variables: .sigma \u0026lt;dbl\u0026gt;, .cooksd \u0026lt;dbl\u0026gt;,\r## # .std.resid \u0026lt;dbl\u0026gt;\r ","date":1621900800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621900800,"objectID":"c1c74f268683837301969e7167daf1ed","permalink":"https://laddem.github.io/courses/tidyverse/solucoes/","publishdate":"2021-05-25T00:00:00Z","relpermalink":"/courses/tidyverse/solucoes/","section":"courses","summary":"Soluções dos exercícios","tags":null,"title":"Soluções","type":"book"},{"authors":["LADDEM"],"categories":null,"content":"\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://laddem.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot;\rif porridge == \u0026quot;blueberry\u0026quot;:\rprint(\u0026quot;Eating...\u0026quot;)\r  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}}\r{{% fragment %}} **Two** {{% /fragment %}}\r{{% fragment %}} Three {{% /fragment %}}\r Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}}\r- Only the speaker can read these notes\r- Press `S` key to view\r{{% /speaker_note %}}\r Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}}\r{{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}\r  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1,\r.reveal section h2,\r.reveal section h3 {\rcolor: navy;\r}\r  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://laddem.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://laddem.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://laddem.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://laddem.github.io/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]
=======
<<<<<<< Updated upstream
[{"authors":null,"categories":null,"content":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://laddem.github.io/author/laddem/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/laddem/","section":"authors","summary":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.","tags":null,"title":"LADDEM","type":"authors"},{"authors":null,"categories":null,"content":"\r\r Table of Contents\r O que você vai aprender O curso Programação Instrutores Links úteis  \r\rO que você vai aprender  A filosofia de design por trás de um dos pacotes mais populares no R Importação, Manipulação e Visualização de dados na prática tidyr, dplyr, ggplot2 e vários outros pacotes para simplificar sua rotina de análise de dados  O curso Uma semana, com aulas à noite, no formato workshop, com muitos exercícios para praticar e pegar o jeito.\nProgramação \rreadr, tibble e tidyr\rUm modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\n\r\rstringr, forcats e dplyr\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\n\r\rggplot2\rO pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.\n\r\rpurrr\rO autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.\n\r\rSoluções\rSoluções dos exercícios\n\r\rInstrutores Vinícius de Souza Maia\nNatália Martins Arruda\nLinks úteis Ciência de dados em R\nR for Data Science\n","date":1621728000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1621728000,"objectID":"02eadce3bea228c4a3968729e322add5","permalink":"https://laddem.github.io/courses/tidyverse/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/","section":"courses","summary":"Aprenda a utilizar o tidyverse nas suas análises de dados.","tags":null,"title":"📊 Aprenda a utilizar o tidyverse","type":"book"},{"authors":null,"categories":null,"content":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\nEla acaba sendo um ponto de partida interessante porque contextualiza a maioria dos pacotes que vamos utilizar. O readr é uma maneira de facilitar e tornar mais rápida a importação de dados em formatos comuns, como o texto delimitado por separadores e o formato colunado com larguras-fixas utilizado pelo IBGE.\nA tibble é uma proposta de modernização para o data.frame, aproveitando a estrutura flexível e poderosa, mas mudando certas convenções, como a conversão de strings para fatores, permitindo a criação de colunas de listas, utilização de nomes mais complexos para colunas, etc.\nO tidyr é uma forma de reformatar (reshape) bancos de dados que vêm em formatos que dificultam seu processamento, permitindo que o analista facilmente reconfigure a informação para o formato mais adequado. Ele é o primeiro pacote que veremos sobre a parte de \u0026ldquo;cozinha\u0026rdquo; dos dados, no qual é preciso processar o dado bruto para torná-lo passível de análise.\nO mesmo pode ser dito para os outros pacotes que veremos nos próximos dias. Cada um deles foi pensado para resolver um problema ou facilitar uma rotina de trabalho relacionada com um dos passos descritos acima.\nProgramação literária Vários dos conceitos que guiam o design do tidyverse são orientados por uma certa filosofia. Esta filosofia dita que a principal preocupação por trás de um programa não é que ele funcione. Eventualmente e com um pouco de persistência, é quase sempre possível chegar a uma solução técnica adequada. A principal questão é que o programa é uma ferramenta de comunicação com outras pessoas que o lerão, seja seus colegas, colaboradores, alunos ou você mesmo, daqui a 2 anos, quando lembrar que você já escreveu um programa para aquela tarefa. Trago aqui alguns trechos de Literate Programming, de Donald Knuth (1984), traduzidos livremente por este que vos fala:\n Creio que chegou a hora de melhorar significativamente a documentação dos programas, e que podemos atingir este objetivo tratando programas como obras literárias. Por isso o título: \u0026ldquo;Programação Literária\u0026rdquo;. Abandonemos os velhos hábitos de construir programas: ao invés de imaginar que nossa tarefa principal é instruir um computador sobre o que deve ser feito, concentremo-nos em explicar aos seres humanos o que queremos que o computador faça. O praticante da programação literária pode ser visto como um ensaísta, cuja principal preocupação é com a clareza da exposição e a excelência no estilo. Tal autor, com um dicionário na mão, escolhe os nomes das variáveis com cuidado e explica claramente seu significado. Ele ou ela esmera por um programa que é compreensível porque seus conceitos foram introduzidos na melhor ordem possível para o entendimento humano, utilizando uma mistura de métodos formais e informais que se complementam.\n Assim, várias das escolhas feitas na construção de tidyverse procuram reforçar essa característica de interpretabilidade dos programas, como a ordem lógica das operações com o pipe (%\u0026gt;%), funções com nomes mais longos e semânticos, a utilização de uma função específica para cada tarefa, ao invés da adaptação de funções genéricas para uma grande variedade de tarefas. O propósito de um código escrito como tidyverse é que, no limite, a própria síntaxe do código funcione como parte da documentação do programa.\nO mistério do pipe: %\u0026gt;% Usuários de longa data do R já podem ter encontrado no mato esse animal estranho e podem ter ficado confusos com seu significado. O pipe é de origem humilde e nasceu nos sistemas Unix há muitas décadas atrás. Seu objetivo é muito simples: e se você tiver uma sequência de computações em que cada uma recebe o resultado daquela feita anteriormente? Claro que você poderia fazer:\nx \u0026lt;- 1:10\ry \u0026lt;- diff(x)\rmean(y)\r ## [1] 1\r Mas não seria interessante pular os objetos intermediários e ir direto ao ponto? O pipe vem do pacote magrittr, mas ele vêm carregado em quase todos os pacotes do tidyverse. Vamos carregar logo o tibble.\n# Para ter acesso ao pipe, basta carregar um pacote do tidyverse, como tibble, dplyr, tidyr, etc.\r# Vamos carregar o tibble agora\rlibrary(tibble)\rx %\u0026gt;% diff() %\u0026gt;% mean()\r ## [1] 1\r Vejamos um exemplo mais real, quantos artistas existem no dataset billboard? Podemos usar unique e length para descobrir.\nx \u0026lt;- unique(tidyr::billboard$artist)\rlength(x)\r ## [1] 228\r Mas com %\u0026gt;% fica bem melhor:\ntidyr::billboard %\u0026gt;% .$artist %\u0026gt;% unique() %\u0026gt;% length()\r ## [1] 228\r Ok, mas como ele funciona? É simples, o pipe carrega o objeto a sua esquerda num ponto . invisível que é automaticamente passado como o primeiro argumento da função à direita.\nx \u0026lt;- 1:10\rmean(x)\r ## [1] 5.5\r x %\u0026gt;% mean()\r ## [1] 5.5\r OK, mas e se meu argumento não for o primeiro, ainda posso usar pipe? Pode! É só usar explicitamente um ponto no lugar onde você quer aproveitar o efeito:\niris %\u0026gt;% boxplot(Sepal.Length ~ Species, data = .)\r O ponto . depois de data indica indica que ali deve ser colocado o iris. O pipe é uma peça chave de muitas funções do tidyverse, não porque ele seja obrigatório, mas sim porque ele permite expressar sequências de operações numa ordem mais lógica, do tipo: \u0026ldquo;Primeiro faça a, então b, então c, \u0026hellip; \u0026ldquo;, ao contrário da forma como isto é geralmente feito usando parênteses para precedência.\n# Compare\rmean(diff(1:10))\r ## [1] 1\r 1:10 %\u0026gt;% diff %\u0026gt;% mean\r ## [1] 1\r E assim fica desmistificado o mistério do pipe! Um último pulo do gato: pelo amor de deus ninguém digita Shift + %, \u0026gt;, Shift + %, basta usar o atalho: Ctrl + Shift + M que ele põe um pipe separado por espaços %\u0026gt;%.\nreadr Usuários do R provavelmente vão estar familiarizados com os nossos leitores de arquivos mais comuns: read.table e read.csv. Talvez muitos de vocês já até memorizaram alguns dos argumentos mais comuns. Não é o caso aqui de revisitar esta função, mas o readr tem muitos paralelos com elas, porque é pensado como uma nova versão da mesma coisa.\n# Comecemos carregando o readr\rlibrary(readr)\r Debaixo do capô O readr, como as funções de leitura do base é uma coleção de parsers, que transformam texto em objetos R com o tipo desejado.\nparse_number(c(\u0026quot;1\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;38\u0026quot;))\r ## [1] 1 20 38\r parse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;ma\u0026lt;e7\u0026gt;\u0026lt;e3\u0026gt;\u0026quot; \u0026quot;p\u0026lt;ea\u0026gt;ra\u0026quot;\r # Note os acentos e caracteres especiais\rparse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;), locale = locale(encoding = \u0026quot;Windows-1252\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;maçã\u0026quot; \u0026quot;pêra\u0026quot;\r parse_logical(c(\u0026quot;true\u0026quot;, \u0026quot;false\u0026quot;, \u0026quot;true\u0026quot;))\r ## [1] TRUE FALSE TRUE\r Em geral, a gente não precisa descer tanto o nível, a gente vai trabalhar mesmo é com os leitores de dados \u0026ldquo;retangulares\u0026rdquo;. Como os do base, eles são read_csv, read_table, etc. Vamos trabalhar com bancos de dados que já vêm no pacote, para facilitar o processo.\n# Lista os datasets que vem no pacote\rreadr_example()\r ## [1] \u0026quot;challenge.csv\u0026quot; \u0026quot;epa78.txt\u0026quot; \u0026quot;example.log\u0026quot; ## [4] \u0026quot;fwf-sample.txt\u0026quot; \u0026quot;massey-rating.txt\u0026quot; \u0026quot;mtcars.csv\u0026quot; ## [7] \u0026quot;mtcars.csv.bz2\u0026quot; \u0026quot;mtcars.csv.zip\u0026quot;\r Uma coisa que gosto de fazer é olhar como o arquivo está organizado antes de tentar abrí-lo. Muitos de vocês podem fazer isso com readLines. Ela ganhou sua versão no pacote com read_lines.\n# Vamos tentar abrir massey-rating.txt\rread_lines(readr_example(\u0026quot;massey-rating.txt\u0026quot;), n_max = 10)\r ## [1] \u0026quot;UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf\u0026quot; ## [2] \u0026quot; 1 1 1 1 1 1 1 1 1 1 1 Ohio St B10 \u0026quot;\r## [3] \u0026quot; 2 2 2 2 2 2 2 2 4 2 2 Oregon P12 \u0026quot;\r## [4] \u0026quot; 3 4 3 4 3 4 3 4 2 3 3 Alabama SEC \u0026quot;\r## [5] \u0026quot; 4 3 4 3 4 3 5 3 3 4 4 TCU B12 \u0026quot;\r## [6] \u0026quot; 6 6 6 5 5 7 6 5 6 11 5 Michigan St B10 \u0026quot;\r## [7] \u0026quot; 7 7 7 6 7 6 11 8 7 8 6 Georgia SEC \u0026quot;\r## [8] \u0026quot; 5 5 5 7 6 8 4 6 5 5 7 Florida St ACC \u0026quot;\r## [9] \u0026quot; 8 8 9 9 10 5 7 7 10 7 8 Baylor B12 \u0026quot;\r## [10] \u0026quot; 9 11 8 13 11 11 12 9 14 9 9 Georgia Tech ACC \u0026quot;\r # Identificando o separador, escolho a função adequada\rread_table(readr_example(\u0026quot;massey-rating.txt\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## UCC = col_double(),\r## PAY = col_double(),\r## LAZ = col_double(),\r## KPK = col_double(),\r## RT = col_double(),\r## COF = col_double(),\r## BIH = col_double(),\r## DII = col_double(),\r## ENG = col_double(),\r## ACU = col_double(),\r## Rank = col_double(),\r## Team = col_character(),\r## Conf = col_character()\r## )\r ## # A tibble: 10 x 13\r## UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf ## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 1 1 1 1 1 1 1 1 1 1 Ohio~ B10 ## 2 2 2 2 2 2 2 2 2 4 2 2 Oreg~ P12 ## 3 3 4 3 4 3 4 3 4 2 3 3 Alab~ SEC ## 4 4 3 4 3 4 3 5 3 3 4 4 TCU B12 ## 5 6 6 6 5 5 7 6 5 6 11 5 Mich~ B10 ## 6 7 7 7 6 7 6 11 8 7 8 6 Geor~ SEC ## 7 5 5 5 7 6 8 4 6 5 5 7 Flor~ ACC ## 8 8 8 9 9 10 5 7 7 10 7 8 Bayl~ B12 ## 9 9 11 8 13 11 11 12 9 14 9 9 Geor~ ACC ## 10 13 10 13 11 8 9 10 11 9 10 10 Miss~ SEC\r Como identifiquei que as colunas estavam separadas por espaços, utilizei read_table cujo delimitador é o espaço \u0026quot; \u0026quot;.\nA segunda feature mais interessante do readr, é uma interface para selecionar os tipos de colunas que serão importadas. Vejamos o seguinte exemplo.\n# Vamos abrir mtcars.csv\rread_lines(readr_example(\u0026quot;mtcars.csv\u0026quot;), n_max = 10)\r ## [1] \u0026quot;\\\u0026quot;mpg\\\u0026quot;,\\\u0026quot;cyl\\\u0026quot;,\\\u0026quot;disp\\\u0026quot;,\\\u0026quot;hp\\\u0026quot;,\\\u0026quot;drat\\\u0026quot;,\\\u0026quot;wt\\\u0026quot;,\\\u0026quot;qsec\\\u0026quot;,\\\u0026quot;vs\\\u0026quot;,\\\u0026quot;am\\\u0026quot;,\\\u0026quot;gear\\\u0026quot;,\\\u0026quot;carb\\\u0026quot;\u0026quot;\r## [2] \u0026quot;21,6,160,110,3.9,2.62,16.46,0,1,4,4\u0026quot; ## [3] \u0026quot;21,6,160,110,3.9,2.875,17.02,0,1,4,4\u0026quot; ## [4] \u0026quot;22.8,4,108,93,3.85,2.32,18.61,1,1,4,1\u0026quot; ## [5] \u0026quot;21.4,6,258,110,3.08,3.215,19.44,1,0,3,1\u0026quot; ## [6] \u0026quot;18.7,8,360,175,3.15,3.44,17.02,0,0,3,2\u0026quot; ## [7] \u0026quot;18.1,6,225,105,2.76,3.46,20.22,1,0,3,1\u0026quot; ## [8] \u0026quot;14.3,8,360,245,3.21,3.57,15.84,0,0,3,4\u0026quot; ## [9] \u0026quot;24.4,4,146.7,62,3.69,3.19,20,1,0,4,2\u0026quot; ## [10] \u0026quot;22.8,4,140.8,95,3.92,3.15,22.9,1,0,4,2\u0026quot;\r # Identificamos o separador de colunas, selecionamos a função adequada\rread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r O console nos mostra que a leitura do banco foi completada, mas também mostra Column Specification. Isto indica qual o tipo de dado que foi identificado automaticamente numa análise feita pela função guess_parser. Em diversos casos, nós podemos querer identificar manualmente as colunas. Vejamos um exemplo:\n# Vamos identificar as colunas com spec\rspec_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r # Copia e cola, modifica as colunas que queremos alterar\rspec_cols \u0026lt;- cols(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\rdisp = col_double(),\rhp = col_double(),\rdrat = col_double(),\rwt = col_double(),\rqsec = col_double(),\rvs = col_double(),\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols)\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r # Para importar apenas colunas selecionadas, utilize 'cols_only()'\rspec_cols2 \u0026lt;- cols_only(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf2 \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols2)\rdf2\r ## # A tibble: 32 x 5\r## mpg cyl am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 1 4 4\r## 2 21 6 1 4 4\r## 3 22.8 4 1 4 1\r## 4 21.4 6 0 3 1\r## 5 18.7 8 0 3 2\r## 6 18.1 6 0 3 1\r## 7 14.3 8 0 3 4\r## 8 24.4 4 0 4 2\r## 9 22.8 4 0 4 2\r## 10 19.2 6 0 4 4\r## # ... with 22 more rows\r # Para indicar os tipos de colunas de um jeito mais sucinto, utilize uma string:\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = \u0026quot;dfddddddfdd\u0026quot;)\r# Só cuidado pra não perder a conta dos ds!\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nmeu_locale \u0026lt;- locale(encoding = \u0026quot;UTF-8\u0026quot;, decimal_mark = \u0026quot;,\u0026quot;, grouping_mark = \u0026quot;.\u0026quot;)\r Aí é só passar isso pra uma das funções do pacote sob o argumento locale\nread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), locale = meu_locale)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_number(),\r## cyl = col_double(),\r## disp = col_number(),\r## hp = col_double(),\r## drat = col_number(),\r## wt = col_number(),\r## qsec = col_number(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 39 262 1646 0 1 4 4\r## 2 21 6 160 110 39 2875 1702 0 1 4 4\r## 3 228 4 108 93 385 232 1861 1 1 4 1\r## 4 214 6 258 110 308 3215 1944 1 0 3 1\r## 5 187 8 360 175 315 344 1702 0 0 3 2\r## 6 181 6 225 105 276 346 2022 1 0 3 1\r## 7 143 8 360 245 321 357 1584 0 0 3 4\r## 8 244 4 1467 62 369 319 20 1 0 4 2\r## 9 228 4 1408 95 392 315 229 1 0 4 2\r## 10 192 6 1676 123 392 344 183 1 0 4 4\r## # ... with 22 more rows\r Existe ainda a possibilidade de ler dados colunados com largura-fixa. readr implementa quatro funções diferentes para ajudar na construção do dicionário:\n# Nossos dados\rx \u0026lt;- readr_example(\u0026quot;fwf-sample.txt\u0026quot;)\rread_lines(x, n_max = 10)\r ## [1] \u0026quot;John Smith WA 418-Y11-4111\u0026quot;\r## [2] \u0026quot;Mary Hartford CA 319-Z19-4341\u0026quot;\r## [3] \u0026quot;Evan Nolan IL 219-532-c301\u0026quot;\r # separados por espaço\rdic1 \u0026lt;- fwf_empty(x)\rdic1\r ## $begin\r## [1] 0 5 20 30\r## ## $end\r## [1] 4 13 22 NA\r## ## $skip\r## [1] 0\r## ## $col_names\r## [1] \u0026quot;X1\u0026quot; \u0026quot;X2\u0026quot; \u0026quot;X3\u0026quot; \u0026quot;X4\u0026quot;\r df \u0026lt;- read_fwf(file = x, col_positions = dic1)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character(),\r## X4 = col_character()\r## )\r df\r ## # A tibble: 3 x 4\r## X1 X2 X3 X4 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando a largura da coluna\rlarguras \u0026lt;- c(20, 10, 12)\rdic2 \u0026lt;- fwf_widths(larguras)\rdic2\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 30 X2 ## 3 30 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic2)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando onde cada coluna começa e termina\rcomeca \u0026lt;- c(1, 21, 30)\rtermina \u0026lt;- c(20, 29, 42)\rdic3 \u0026lt;- fwf_positions(comeca, termina)\rdic3\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 29 X2 ## 3 29 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic3)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando pares nome-valor\rdic4 \u0026lt;- fwf_cols(\rnome = c(1, 20),\ruf = c(21, 29),\rnumero = c(30, 42))\rdic4\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 nome ## 2 20 29 uf ## 3 29 42 numero\r df \u0026lt;- read_fwf(file = x, col_positions = dic4)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## nome = col_character(),\r## uf = col_character(),\r## numero = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## nome uf numero ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r Especificar dicionários para arquivos colunados é um pé-no-saco, por sorte, existem pacotes que já fizeram parte desse trabalho por nós. O readr não melhora muita o serviço manual de construção de dicionários, o que ele oferece é um ganho de performance tremendo. read_fwf é centenas de vezes mais rápido que o base read.fwf.\nEm termos do que o pacote faz, é basicamente isso. A única coisa que falta mencionar é que ele importa os dados como tibbles ao invés do data.frame padrão, mas isso já é um ótimo gancho pra nossa próxima parte.\ntibbles Tibbles são basicamente data.frames com um método mais bonitinho de print. Elas automaticamente se ajustam a largura da sua tela, omitindo as colunas que estouram, e por padrão imprimem só as 10 primeiras observações. Outras características que pessoalmente gosto, é que elas informam o tipo de variável junto com o nome, arrendondam digitos significativos, destacam números grandes, negativos, NAs e etc.\ndf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = cols()) # omitir a especificação\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Do ponto de vista prático, elas funcionam exatamente igual a data.frames, tudo que você pode fazer com um data.frame, você faz com tibbles. O que elas trazem de novidade é:\n Elas nunca mudam o tipo de dado inputado.  df1 \u0026lt;- data.frame(x = list(1:5, 1:10, 1:20))\rdf1\r ## x.1.5 x.1.10 x.1.20\r## 1 1 1 1\r## 2 2 2 2\r## 3 3 3 3\r## 4 4 4 4\r## 5 5 5 5\r## 6 1 6 6\r## 7 2 7 7\r## 8 3 8 8\r## 9 4 9 9\r## 10 5 10 10\r## 11 1 1 11\r## 12 2 2 12\r## 13 3 3 13\r## 14 4 4 14\r## 15 5 5 15\r## 16 1 6 16\r## 17 2 7 17\r## 18 3 8 18\r## 19 4 9 19\r## 20 5 10 20\r df2 \u0026lt;- tibble(x = list(1:5, 1:10, 1:20))\rdf2\r ## # A tibble: 3 x 1\r## x ## \u0026lt;list\u0026gt; ## 1 \u0026lt;int [5]\u0026gt; ## 2 \u0026lt;int [10]\u0026gt;\r## 3 \u0026lt;int [20]\u0026gt;\r  Elas nunca ajustam os nomes das variáveis  names(data.frame(`nome hipster` = 1))\r ## [1] \u0026quot;nome.hipster\u0026quot;\r names(tibble(`nome hipster` = 1))\r ## [1] \u0026quot;nome hipster\u0026quot;\r  Ela avalia cada argumento de forma \u0026ldquo;preguiçosa\u0026rdquo; e sequencial  # erro\rdata.frame(x = 1:5, y = x ^ 2)\r ## Error in x^2: argumento não-numérico para operador binário\r # funciona\rtibble(x = 1:5, y = x ^ 2)\r ## # A tibble: 5 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 4\r## 3 3 9\r## 4 4 16\r## 5 5 25\r  Ela nunca utiliza row.names  head(data.frame(state.x77))\r ## Population Income Illiteracy Life.Exp Murder HS.Grad Frost Area\r## Alabama 3615 3624 2.1 69.05 15.1 41.3 20 50708\r## Alaska 365 6315 1.5 69.31 11.3 66.7 152 566432\r## Arizona 2212 4530 1.8 70.55 7.8 58.1 15 113417\r## Arkansas 2110 3378 1.9 70.66 10.1 39.9 65 51945\r## California 21198 5114 1.1 71.71 10.3 62.6 20 156361\r## Colorado 2541 4884 0.7 72.06 6.8 63.9 166 103766\r as_tibble(state.x77)\r ## # A tibble: 50 x 8\r## Population Income Illiteracy `Life Exp` Murder `HS Grad` Frost Area\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 3615 3624 2.1 69.0 15.1 41.3 20 50708\r## 2 365 6315 1.5 69.3 11.3 66.7 152 566432\r## 3 2212 4530 1.8 70.6 7.8 58.1 15 113417\r## 4 2110 3378 1.9 70.7 10.1 39.9 65 51945\r## 5 21198 5114 1.1 71.7 10.3 62.6 20 156361\r## 6 2541 4884 0.7 72.1 6.8 63.9 166 103766\r## 7 3100 5348 1.1 72.5 3.1 56 139 4862\r## 8 579 4809 0.9 70.1 6.2 54.6 103 1982\r## 9 8277 4815 1.3 70.7 10.7 52.6 11 54090\r## 10 4931 4091 2 68.5 13.9 40.6 60 58073\r## # ... with 40 more rows\r  Ela muda a \u0026ldquo;regra da reciclagem\u0026rdquo;: apenas são aceitos vetores unitários ou vetores de tamanho igual aos demais  data.frame(x = 1:10, y = 1:5)\r ## x y\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r # erro\rtibble(x = 1:10, y = 1:5)\r ## Error: Tibble columns must have compatible sizes.\r## * Size 10: Existing data.\r## * Size 5: Column `y`.\r## i Only values of size one are recycled.\r tibble(x = 1:10, y = 1)\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 1\r## 3 3 1\r## 4 4 1\r## 5 5 1\r## 6 6 1\r## 7 7 1\r## 8 8 1\r## 9 9 1\r## 10 10 1\r tibble(x = 1:10, y = c(1:5, 1:5))\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r  Tibbles são estritas com relação as operações de subsetting com [  df1 \u0026lt;- data.frame(x = 1:3, y = 3:1)\rclass(df1[,1:2])\r ## [1] \u0026quot;data.frame\u0026quot;\r class(df1[,1])\r ## [1] \u0026quot;integer\u0026quot;\r df2 \u0026lt;- tibble(x = 1:3, y = 3:1)\rclass(df2[, 1:2])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r class(df2[, 1])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r # Se quiser extrair só uma coluna, utilize '[[' ou '$'\rclass(df2[[1]])\r ## [1] \u0026quot;integer\u0026quot;\r class(df2$x)\r ## [1] \u0026quot;integer\u0026quot;\r Elas também não aceitam \u0026lsquo;partial matching\u0026rsquo; de nomes de variáveis.\ndf \u0026lt;- data.frame(nome_de_cavalo = 1)\rdf$nome\r ## [1] 1\r df2 \u0026lt;- tibble(nome_de_cavalo = 1)\rdf2$nome\r ## Warning: Unknown or uninitialised column: `nome`.\r ## NULL\r tidyr Ok, nossos dados estão no R, mas, muitas vezes, não estão no formato adequado. De maneira geral, analistas de dados vão dar preferência a um formato parecido com este:\nIsto tem uma razão de ser que deve tornar-se óbvia quando tentarmos realizar as operações de transformação de variáveis, visualização, modelos, etc. Porém, muitas vezes outras considerações são feitas na hora registrar os dados, armazená-los, apresentá-los ao público, por isso, frequentemente nossos dados não estão no formato tidy e precisam ser reformatados. Essa é uma das principais tarefas do tidyr e é nela que vamos nos concentrar.\nAtente que reformatação, como muitos outros aspectos da análise de dados, não é receita de bolo. Muitas vezes o formato desejado não é óbvio, muito menos os passos necessários para chegar lá. Porém, vou apresentar as ferramentas e alguns exemplos simples que cobrem muitos dos nossos casos de uso.\nlibrary(tidyr)\rwho\r ## # A tibble: 7,240 x 60\r## country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghani~ AF AFG 1980 NA NA NA NA\r## 2 Afghani~ AF AFG 1981 NA NA NA NA\r## 3 Afghani~ AF AFG 1982 NA NA NA NA\r## 4 Afghani~ AF AFG 1983 NA NA NA NA\r## 5 Afghani~ AF AFG 1984 NA NA NA NA\r## 6 Afghani~ AF AFG 1985 NA NA NA NA\r## 7 Afghani~ AF AFG 1986 NA NA NA NA\r## 8 Afghani~ AF AFG 1987 NA NA NA NA\r## 9 Afghani~ AF AFG 1988 NA NA NA NA\r## 10 Afghani~ AF AFG 1989 NA NA NA NA\r## # ... with 7,230 more rows, and 52 more variables: new_sp_m4554 \u0026lt;int\u0026gt;,\r## # new_sp_m5564 \u0026lt;int\u0026gt;, new_sp_m65 \u0026lt;int\u0026gt;, new_sp_f014 \u0026lt;int\u0026gt;,\r## # new_sp_f1524 \u0026lt;int\u0026gt;, new_sp_f2534 \u0026lt;int\u0026gt;, new_sp_f3544 \u0026lt;int\u0026gt;,\r## # new_sp_f4554 \u0026lt;int\u0026gt;, new_sp_f5564 \u0026lt;int\u0026gt;, new_sp_f65 \u0026lt;int\u0026gt;,\r## # new_sn_m014 \u0026lt;int\u0026gt;, new_sn_m1524 \u0026lt;int\u0026gt;, new_sn_m2534 \u0026lt;int\u0026gt;,\r## # new_sn_m3544 \u0026lt;int\u0026gt;, new_sn_m4554 \u0026lt;int\u0026gt;, new_sn_m5564 \u0026lt;int\u0026gt;,\r## # new_sn_m65 \u0026lt;int\u0026gt;, new_sn_f014 \u0026lt;int\u0026gt;, new_sn_f1524 \u0026lt;int\u0026gt;,\r## # new_sn_f2534 \u0026lt;int\u0026gt;, new_sn_f3544 \u0026lt;int\u0026gt;, new_sn_f4554 \u0026lt;int\u0026gt;,\r## # new_sn_f5564 \u0026lt;int\u0026gt;, new_sn_f65 \u0026lt;int\u0026gt;, new_ep_m014 \u0026lt;int\u0026gt;,\r## # new_ep_m1524 \u0026lt;int\u0026gt;, new_ep_m2534 \u0026lt;int\u0026gt;, new_ep_m3544 \u0026lt;int\u0026gt;,\r## # new_ep_m4554 \u0026lt;int\u0026gt;, new_ep_m5564 \u0026lt;int\u0026gt;, new_ep_m65 \u0026lt;int\u0026gt;,\r## # new_ep_f014 \u0026lt;int\u0026gt;, new_ep_f1524 \u0026lt;int\u0026gt;, new_ep_f2534 \u0026lt;int\u0026gt;,\r## # new_ep_f3544 \u0026lt;int\u0026gt;, new_ep_f4554 \u0026lt;int\u0026gt;, new_ep_f5564 \u0026lt;int\u0026gt;,\r## # new_ep_f65 \u0026lt;int\u0026gt;, newrel_m014 \u0026lt;int\u0026gt;, newrel_m1524 \u0026lt;int\u0026gt;,\r## # newrel_m2534 \u0026lt;int\u0026gt;, newrel_m3544 \u0026lt;int\u0026gt;, newrel_m4554 \u0026lt;int\u0026gt;,\r## # newrel_m5564 \u0026lt;int\u0026gt;, newrel_m65 \u0026lt;int\u0026gt;, newrel_f014 \u0026lt;int\u0026gt;,\r## # newrel_f1524 \u0026lt;int\u0026gt;, newrel_f2534 \u0026lt;int\u0026gt;, newrel_f3544 \u0026lt;int\u0026gt;,\r## # newrel_f4554 \u0026lt;int\u0026gt;, newrel_f5564 \u0026lt;int\u0026gt;, newrel_f65 \u0026lt;int\u0026gt;\r Esse é um banco de dados difícil de analisar, ele tem 60 colunas, indicando o número de casos de tuberculose em diversos estágios da doença, por país e ano. O problema é que ao invés de termos algo como:\ntribble(\r~pais, ~ano, ~tipo, ~idade, ~casos,\r\u0026quot;brasil\u0026quot;, 1980, \u0026quot;extrapulmonar\u0026quot;, \u0026quot;15-24\u0026quot;, 10,\r\u0026quot;brasil\u0026quot;, 1990, \u0026quot;relapso\u0026quot;, \u0026quot;15-24\u0026quot;, 10\r)\r ## # A tibble: 2 x 5\r## pais ano tipo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 brasil 1980 extrapulmonar 15-24 10\r## 2 brasil 1990 relapso 15-24 10\r As informações de tipo de tuberculose e idade dos pacientes estão espalhadas pelas colunas. Pra encurtar a história, precisamos \u0026ldquo;tombar\u0026rdquo; esse banco para que essas colunas se tornem um novo conjunto de variáveis. Vamos passo a passo.\n# Primeiro, vamos excluir as colunas iso2 e iso3, porque elas são a mesma informação redundante\rwho$iso2 \u0026lt;- NULL\rwho$iso3 \u0026lt;- NULL\rwho1 \u0026lt;- pivot_longer(who,\rcols = c(new_sp_m014:newrel_f65),\rnames_to = \u0026quot;tipo_tb\u0026quot;,\rvalues_to = \u0026quot;casos\u0026quot;,\rvalues_drop_na = TRUE)\rwho1\r ## # A tibble: 76,046 x 4\r## country year tipo_tb casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 new_sp_m014 0\r## 2 Afghanistan 1997 new_sp_m1524 10\r## 3 Afghanistan 1997 new_sp_m2534 6\r## 4 Afghanistan 1997 new_sp_m3544 3\r## 5 Afghanistan 1997 new_sp_m4554 5\r## 6 Afghanistan 1997 new_sp_m5564 2\r## 7 Afghanistan 1997 new_sp_m65 0\r## 8 Afghanistan 1997 new_sp_f014 5\r## 9 Afghanistan 1997 new_sp_f1524 38\r## 10 Afghanistan 1997 new_sp_f2534 36\r## # ... with 76,036 more rows\r Nosso primeiro passo é transformar todas as colunas de novos casos em um par de colunas:\n cols indica quais colunas serão tombadas e quais serão mantidas. Uma coluna names_to recebe as categorias da variável. Uma coluna values_to recebe os valores das células. values_drop_na é uma opção para eliminar células vazias.  Essa primeira transformação já nos dá um banco de dados um pouco mais amigável, porém, ainda temos variáveis \u0026ldquo;presas\u0026rdquo; na coluna tipo_tb. Vamos tentar soltá-las.\n# primeiro, corrigir uma pequena inconsistencia:\runique(who1$tipo_tb)\r ## [1] \u0026quot;new_sp_m014\u0026quot; \u0026quot;new_sp_m1524\u0026quot; \u0026quot;new_sp_m2534\u0026quot; \u0026quot;new_sp_m3544\u0026quot; \u0026quot;new_sp_m4554\u0026quot;\r## [6] \u0026quot;new_sp_m5564\u0026quot; \u0026quot;new_sp_m65\u0026quot; \u0026quot;new_sp_f014\u0026quot; \u0026quot;new_sp_f1524\u0026quot; \u0026quot;new_sp_f2534\u0026quot;\r## [11] \u0026quot;new_sp_f3544\u0026quot; \u0026quot;new_sp_f4554\u0026quot; \u0026quot;new_sp_f5564\u0026quot; \u0026quot;new_sp_f65\u0026quot; \u0026quot;new_sn_m014\u0026quot; ## [16] \u0026quot;new_sn_m1524\u0026quot; \u0026quot;new_sn_m2534\u0026quot; \u0026quot;new_sn_m3544\u0026quot; \u0026quot;new_sn_m4554\u0026quot; \u0026quot;new_sn_m5564\u0026quot;\r## [21] \u0026quot;new_sn_m65\u0026quot; \u0026quot;new_ep_m014\u0026quot; \u0026quot;new_ep_m1524\u0026quot; \u0026quot;new_ep_m2534\u0026quot; \u0026quot;new_ep_m3544\u0026quot;\r## [26] \u0026quot;new_ep_m4554\u0026quot; \u0026quot;new_ep_m5564\u0026quot; \u0026quot;new_ep_m65\u0026quot; \u0026quot;new_sn_f014\u0026quot; \u0026quot;newrel_m014\u0026quot; ## [31] \u0026quot;newrel_f014\u0026quot; \u0026quot;new_sn_f1524\u0026quot; \u0026quot;new_sn_f2534\u0026quot; \u0026quot;new_sn_f3544\u0026quot; \u0026quot;new_sn_f4554\u0026quot;\r## [36] \u0026quot;new_sn_f5564\u0026quot; \u0026quot;new_sn_f65\u0026quot; \u0026quot;new_ep_f014\u0026quot; \u0026quot;new_ep_f1524\u0026quot; \u0026quot;new_ep_f2534\u0026quot;\r## [41] \u0026quot;new_ep_f3544\u0026quot; \u0026quot;new_ep_f4554\u0026quot; \u0026quot;new_ep_f5564\u0026quot; \u0026quot;new_ep_f65\u0026quot; \u0026quot;newrel_m1524\u0026quot;\r## [46] \u0026quot;newrel_m2534\u0026quot; \u0026quot;newrel_m3544\u0026quot; \u0026quot;newrel_m4554\u0026quot; \u0026quot;newrel_m5564\u0026quot; \u0026quot;newrel_m65\u0026quot; ## [51] \u0026quot;newrel_f1524\u0026quot; \u0026quot;newrel_f2534\u0026quot; \u0026quot;newrel_f3544\u0026quot; \u0026quot;newrel_f4554\u0026quot; \u0026quot;newrel_f5564\u0026quot;\r## [56] \u0026quot;newrel_f65\u0026quot;\r # Notem que newrel deveria ser new_rel\r# Alguns de vocês devem conhecer 'gsub'\rwho1$tipo_tb \u0026lt;- gsub(\u0026quot;newrel\u0026quot;, \u0026quot;new_rel\u0026quot;, who1$tipo_tb)\r# Agora, podemos usar outra função chave do tidyr, 'separate'\rwho2 \u0026lt;- who1 %\u0026gt;% separate(col = tipo_tb,\rinto = c(NA, \u0026quot;tipo_tb\u0026quot;, \u0026quot;sexo_idade\u0026quot;),\rsep = \u0026quot;_\u0026quot;)\rwho2\r ## # A tibble: 76,046 x 5\r## country year tipo_tb sexo_idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m014 0\r## 2 Afghanistan 1997 sp m1524 10\r## 3 Afghanistan 1997 sp m2534 6\r## 4 Afghanistan 1997 sp m3544 3\r## 5 Afghanistan 1997 sp m4554 5\r## 6 Afghanistan 1997 sp m5564 2\r## 7 Afghanistan 1997 sp m65 0\r## 8 Afghanistan 1997 sp f014 5\r## 9 Afghanistan 1997 sp f1524 38\r## 10 Afghanistan 1997 sp f2534 36\r## # ... with 76,036 more rows\r # E outra passagem de separate para separar a idade do sexo\rwho3 \u0026lt;- who2 %\u0026gt;% separate(col = sexo_idade,\rinto = c(\u0026quot;sexo\u0026quot;, \u0026quot;idade\u0026quot;),\rsep = 1)\rwho3\r ## # A tibble: 76,046 x 6\r## country year tipo_tb sexo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m 014 0\r## 2 Afghanistan 1997 sp m 1524 10\r## 3 Afghanistan 1997 sp m 2534 6\r## 4 Afghanistan 1997 sp m 3544 3\r## 5 Afghanistan 1997 sp m 4554 5\r## 6 Afghanistan 1997 sp m 5564 2\r## 7 Afghanistan 1997 sp m 65 0\r## 8 Afghanistan 1997 sp f 014 5\r## 9 Afghanistan 1997 sp f 1524 38\r## 10 Afghanistan 1997 sp f 2534 36\r## # ... with 76,036 more rows\r Bem melhor, não acham? Estamos agora com um banco de dados muito mais adequado para uma análise de dados em R. Cada linha é uma observação, cada coluna é uma informação sobre ela.\nAlguns de vocês podem ter reparado que fizemos um caminho em que nosso banco de dados passou de ter muitas colunas para muitas linhas (ficou mais \u0026ldquo;longo\u0026rdquo;) e depois precisamos separar algumas das colunas que criamos em outras (o que fizemos com separate). Podemos facilmente imaginar situações em que queremos fazer o caminho inverso: transformar um banco do formato longo para o formato com mais colunas e unir colunas separadas em uma nova. Vamos ver um exemplo.\n# Exemplo adaptado de https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population\rpopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Imagine que, por qualquer motivo, você prefira trabalhar com uma variável \u0026ldquo;Data\u0026rdquo; ao invés de dia, mês e ano. Podemos usar unite:\npopulacao2 \u0026lt;- populacao %\u0026gt;% unite(col = Data, Day, Month, Year, sep = \u0026quot; \u0026quot;)\rpopulacao2\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19 May 20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19 May 20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census result[9]\r O outro problema que precisamos resolver frequentemente, é separar um par de variáveis em diversas colunas, fazendo o caminho inverso que fizemos no caso do dataset da OMS.\nus_rent_income\r ## # A tibble: 104 x 5\r## GEOID NAME variable estimate moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama income 24476 136\r## 2 01 Alabama rent 747 3\r## 3 02 Alaska income 32940 508\r## 4 02 Alaska rent 1200 13\r## 5 04 Arizona income 27517 148\r## 6 04 Arizona rent 972 4\r## 7 05 Arkansas income 23789 165\r## 8 05 Arkansas rent 709 5\r## 9 06 California income 29454 109\r## 10 06 California rent 1358 3\r## # ... with 94 more rows\r No exemplo acima, queremos separar em colunas os valores das variáveis de renda e valor do aluguel. Esse tipo de operação tem um certo grau de abstração que me deu bastante dor de cabeça para entender inicialmente, então vamos olhar com carinho para o que queremos ter depois da transformação.\nus_rent_income2 \u0026lt;- tribble(\r~GEOID, ~NAME, ~income_estimate, ~rent_estimate, ~income_moe, ~rent_moe,\r\u0026quot;01\u0026quot;, \u0026quot;Alabama\u0026quot;, 24476, 747, 136, 3,\r\u0026quot;02\u0026quot;, \u0026quot;Alaska\u0026quot;, 32940, 1200, 508, 13\r)\rus_rent_income2\r ## # A tibble: 2 x 6\r## GEOID NAME income_estimate rent_estimate income_moe rent_moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r O banco que queremos tem uma cara assim. Ele tem mais colunas novas e menos linhas, já que eu tinha no formato tidy uma variável chamada \u0026ldquo;variable\u0026rdquo; que guardava os valores renda e aluguel e duas colunas que guardavam os valores da estimativa e do moe. Agora, eu vou ter 4 colunas, duas para as estimativas de renda e aluguel e duas para os moes das mesmas variáveis. Como especificar isso para o banco todo? Usando pivot_wider.\nus_rent_income %\u0026gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe))\r ## # A tibble: 52 x 6\r## GEOID NAME estimate_income estimate_rent moe_income moe_rent\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r## 3 04 Arizona 27517 972 148 4\r## 4 05 Arkansas 23789 709 165 5\r## 5 06 California 29454 1358 109 3\r## 6 08 Colorado 32401 1125 109 5\r## 7 09 Connecticut 35326 1123 195 5\r## 8 10 Delaware 31560 1076 247 10\r## 9 11 District of Columbia 43198 1424 681 17\r## 10 12 Florida 25952 1077 70 3\r## # ... with 42 more rows\r As funções pivot_ tem diversos outros argumentos e cobrem diversos casos de uso. Vejam este exemplo da documentação de pivot_longer:\nanscombe\r ## x1 x2 x3 x4 y1 y2 y3 y4\r## 1 10 10 10 8 8.04 9.14 7.46 6.58\r## 2 8 8 8 8 6.95 8.14 6.77 5.76\r## 3 13 13 13 8 7.58 8.74 12.74 7.71\r## 4 9 9 9 8 8.81 8.77 7.11 8.84\r## 5 11 11 11 8 8.33 9.26 7.81 8.47\r## 6 14 14 14 8 9.96 8.10 8.84 7.04\r## 7 6 6 6 8 7.24 6.13 6.08 5.25\r## 8 4 4 4 19 4.26 3.10 5.39 12.50\r## 9 12 12 12 8 10.84 9.13 8.15 5.56\r## 10 7 7 7 8 4.82 7.26 6.42 7.91\r## 11 5 5 5 8 5.68 4.74 5.73 6.89\r Podemos transformar esse banco de dados rapidamente usando um dos argumentos de pivot_longer, chamado names_pattern.\nanscombe %\u0026gt;% pivot_longer(everything(),\rnames_to = c(\u0026quot;.value\u0026quot;, \u0026quot;set\u0026quot;),\rnames_pattern = \u0026quot;(.)(.)\u0026quot;)\r ## # A tibble: 44 x 3\r## set x y\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10 8.04\r## 2 2 10 9.14\r## 3 3 10 7.46\r## 4 4 8 6.58\r## 5 1 8 6.95\r## 6 2 8 8.14\r## 7 3 8 6.77\r## 8 4 8 5.76\r## 9 1 13 7.58\r## 10 2 13 8.74\r## # ... with 34 more rows\r Esse exemplo é interessante, porque ele se aproveita de uma \u0026ldquo;regular expression\u0026rdquo;, tema da parte do nosso curso em que falaremos sobre manipulação de strings com o stringr. Resumidas as contas, as colunas se chamam \u0026ldquo;x1, x2, x3 \u0026hellip;\u0026rdquo; e a string \u0026ldquo;(.)(.)\u0026rdquo; indica que há dois \u0026ldquo;grupos\u0026rdquo; formados por um caractere cada. A string \u0026ldquo;.value\u0026rdquo; que vai no argumento de cima é um atalho da função para dizer \u0026ldquo;pegue o valor de todas as células das variáveis selecionadas\u0026rdquo;, aqui, todas. Ou seja, ele indica para a função que o primeiro caractere \u0026ldquo;x\u0026rdquo; ou \u0026ldquo;y\u0026rdquo; definirá uma nova variável e armazenará os valores das celulas, enquanto o segundo grupo \u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo; ou \u0026ldquo;4\u0026rdquo; formará uma segunda variável chamada \u0026ldquo;set\u0026rdquo; que contém apenas os nomes das colunas. Deu um nó na cabeça?\nUma última preocupação ao utilizar a reformatação de dados é o que ocorre com os valores NA. Vejamos este exemplo:\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\r Existem dois tipos de valor nulo, explícito se diz de um valor nulo como aquele NA que aparece na variável lucro. Implícito é o valor que ocorre no primeiro quadrimestre de 2016, onde sequer foi adicionada uma linha no banco de dados. Os valores implícitos são muito sacanas, porque eles não são imediatamente visíveis.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro)\r ## # A tibble: 4 x 3\r## qdr `2015` `2016`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1.88 NA ## 2 2 0.59 0.92\r## 3 3 0.35 0.17\r## 4 4 NA 2.66\r Ao transformar o banco, o valor implícito ficou explícito. Caso você não esteja interessado neste valor, você pode passar o values_drop_na durante a transformação de volta ao formato original.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro) %\u0026gt;% pivot_longer(c(`2015`, `2016`),\rnames_to = \u0026quot;ano\u0026quot;,\rvalues_to = \u0026quot;lucro\u0026quot;,\rvalues_drop_na = TRUE)\r ## # A tibble: 6 x 3\r## qdr ano lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2015 1.88\r## 2 2 2015 0.59\r## 3 2 2016 0.92\r## 4 3 2015 0.35\r## 5 3 2016 0.17\r## 6 4 2016 2.66\r Que faz os valores missing desaparecerem do resultado.\ncomplete pode ser usada pra tornar valores implícitos, explícitos! A função toma todas as colunas pedidas e verifica todas as combinações possíveis de valores, preenchendo as lacunas com NA. Cuidado ao utilizar complete com valores numéricos ou conjuntos de colunas com muitas combinações possíveis, pois o número de combinações pode ser infinitamente grande e travar sua sessão!\nacoes %\u0026gt;% complete(ano, qdr)\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Pra encerrar, fill serve para aqueles casos em que um valor missing indica que a última observação deve ser repetida. Pesquisadores brasileiros das antigas podem lembrar-se do Censo de 1991, em que o IBGE registrava os arquivos de domícilio e pessoas com esse sistema. Em inglês, isso se chama LOCF, ou \u0026ldquo;last observation carried forward\u0026rdquo;.\ntreatment \u0026lt;- tribble(\r~ person, ~ treatment, ~response,\r\u0026quot;Derrick Whitmore\u0026quot;, 1, 7,\rNA, 2, 10,\rNA, 3, 9,\r\u0026quot;Katherine Burke\u0026quot;, 1, 4\r)\rtreatment\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 \u0026lt;NA\u0026gt; 2 10\r## 3 \u0026lt;NA\u0026gt; 3 9\r## 4 Katherine Burke 1 4\r treatment %\u0026gt;% fill(person)\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 Derrick Whitmore 2 10\r## 3 Derrick Whitmore 3 9\r## 4 Katherine Burke 1 4\r tidyr tem também outras funcionalidades relevantes para modelagem estatística, mas acho que isso sai um pouco do escopo do curso. Quem sabe a gente não faz um curso posterior só sobre modelagem no tidyverse?\nRevisão readr O pacote readr apresenta uma família de funções para substituir as funções do base relacionadas a importação de arquivos em formato texto, seja delimitado ou largura-fixa. São elas,\n read_delim read_csv read_csv2 read_tsv read_table read_fwf  E assim sucessivamente. Durante o processo de importação, você pode querer especificar o tipo de coluna com cols ou cols_only, usando o argumento col_types. Ou use uma string do tipo \u0026ldquo;ddcdiDT\u0026rdquo; em que cada letra é um tipo de variável.\n col_integer col_double col_factor col_character  Etc. Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nAh, e você sempre pode salvar com write_, inclusive salvando/lendo compactado para bzip, gzip ou xzip.\ntibble Tibbles são uma versão do data.frame com algumas regrinhas novas. Vou apenas repetí-las aqui de forma resumida.\n tibbles tem um método print mais bonito e amigável, especialmente para bancos com muitas observações e variáveis. elas são estritas com operações de subsetting com [ e $. elas não aceita a reciclagem de argumento de tamanho diferente de 1.  tidyr tidyr é um pacote de reformatação de bancos, criando novas linhas e colunas a partir da reorganização das variáveis e valores existentes. Suas principais operações são:\n pivot_longer para converter colunas em linhas pivot_wider para converter linhas em colunas separate para separar uma coluna em várias com base em caracteres unite para unir diversas colunas em uma com base em caracteres  Ufa. Acabou né? Posso ir dormir já? Claro, só fazer uns exercícios!\nExercícios  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  file \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.  # Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\rbillboard  ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r  Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?\n  O que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.\n  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r  Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?\n  Compare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?\n  Agradecimentos Esse material é uma adaptação livre das vinhetas dos pacotes tidyr, readr e tibble e do capítulo Tidy Data do R for Data Science, de Wickham \u0026amp; Grolemund.\n","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"0bad4868b4cebec13d81438fabee26ad","permalink":"https://laddem.github.io/courses/tidyverse/dia1/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia1/","section":"courses","summary":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:","tags":null,"title":"readr, tibble e tidyr","type":"book"},{"authors":null,"categories":null,"content":"\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\nO pacote stringr é uma série de adaptações da biblioteca stringi e serve para a manipulação de variáveis texto, incluindo funções para detecção, modificação, substituição, remoção de texto em variáveis caractere. Para dominar esse assunto, é necessário compreender o conceito de “regex,” ou “expressão regular,” que foge um pouco do escopo do curso, mas que será introduzido brevemente.\nO pacote forcats contém uma série de funções para trabalhar com o tipo factor. São funções que facilitam operações envolvendo esse tipo de variável, como contagens, troca dos nomes das categorias, agrupamento de categorias, recodificação, plotagem, etc.\nO pacote dplyr é um dos pilares do tidyverse e ele tem dois papéis principais: operações de manipulação de banco de dados simples e operações de bancos de dados relacionais. No primeiro tipo são incluídas as operações de criação e modificação de variáveis, medidas resumo globais e por grupos, seleção de variáveis, mudança da ordem das linhas e colunas, etc. No segundo tipo, são as operações de tipo _join, em que uma variável chave é utilizada para combinar registros de dois bancos de dados distintos.\nOs pacotes stringr e forcats são mais diretos, mas o dplyr pode representar um certo nível de abstração que pode incomodar usuários de longa data do R, portanto, vamos nos esforçar para demonstrar as vantagens de mudar seu workflow para incluir as funções desse pacote através de comparações com o R base.\ndplyr dplyr para manipulação de dados Talvez o pacote mais utilizado de todo o tidyverse, dplyr é um pacote de manipulação de bancos de dados inspirado pela linguagem SQL. A ideia é concatenar operações de seleção de variáveis, filtragem de observação, arranjo e ordenamento, derivação de variáveis, computação de medidas resumo para o banco todo ou para grupos. As funções básicas e mais utilizadas são, portanto:\n select filter arrange mutate summarize group_by  Para praticar, vamos usar o dataset flights, que contém informações sobre os vôos saídos de Nova Iorque em 2013.\nlibrary(nycflights13)\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r## The following objects are masked from 'package:stats':\r## ## filter, lag\r## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r flights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r glimpse(flights)\r ## Rows: 336,776\r## Columns: 19\r## $ year \u0026lt;int\u0026gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2~\r## $ month \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ day \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ dep_time \u0026lt;int\u0026gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, ~\r## $ sched_dep_time \u0026lt;int\u0026gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, ~\r## $ dep_delay \u0026lt;dbl\u0026gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1~\r## $ arr_time \u0026lt;int\u0026gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,~\r## $ sched_arr_time \u0026lt;int\u0026gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,~\r## $ arr_delay \u0026lt;dbl\u0026gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1~\r## $ carrier \u0026lt;chr\u0026gt; \u0026quot;UA\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;DL\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;EV\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;~\r## $ flight \u0026lt;int\u0026gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4~\r## $ tailnum \u0026lt;chr\u0026gt; \u0026quot;N14228\u0026quot;, \u0026quot;N24211\u0026quot;, \u0026quot;N619AA\u0026quot;, \u0026quot;N804JB\u0026quot;, \u0026quot;N668DN\u0026quot;, \u0026quot;N394~\r## $ origin \u0026lt;chr\u0026gt; \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;,~\r## $ dest \u0026lt;chr\u0026gt; \u0026quot;IAH\u0026quot;, \u0026quot;IAH\u0026quot;, \u0026quot;MIA\u0026quot;, \u0026quot;BQN\u0026quot;, \u0026quot;ATL\u0026quot;, \u0026quot;ORD\u0026quot;, \u0026quot;FLL\u0026quot;, \u0026quot;IAD\u0026quot;,~\r## $ air_time \u0026lt;dbl\u0026gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1~\r## $ distance \u0026lt;dbl\u0026gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, ~\r## $ hour \u0026lt;dbl\u0026gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6~\r## $ minute \u0026lt;dbl\u0026gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0~\r## $ time_hour \u0026lt;dttm\u0026gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0~\r Podemos filtrar nossas linhas: filter\n# Voos de primeiro de janeiro\rflights %\u0026gt;% filter(month == 1, day == 1)\r ## # A tibble: 842 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 832 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos a partir de junho\rflights %\u0026gt;% filter(month \u0026gt; 6)\r ## # A tibble: 170,618 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 170,608 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saídos do aeroporto JFK\rflights %\u0026gt;% filter(origin == \u0026quot;JFK\u0026quot;)\r ## # A tibble: 111,279 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 111,269 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com destino ao aeroporto de Albuquerque\rflights %\u0026gt;% filter(dest == \u0026quot;ABQ\u0026quot;)\r ## # A tibble: 254 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 1955 2001 -6 2213 2248\r## 2 2013 10 2 2010 2001 9 2230 2248\r## 3 2013 10 3 1955 2001 -6 2232 2248\r## 4 2013 10 4 2017 2001 16 2304 2248\r## 5 2013 10 5 1959 1959 0 2226 2246\r## 6 2013 10 6 1959 2001 -2 2234 2248\r## 7 2013 10 7 2002 2001 1 2233 2248\r## 8 2013 10 8 1957 2001 -4 2216 2248\r## 9 2013 10 9 1957 2001 -4 2220 2248\r## 10 2013 10 10 2011 2001 10 2235 2248\r## # ... with 244 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de até 10 minutos\rflights %\u0026gt;% filter(dep_delay \u0026lt;= 10)\r ## # A tibble: 245,687 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 245,677 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de cerca de 10 minutos\rflights %\u0026gt;% filter(near(dep_delay, 10, tol = 2))\r ## # A tibble: 8,677 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 611 600 11 945 931\r## 2 2013 1 1 709 700 9 852 832\r## 3 2013 1 1 826 817 9 1145 1158\r## 4 2013 1 1 851 840 11 1215 1206\r## 5 2013 1 1 1011 1001 10 1133 1128\r## 6 2013 1 1 1208 1158 10 1540 1502\r## 7 2013 1 1 1240 1229 11 1451 1428\r## 8 2013 1 1 1310 1300 10 1559 1554\r## 9 2013 1 1 1330 1321 9 1613 1536\r## 10 2013 1 1 1511 1500 11 1753 1742\r## # ... with 8,667 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos que ocorreram entre abril e maio\rflights %\u0026gt;% filter(between(month, 4, 5))\r ## # A tibble: 57,126 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 57,116 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Podemos combinar várias condições usando operadores lógicos\n# Voos até 15 de abril ou até 15 de maio\rflights %\u0026gt;% filter(\rbetween(month, 4, 5), # mesmo que usar \u0026amp;\rbetween(day, 1, 15)\r)\r ## # A tibble: 28,176 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 28,166 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos entre 15 de abril e 15 de maio\rflights %\u0026gt;% filter(\rmonth == 4 \u0026amp; between(day, 15, 30) | # OU\rmonth == 5 \u0026amp; between(day, 1, 15)\r)\r ## # A tibble: 29,101 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 15 2 2359 3 341 339\r## 2 2013 4 15 453 500 -7 639 640\r## 3 2013 4 15 511 515 -4 741 802\r## 4 2013 4 15 527 530 -3 806 813\r## 5 2013 4 15 527 529 -2 750 743\r## 6 2013 4 15 537 540 -3 846 840\r## 7 2013 4 15 542 545 -3 931 927\r## 8 2013 4 15 551 600 -9 728 758\r## 9 2013 4 15 552 600 -8 835 850\r## 10 2013 4 15 552 600 -8 648 701\r## # ... with 29,091 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos em todas os primeiros 7 dias de cada mês, exceto em janeiro e dezembro\rflights %\u0026gt;% filter(\rbetween(day, 1, 7),\r!month %in% c(1, 12)\r)\r ## # A tibble: 64,365 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 64,355 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saidos de JFK, excluindo aqueles para os quais não tem informações de horário de saída\rflights %\u0026gt;% filter(\rorigin == \u0026quot;JFK\u0026quot;, !is.na(dep_time)\r)\r ## # A tibble: 109,416 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 109,406 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com mais de 30 minutos de atraso em janeiro ou dezembro\rflights %\u0026gt;% filter(\rdep_delay \u0026gt; 30, xor(month == 1, month == 12)\r)\r ## # A tibble: 8,221 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 732 645 47 1011 941\r## 2 2013 1 1 749 710 39 939 850\r## 3 2013 1 1 811 630 101 1047 830\r## 4 2013 1 1 826 715 71 1136 1045\r## 5 2013 1 1 848 1835 853 1001 1950\r## 6 2013 1 1 903 820 43 1045 955\r## 7 2013 1 1 909 810 59 1331 1315\r## 8 2013 1 1 953 921 32 1320 1241\r## 9 2013 1 1 957 733 144 1056 853\r## 10 2013 1 1 1025 951 34 1258 1302\r## # ... with 8,211 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r E assim sucessivamente.\nDa mesma forma, temos select para selecionar as variáveis do banco. As duas grandes novidades são que você não precisa utilizar aspas na seleção de variáveis e que select introduz várias helper functions para facilitar a seleção de variáveis parecidas.\n# Selecionar as colunas ano, mes, dia, horario de saida e horario de chegada\rflights %\u0026gt;% select(year, month, day, dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Utilizando helpers\rflights %\u0026gt;% select(year:dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Mais helpers\rflights %\u0026gt;% select(year:day, starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 2 830 11\r## 2 2013 1 1 533 4 850 20\r## 3 2013 1 1 542 2 923 33\r## 4 2013 1 1 544 -1 1004 -18\r## 5 2013 1 1 554 -6 812 -25\r## 6 2013 1 1 554 -4 740 12\r## 7 2013 1 1 555 -5 913 19\r## 8 2013 1 1 557 -3 709 -14\r## 9 2013 1 1 557 -3 838 -8\r## 10 2013 1 1 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, ends_with(\u0026quot;time\u0026quot;))\r ## # A tibble: 336,776 x 8\r## year month day dep_time sched_dep_time arr_time sched_arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 515 830 819 227\r## 2 2013 1 1 533 529 850 830 227\r## 3 2013 1 1 542 540 923 850 160\r## 4 2013 1 1 544 545 1004 1022 183\r## 5 2013 1 1 554 600 812 837 116\r## 6 2013 1 1 554 558 740 728 150\r## 7 2013 1 1 555 600 913 854 158\r## 8 2013 1 1 557 600 709 723 53\r## 9 2013 1 1 557 600 838 846 140\r## 10 2013 1 1 558 600 753 745 138\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, c(ends_with(\u0026quot;time\u0026quot;)) \u0026amp; !contains(\u0026quot;sched\u0026quot;))\r ## # A tibble: 336,776 x 6\r## year month day dep_time arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 830 227\r## 2 2013 1 1 533 850 227\r## 3 2013 1 1 542 923 160\r## 4 2013 1 1 544 1004 183\r## 5 2013 1 1 554 812 116\r## 6 2013 1 1 554 740 150\r## 7 2013 1 1 555 913 158\r## 8 2013 1 1 557 709 53\r## 9 2013 1 1 557 838 140\r## 10 2013 1 1 558 753 138\r## # ... with 336,766 more rows\r # Você pode mudar o nome das colunas durante um call para select\rflights %\u0026gt;% select(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 3\r## ano mes dia\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1\r## 2 2013 1 1\r## 3 2013 1 1\r## 4 2013 1 1\r## 5 2013 1 1\r## 6 2013 1 1\r## 7 2013 1 1\r## 8 2013 1 1\r## 9 2013 1 1\r## 10 2013 1 1\r## # ... with 336,766 more rows\r # Ou você pode usar rename para mudar os nomes sem selecionar variáveis\rflights %\u0026gt;% rename(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 19\r## ano mes dia dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r São realmente muitas possibilidades, vejam a documentação e os exemplos em ?select.\nUtilizando arrange podemos facilmente organizar nosso banco a partir de variáveis de interesse:\n# Selecionar algumas variáveis e ver organizar de acordar com os mais adiantados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(dep_delay, arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 12 7 2040 -43 40 48\r## 2 2013 2 3 2022 -33 2240 -58\r## 3 2013 11 10 1408 -32 1549 -10\r## 4 2013 1 11 1900 -30 2233 -10\r## 5 2013 1 29 1703 -27 1947 -10\r## 6 2013 8 9 729 -26 1002 7\r## 7 2013 3 30 2030 -25 2213 -37\r## 8 2013 10 23 1907 -25 2143 0\r## 9 2013 5 5 934 -24 1225 -44\r## 10 2013 9 18 1631 -24 1812 -33\r## # ... with 336,766 more rows\r # Ou os mais atrasados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(-dep_delay, -arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 9 641 1301 1242 1272\r## 2 2013 6 15 1432 1137 1607 1127\r## 3 2013 1 10 1121 1126 1239 1109\r## 4 2013 9 20 1139 1014 1457 1007\r## 5 2013 7 22 845 1005 1044 989\r## 6 2013 4 10 1100 960 1342 931\r## 7 2013 3 17 2321 911 135 915\r## 8 2013 6 27 959 899 1236 850\r## 9 2013 7 22 2257 898 121 895\r## 10 2013 12 5 756 896 1058 878\r## # ... with 336,766 more rows\r É basicamente isso, você pode especificar uma ou muitas colunas para organizar, decidir se a ordem é ascendente ou descendente e pronto.\nUtilizando mutate, você cria variáveis derivadas das originais. Como tibble, essa função avalia seus argumentos de maneira preguiçosa e sequencial, o que permite você criar variáveis derivadas umas das outras muito facilmente.\nflights %\u0026gt;% select(sched_dep_time, dep_time, sched_arr_time, arr_time) %\u0026gt;% mutate(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 8\r## sched_dep_time dep_time sched_arr_time arr_time atraso_decolagem atraso_pouso\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 515 517 819 830 2 11\r## 2 529 533 830 850 4 20\r## 3 540 542 850 923 2 73\r## 4 545 544 1022 1004 -1 -18\r## 5 600 554 837 812 -46 -25\r## 6 558 554 728 740 -4 12\r## 7 600 555 854 913 -45 59\r## 8 600 557 723 709 -43 -14\r## 9 600 557 846 838 -43 -8\r## 10 600 558 745 753 -42 8\r## # ... with 336,766 more rows, and 2 more variables: atraso_dec_horas \u0026lt;dbl\u0026gt;,\r## # atraso_pouso_horas \u0026lt;dbl\u0026gt;\r # Transmute é um atalho para quando você quer apenas as variáveis resultado e não está interessado nas intermediárias.\rflights %\u0026gt;% transmute(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 4\r## atraso_decolagem atraso_pouso atraso_dec_horas atraso_pouso_horas\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 11 0.0333 0.183\r## 2 4 20 0.0667 0.333\r## 3 2 73 0.0333 1.22 ## 4 -1 -18 -0.0167 -0.3 ## 5 -46 -25 -0.767 -0.417\r## 6 -4 12 -0.0667 0.2 ## 7 -45 59 -0.75 0.983\r## 8 -43 -14 -0.717 -0.233\r## 9 -43 -8 -0.717 -0.133\r## 10 -42 8 -0.7 0.133\r## # ... with 336,766 more rows\r Usando o pipe, é fazer diversas operações de transformação de variáveis simultâneamente em um único call sem a necessidade de repetir o nome do objeto e $ a cada referência. mutate é uma função extremamente flexível, você pode chamar qualquer função que retorne um vetor de tamanho 1 ou de tamanho do número de linhas do banco lá dentro para criar uma variável.\ndesabafo \u0026lt;- function(x) {\ry \u0026lt;- floor(x / 60)\rdplyr::case_when(\r# Condições ~ Resultados\ry \u0026lt; 0 ~ \u0026quot;Opa, vou chegar cedo!\u0026quot;,\ry \u0026lt; 1 ~ \u0026quot;Atraso de menos de 1 hora é tolerável\u0026quot;,\ry \u0026gt;= 1 ~ paste0(\u0026quot;Atraso de mais de \u0026quot;, y, \u0026quot; horas é f***.\u0026quot;),\rTRUE ~ \u0026quot;Ahn?\u0026quot; # Condição guarda-chuva\r)\r}\rflights %\u0026gt;% select(dep_delay) %\u0026gt;% mutate(desabafo = desabafo(dep_delay)) %\u0026gt;% sample_n(10)\r ## # A tibble: 10 x 2\r## dep_delay desabafo ## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 -5 Opa, vou chegar cedo! ## 2 23 Atraso de menos de 1 hora é tolerável\r## 3 -4 Opa, vou chegar cedo! ## 4 -3 Opa, vou chegar cedo! ## 5 -8 Opa, vou chegar cedo! ## 6 -3 Opa, vou chegar cedo! ## 7 -5 Opa, vou chegar cedo! ## 8 22 Atraso de menos de 1 hora é tolerável\r## 9 23 Atraso de menos de 1 hora é tolerável\r## 10 -2 Opa, vou chegar cedo!\r Utilizando summarize você tira medidas resumo das suas colunas de interesse:\nflights %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 1 x 5\r## atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~ n_voos\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 12.6 40.2 6.90 44.6 336776\r Parece uma bobagem, mas quando você junta isso com a última função, group_by, é possível obter diversas estatísticas de interesse muito rapidamente e para vários domínios:\n# Por mês\rflights %\u0026gt;% group_by(month) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 12 x 6\r## month atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 36.4 6.13 40.4\r## 2 2 10.8 36.3 5.61 39.5\r## 3 3 13.2 40.1 5.81 44.1\r## 4 4 13.9 43.0 11.2 47.5\r## 5 5 13.0 39.4 3.52 44.2\r## 6 6 20.8 51.5 16.5 56.1\r## 7 7 21.7 51.6 16.7 57.1\r## 8 8 12.6 37.7 6.04 42.6\r## 9 9 6.72 35.6 -4.02 39.7\r## 10 10 6.24 29.7 -0.167 32.6\r## 11 11 5.44 27.6 0.461 31.4\r## 12 12 16.6 41.9 14.9 46.1\r## # ... with 1 more variable: n_voos \u0026lt;int\u0026gt;\r # Por mês e aeroporto de origem\rflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 EWR 14.9 40.8 12.8 ## 2 1 JFK 8.62 36.0 1.37\r## 3 1 LGA 5.64 29.7 3.38\r## 4 2 EWR 13.1 37.2 8.78\r## 5 2 JFK 11.8 37.4 4.39\r## 6 2 LGA 6.96 33.4 3.15\r## 7 3 EWR 18.1 44.1 10.6 ## 8 3 JFK 10.7 35.3 2.58\r## 9 3 LGA 10.2 39.7 3.74\r## 10 4 EWR 17.4 43.9 14.1 ## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r Uma vez que você se familiariza com a gramática do dplyr, o processo de análise exploratória se torna bastante trivial e até certo ponto, prazeiroso. Mas o que eu realmente gosto é que ele também se torna visualmente óbvio para o leitor, com cada chamado podendo ser lido como uma declaração:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo.\n Você também pode rapidamente introduzir ou retirar passos em cada chamado deste utilizando o pipe, por exemplo:\nflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38\r## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r E a leitura fica:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo, então, ordene os resultados pelo maior atraso.\n De quebra, você ainda leva para casa um dado no formato “tabela,” fácil de exportar para outros softwares para embelezamento e publicação. Veja:\nresumo \u0026lt;- flights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r print(resumo, n = Inf)\r ## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38 ## 11 1 EWR 14.9 40.8 12.8 ## 12 12 JFK 14.8 39.1 12.7 ## 13 12 LGA 13.6 39.8 12.0 ## 14 8 EWR 13.5 37.6 6.71 ## 15 2 EWR 13.1 37.2 8.78 ## 16 8 JFK 12.9 36.3 5.91 ## 17 5 JFK 12.5 38.5 2.12 ## 18 4 JFK 12.2 41.2 7.01 ## 19 2 JFK 11.8 37.4 4.39 ## 20 4 LGA 11.5 43.4 12.0 ## 21 8 LGA 11.2 39.2 5.41 ## 22 3 JFK 10.7 35.3 2.58 ## 23 5 LGA 10.6 40.6 2.80 ## 24 3 LGA 10.2 39.7 3.74 ## 25 10 EWR 8.64 32.7 2.60 ## 26 1 JFK 8.62 36.0 1.37 ## 27 9 EWR 7.29 35.0 -4.73 ## 28 2 LGA 6.96 33.4 3.15 ## 29 11 EWR 6.72 28.8 0.672\r## 30 9 JFK 6.64 32.5 -4.46 ## 31 9 LGA 6.21 39.0 -2.83 ## 32 1 LGA 5.64 29.7 3.38 ## 33 10 LGA 5.31 30.1 0.186\r## 34 11 LGA 4.77 26.6 1.55 ## 35 11 JFK 4.68 27.1 -0.873\r## 36 10 JFK 4.59 25.2 -3.59 ## # ... with 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;, n_voos \u0026lt;int\u0026gt;\r Lembrem-se que é necessário atribuir \u0026lt;- os resultados das operações para que elas sejam salvas. Em geral, meu workflow é assim:\n# Começo com o banco\rflights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Seleciono algumas variáveis\rflights %\u0026gt;% select(month, dep_delay, arr_delay)\r ## # A tibble: 336,776 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 336,766 more rows\r # Recorto algumas observações\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6))\r ## # A tibble: 166,158 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 166,148 more rows\r # Escolho os dominios e calculo as medidas resumo\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T))\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 6.13\r## 2 2 10.8 5.61\r## 3 3 13.2 5.81\r## 4 4 13.9 11.2 ## 5 5 13.0 3.52\r## 6 6 20.8 16.5\r # Acho bom organizar pelos atrasos maiores\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r # Estou satisfeito, salvo meu resultado em outro objeto\ratrasos \u0026lt;- flights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\ratrasos\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r Desta forma, consigo construir interativamente meus cálculos, verificando a cada passo se estou obtendo o resultado esperado. Visto de outra perspectiva, se encontro um código programado desta forma que não funciona, posso ir apagando cada %\u0026gt;% para identificar onde o problema ocorreu.\nEspero que tenha ficado claro que o assunto não se encerra por aqui. Existem diversas outras funções úteis no pacote, como count, if_else, case_when, top_n, bind_rows, bind_cols, as novas funções across e c_across e muitas, muitas outras. Nos livros vocês encontram vários outros exemplos e funções para facilitar o processo de análise de dados, mas nossa expectativa é que essa apresentação seja um ponto de partida para vocês se aprofundarem no seu próprio ritmo.\ndplyr para bancos de dados relacionais Nesta seção, o nosso problema não é mais a análise de dados presentes em um banco, mas o problema de relacionar informações sobre uma mesma unidade de análise que estão presentes em vários bancos de dados distintos.\nO banco nycflights13 contém várias tabelas que se relacionam, e elas funcionam como um excelente exemplo de banco de dados relacionais.\nNote que além do banco de dados dos vôos, temos informações sobre clima, aviões e companhias aéreas. Para nós, pode ser relevante reunir informações de diferentes fontes em um mesmo banco de dados, algo que é possível através de joins. Por uma questão de tempo, não vamos entrar muito a fundo no assunto, mas vamos introduzir dois conceitos chave e partir pros exemplos.\n  chaves são as variáveis que identificam cada observação em um banco de dados de forma única. Uma chave é dita “primária” quando identifica uma observação na sua própria tabela e “externa” quando ela identifica uma observação em outra tabela. Assim, qualquer operação de join é uma forma de relacionar uma chave primária e uma chave externa. Essa junção de chaves é uma relação, e as relações podem ser 1 para 1, 1 para muitos ou muitos para 1.\n  joins são tipos de operação no qual se opta por priorizar um grupo de observações em detrimento de outras. Podemos vê-los didaticamente a partir de duas figuras:\n  A primeira figura é interessante porque nos dá uma ideia de quais observações serão mantidas e quais serão descartadas, podemos imaginá-la como uma abstração da nossa escolha.\n Quero todas as informações sobre os vôos e os aeroportos, e as duas são igualmente importantes (inner_join, x = flights, y = airports).\n  Quero todas as observações do banco vôos e as informações disponíveis sobre a aeronave (left_join, x = flights, y = planes).\n  Quero todas as informações tanto sobre os vôos quanto sobre o clima em cada dia (full_join, x = flights, y = weather).\n  Quero as informações dos vôos realizados pelas companhias aéreas - minha prioridade são as cias. áreas (right_join, x = flights, y = carriers).\n A segunda figura é interessante porque elas mostra a mecânica de um join: cada observação tem a sua chave marcada com a observação correspondente no outro banco. Se as chaves são iguais, a operação é realizada, se as chaves não são iguais, a operação não é realizada. Dependendo do tipo de join, uma, as duas ou nenhuma das observações é descartada do banco resultante.\n Antes de começar a trabalhar com bancos relacionais, é uma boa ideia dar uma explorada nas chaves, vendo suas contagens, se há erros de digitação, etc. Por uma questão de tempo, vamos pular essa fase.\n Se as nossas chaves forem perfeitinhas, e inclusive tiverem o mesmo nome nas duas tabelas, basta invocar o tipo de join desejado.\n# Vamos dar uma enxugada no flights para poder ver o efeito dos joins com maior facilidade.\rflights2 \u0026lt;- flights %\u0026gt;% select(year:day, hour, origin, dest, tailnum, carrier)\rflights2\r ## # A tibble: 336,776 x 8\r## year month day hour origin dest tailnum carrier\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA ## 2 2013 1 1 5 LGA IAH N24211 UA ## 3 2013 1 1 5 JFK MIA N619AA AA ## 4 2013 1 1 5 JFK BQN N804JB B6 ## 5 2013 1 1 6 LGA ATL N668DN DL ## 6 2013 1 1 5 EWR ORD N39463 UA ## 7 2013 1 1 6 EWR FLL N516JB B6 ## 8 2013 1 1 6 LGA IAD N829AS EV ## 9 2013 1 1 6 JFK MCO N593JB B6 ## 10 2013 1 1 6 LGA ORD N3ALAA AA ## # ... with 336,766 more rows\r # Chaves perfeitas, mesmo nome nos dois bancos = natural join\rflights2 %\u0026gt;% left_join(weather) # Moleza\r ## Joining, by = c(\u0026quot;year\u0026quot;, \u0026quot;month\u0026quot;, \u0026quot;day\u0026quot;, \u0026quot;hour\u0026quot;, \u0026quot;origin\u0026quot;)\r## # A tibble: 336,776 x 18\r## year month day hour origin dest tailnum carrier temp dewp humid\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 39.0 28.0 64.4\r## 2 2013 1 1 5 LGA IAH N24211 UA 39.9 25.0 54.8\r## 3 2013 1 1 5 JFK MIA N619AA AA 39.0 27.0 61.6\r## 4 2013 1 1 5 JFK BQN N804JB B6 39.0 27.0 61.6\r## 5 2013 1 1 6 LGA ATL N668DN DL 39.9 25.0 54.8\r## 6 2013 1 1 5 EWR ORD N39463 UA 39.0 28.0 64.4\r## 7 2013 1 1 6 EWR FLL N516JB B6 37.9 28.0 67.2\r## 8 2013 1 1 6 LGA IAD N829AS EV 39.9 25.0 54.8\r## 9 2013 1 1 6 JFK MCO N593JB B6 37.9 27.0 64.3\r## 10 2013 1 1 6 LGA ORD N3ALAA AA 39.9 25.0 54.8\r## # ... with 336,766 more rows, and 7 more variables: wind_dir \u0026lt;dbl\u0026gt;,\r## # wind_speed \u0026lt;dbl\u0026gt;, wind_gust \u0026lt;dbl\u0026gt;, precip \u0026lt;dbl\u0026gt;, pressure \u0026lt;dbl\u0026gt;,\r## # visib \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r flights2 %\u0026gt;% left_join(airlines) # Moleza\r ## Joining, by = \u0026quot;carrier\u0026quot;\r## # A tibble: 336,776 x 9\r## year month day hour origin dest tailnum carrier name ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. ## 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways ## 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Airways ## 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet Airlines Inc.\r## 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Airways ## 10 2013 1 1 6 LGA ORD N3ALAA AA American Airlines Inc. ## # ... with 336,766 more rows\r # Chaves perfeitas, mas há variáveis nos dois bancos com o mesmo nome e que não são chaves\r# É necessário especificar qual a chave\rflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;)\r ## # A tibble: 336,776 x 16\r## year.x month day hour origin dest tailnum carrier year.y type ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wing mult~\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wing mult~\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wing mult~\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wing mult~\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wing mult~\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wing mult~\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000 Fixed wing mult~\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998 Fixed wing mult~\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004 Fixed wing mult~\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA \u0026lt;NA\u0026gt; ## # ... with 336,766 more rows, and 6 more variables: manufacturer \u0026lt;chr\u0026gt;,\r## # model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;, engine \u0026lt;chr\u0026gt;\r Veja que tanto flights2 quanto planes tem uma variável chamada year, mas elas significados diferentes. Em flights2 é o ano do vôo, enquanto em planes é o ano em que a aeronave entra em serviço. Na hora que fazemos o join, uma recebe o sufixo “x” e a outra “y” para a indicar a diferença. Você pode especificar o sufixo desejado para evitar confusão:\nflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;, suffix = c(\u0026quot;_flight\u0026quot;, \u0026quot;_entered_service\u0026quot;))\r ## # A tibble: 336,776 x 16\r## year_flight month day hour origin dest tailnum carrier year_entered_serv~\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 1999\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA\r## # ... with 336,766 more rows, and 7 more variables: type \u0026lt;chr\u0026gt;,\r## # manufacturer \u0026lt;chr\u0026gt;, model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;,\r## # engine \u0026lt;chr\u0026gt;\r Um aviso: cuidado com os produtos cartesianos. Não há um bom exemplo aqui no caso do flights porque o banco já está limpinho, mas se você especificar chaves com uma relação “muitos para muitos,” ele vai registrar no banco novo uma linha para cada combinação possível de variáveis. Em bancos maiores, isso geralmente estoura sua memória e trava o R. Veja este pequeno exemplo de brinquedo.\nx \u0026lt;- tribble(\r~key, ~val_x,\r1, \u0026quot;x1\u0026quot;,\r2, \u0026quot;x2\u0026quot;,\r2, \u0026quot;x3\u0026quot;,\r3, \u0026quot;x4\u0026quot;\r)\ry \u0026lt;- tribble(\r~key, ~val_y,\r1, \u0026quot;y1\u0026quot;,\r2, \u0026quot;y2\u0026quot;,\r2, \u0026quot;y3\u0026quot;,\r3, \u0026quot;y4\u0026quot;\r)\rleft_join(x, y, by = \u0026quot;key\u0026quot;)\r ## # A tibble: 6 x 3\r## key val_x val_y\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 x1 y1 ## 2 2 x2 y2 ## 3 2 x2 y3 ## 4 2 x3 y2 ## 5 2 x3 y3 ## 6 3 x4 y4\r Veja que no resultado foi criada uma linha para cada combinação de val_x e val_y que tem a mesma chave repetida. Podem até existir situações em que isso seja o que você quer mesmo, mas na minha experiência até o momento isso é problema com as chaves duplicadas e é sinal de que há algo errado.\nMas peraí, se você falou que tem 4 tipos de join, porque só dá exemplo de left_join?\nNa prática, operações relacionais são feitas de forma intencional: escolhemos bancos de dados de acordo com o valor que atribuímos a informação presente nele e pinçamos informações relacionadas de outros lugares para adicionar aquilo que é nosso foco. Por isso, na maioria dos casos, o left_join é o mais usual, porque preserva todas as informações do meu banco x e adiciona apenas as informações do banco y que combinaram com sucesso. Isso garante que eu não vou perder nenhuma informação do meu banco principal.\nPra encerrar essa parte, mais exemplos de joins.\n# Minhas chaves tem nomes diferentes, então uso um vetor do tipo c(\u0026quot;chave_x\u0026quot; = \u0026quot;chave_y\u0026quot;)\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;dest\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Georg~ 30.0 -95.3 97\r## 2 2013 1 1 5 LGA IAH N24211 UA Georg~ 30.0 -95.3 97\r## 3 2013 1 1 5 JFK MIA N619AA AA Miami~ 25.8 -80.3 8\r## 4 2013 1 1 5 JFK BQN N804JB B6 \u0026lt;NA\u0026gt; NA NA NA\r## 5 2013 1 1 6 LGA ATL N668DN DL Harts~ 33.6 -84.4 1026\r## 6 2013 1 1 5 EWR ORD N39463 UA Chica~ 42.0 -87.9 668\r## 7 2013 1 1 6 EWR FLL N516JB B6 Fort ~ 26.1 -80.2 9\r## 8 2013 1 1 6 LGA IAD N829AS EV Washi~ 38.9 -77.5 313\r## 9 2013 1 1 6 JFK MCO N593JB B6 Orlan~ 28.4 -81.3 96\r## 10 2013 1 1 6 LGA ORD N3ALAA AA Chica~ 42.0 -87.9 668\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r # Mesma coisa, só que agora juntando as informações da origem ao invés do destino\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;origin\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Newar~ 40.7 -74.2 18\r## 2 2013 1 1 5 LGA IAH N24211 UA La Gu~ 40.8 -73.9 22\r## 3 2013 1 1 5 JFK MIA N619AA AA John ~ 40.6 -73.8 13\r## 4 2013 1 1 5 JFK BQN N804JB B6 John ~ 40.6 -73.8 13\r## 5 2013 1 1 6 LGA ATL N668DN DL La Gu~ 40.8 -73.9 22\r## 6 2013 1 1 5 EWR ORD N39463 UA Newar~ 40.7 -74.2 18\r## 7 2013 1 1 6 EWR FLL N516JB B6 Newar~ 40.7 -74.2 18\r## 8 2013 1 1 6 LGA IAD N829AS EV La Gu~ 40.8 -73.9 22\r## 9 2013 1 1 6 JFK MCO N593JB B6 John ~ 40.6 -73.8 13\r## 10 2013 1 1 6 LGA ORD N3ALAA AA La Gu~ 40.8 -73.9 22\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r O assunto, obviamente, não pára por aí. Nos livros vocês encontrarão mais exemplos e funções, como é o caso do semi_join e do anti_join e das operações “set,” intersect, union e setdiff, mas isso fica pra vocês explorarem por conta própria e virem tirar as dúvidas depois!\nstringr stringr contém uma família de funções, todas começadas em str_, cuja principal preocupação é a consistência. As funções do base para strings são muito úteis, porém, seus argumentos estão numa ordem um pouco estranha, algumas funções são vetorizadas e outras não. Quando você se acostuma, até que não é tão ruim, mas voltando para o assunto discutido ontem de tornar o seu código mais legível, é interessante ter a simplicidade oferecida.\nBasicão da string Como este curso já é pra praticantes de R, vou pular algumas coisas muito básicas de string, vamos ao que interessa.\nDeterminados caracteres tem um significado especial dentro das strings. Quem já tentou copiar e colar um caminho de arquivo do Windows pro R sabe disso. Então, nesses casos, é precisar “escapar” caracteres. Por exemplo, se você quiser escrever aspas, você usar a contrabarra \\ para “escapar” um caractere.\naspa_simples \u0026lt;- '\\'' # ou \u0026quot;'\u0026quot;\raspa_dupla \u0026lt;- \u0026quot;\\\u0026quot;\u0026quot; # ou '\u0026quot;'\r A regra do escape é simples, então se você quiser colocar uma contrabarra \\\nx \u0026lt;- c(\u0026quot;\\\\\u0026quot;, \u0026quot;\\\u0026quot;\u0026quot;)\rx\r ## [1] \u0026quot;\\\\\u0026quot; \u0026quot;\\\u0026quot;\u0026quot;\r writeLines(x)\r ## \\\r## \u0026quot;\r Outros caracteres especiais úteis: \u0026quot;\\n\u0026quot; para pular uma linha, \\t para Tab. Você pode ver os outros na ajuda das aspas \u0026quot;, basta digitar no console ?\u0026quot;'\u0026quot; ou ?'\u0026quot;'.\nOutra coisa que dá pra fazer, se você precisar incluir um caractere distinto, é usar unicode:\nx \u0026lt;- \u0026quot;\\u00b5\u0026quot;\rx\r ## [1] \u0026quot;µ\u0026quot;\r Ok, mas e o pacote stringr? Bem, ele tem o intuito de facilitar e dar consistência, então, todas as funções do pacote começam com as iniciais str_ justamente para serem utilizadas com o autocompletar do RStudio, que pode ser acessada com os atalhos Ctrl + Espaço ou Tab. Vamos ver agora alguns exemplos de funções do pacote.\nComprimento da string em caracteres:\nlibrary(stringr)\r# No RStudio, basta digitar 'str_' e apertar Tab ou Ctrl + Espaço\rx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_length(x)\r ## [1] 17\r x \u0026lt;- c(\u0026quot;Ministro Sinistro\u0026quot;, \u0026quot;Abelha Gulosa\u0026quot;, \u0026quot;p\u0026quot;)\rstr_length(x)\r ## [1] 17 13 1\r Concatenação de strings:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;xyz\u0026quot;\r Use o argumento sep para definir caracteres que aparecerão entre as strings originais:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;, sep = \u0026quot; + \u0026quot;)\r ## [1] \u0026quot;x + y + z\u0026quot;\r Você pode trabalhar com strings que contém NAs:\nx \u0026lt;- c(\u0026quot;abc\u0026quot;, NA)\rstr_c(\u0026quot;|-\u0026quot;, x, \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; NA\r str_c(\u0026quot;|-\u0026quot;, str_replace_na(x), \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; \u0026quot;|-NA-|\u0026quot;\r str_c é uma função vetorizada e automaticamente recicla seus argumentos pra ter o tamanho do maior:\n# Eu na graduação\rstr_c(\u0026quot;Profe, me dá mais \u0026quot;, c(\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;), \u0026quot; semanas pra entregar, por favor!\u0026quot;)\r ## [1] \u0026quot;Profe, me dá mais 1 semanas pra entregar, por favor!\u0026quot;\r## [2] \u0026quot;Profe, me dá mais 2 semanas pra entregar, por favor!\u0026quot;\r## [3] \u0026quot;Profe, me dá mais 3 semanas pra entregar, por favor!\u0026quot;\r # Eu de manhã\rstr_c(\u0026quot;Só mais \u0026quot;, c(\u0026quot;5\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;30\u0026quot;), \u0026quot; minutinhos e eu acordo!\u0026quot;)\r ## [1] \u0026quot;Só mais 5 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 10 minutinhos e eu acordo!\u0026quot;\r## [3] \u0026quot;Só mais 20 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 30 minutinhos e eu acordo!\u0026quot;\r Se algum dos objetos passados para str_c tiver tamanho 0, ele é descartado. Útil para usar com testes lógicos.\nnome \u0026lt;- \u0026quot;Vinicius\u0026quot;\rsobrenome \u0026lt;- \u0026quot;Maia\u0026quot;\rtem_nome_do_meio \u0026lt;- FALSE\rstr_c(\r\u0026quot;Meu nome é \u0026quot;, nome, \u0026quot; \u0026quot;,\r# isso aqui retorna um vetor tamanho 0\rif (tem_nome_do_meio) \u0026quot; de Souza\u0026quot;, sobrenome,\r\u0026quot;.\u0026quot;\r)\r ## [1] \u0026quot;Meu nome é Vinicius Maia.\u0026quot;\r Conhecedores de paste reconhecerão o argumento collapse, que serve para transformar vetores de strings em uma única string.\nstr_c(c(\u0026quot;Natália\u0026quot;, \u0026quot;Martins\u0026quot;, \u0026quot;Arruda\u0026quot;), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;Natália Martins Arruda\u0026quot;\r De forma similar, conhecedores de substring deverão imediatamente reconhecer essa:\nx \u0026lt;- c(\u0026quot;Maçã\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Abacaxi\u0026quot;)\rstr_sub(x, 1, 3)\r ## [1] \u0026quot;Maç\u0026quot; \u0026quot;Ban\u0026quot; \u0026quot;Aba\u0026quot;\r str_sub(x, -3, -1)\r ## [1] \u0026quot;açã\u0026quot; \u0026quot;ana\u0026quot; \u0026quot;axi\u0026quot;\r str_sub não vai dar erro se a string for muito curta:\nstr_sub(\u0026quot;a\u0026quot;, 1, 5)\r ## [1] \u0026quot;a\u0026quot;\r Dá pra usar a forma str_sub(x) \u0026lt;- para modificar partes de strings\nstr_sub(x, 1, 1) \u0026lt;- str_to_lower(str_sub(x, 1, 1))\rx\r ## [1] \u0026quot;maçã\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;abacaxi\u0026quot;\r Note o uso de str_to_lower para mudar para minúsculas. O contrário é str_to_upper, também há uma para títulos, str_to_title, e para a primeira letra de uma frase, str_to_sentence.\nx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_to_lower(x)\r ## [1] \u0026quot;ministro sinistro\u0026quot;\r str_to_upper(x)\r ## [1] \u0026quot;MINISTRO SINISTRO\u0026quot;\r str_to_sentence(x)\r ## [1] \u0026quot;Ministro sinistro\u0026quot;\r str_to_title(x)\r ## [1] \u0026quot;Ministro Sinistro\u0026quot;\r Como vimos no readr, algumas questões relacionadas a strings dependem da língua, ou, na linguagem do pacote, são “locale dependent.” Por isso nas funções onde isso é relevante, o argumento se chama locale. Isso não é super relevante para quem trabalha com o inglês ou as línguas do oeste europeu, considerando que a maioria das línguas tem raízes similares, mas pode ser muito importante para outros idiomas. Vejamos este exemplo com a mudança da ordem das strings.\nx \u0026lt;- c(\u0026quot;abacaxi\u0026quot;, \u0026quot;escarola\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_sort(x, locale = \u0026quot;en\u0026quot;) # Inglês\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;escarola\u0026quot;\r str_sort(x, locale = \u0026quot;haw\u0026quot;) # Havaiano\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;escarola\u0026quot; \u0026quot;banana\u0026quot;\r É justamente para esses casos que str_sort e str_order oferecem a alternativa de você especificar o locale.\nTrabalhando com padrões e “expressões regulares” Expressões regulares são quase uma linguagem de programação em si, aqui, vamos dar uma passada muito rápida e ver alguns exemplos simples. São uma ferramenta muito útil, mas talvez não do interesse de todos.\nBasicamente, a ideia é fazer uma pesquisa na string, em busca de um padrão específico. Pode ser uma palavra, um espaço em branco, uma quebra de linha. Pode ficar muito complexo ou ser bem básico. O nosso objetivo aqui é que todos tenham a capacidade de trabalhar com padrões simples para corrigir inconsistências em bancos de dados, como no exemplo da aula anterior das colunas do dataset da OMS.\nPara visualizar padrões, vamos usar duas helper functions, str_view e str_view_all.\nx \u0026lt;- c(\u0026quot;mamão\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;ananas\u0026quot;)\rstr_view(x, \u0026quot;an\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rO resultado sai na aba “Viewer” do seu RStudio.\nO primeiro padrão que podemos usar é o ., que identifica qualquer caractere. As vezes na documentação esse tipo de padrão genérico é chamado de “wildcard.”\nstr_view(x, \u0026quot;.a.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rA forma de ler essa operação é: “Identifique qualquer conjunto de caracteres que tenha uma letra a no meio deles.”\nSe você quiser identificar um . numa string, você precisa usar o escape \\. Porém, a barra também é um escape! Então, ao escrever expressões regulares, precisamos usar \\\\. Veja:\ndot \u0026lt;- \u0026quot;.\u0026quot;\rcat(dot)\r ## .\r # erro\rdot \u0026lt;- \u0026quot;\\.\u0026quot;\r ## Error: '\\.' é uma seqüência de escape não reconhecida na cadeia de caracteres começando com \u0026quot;\u0026quot;\\.\u0026quot;\r # agora sim\rdot \u0026lt;- \u0026quot;\\\\.\u0026quot;\rcat(dot)\r ## \\.\r Agora em um exemplo:\nx \u0026lt;- c(\u0026quot;Praia.\u0026quot;, \u0026quot;Agora.\u0026quot;, \u0026quot;Ou.\u0026quot;, \u0026quot;Me.\u0026quot;, \u0026quot;Rebelo.\u0026quot;)\rstr_view(x, \u0026quot;a\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;u\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;o\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rTá, mas se a contrabarra é utilizada para denotar uma expressão regular tipo o ., como eu faço para pesquisar uma contrabarra?\nx \u0026lt;- \u0026quot;Jake Peralta é o melhor detetive\\\\gênio\u0026quot;\rcat(x)\r ## Jake Peralta é o melhor detetive\\gênio\r A solução é escapar o escape do escape, sacou?\nstr_view(x, \u0026quot;\\\\\\\\\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Jake Peralta é o melhor detetive\\\\gênio\\n\"},\"evals\":[],\"jsHooks\":[]}\rÉ enrolado mesmo…\nPara não estender muito o assunto, vamos ver vários exemplos de caracteres especiais a ser usados em expressões regulares.\n^ encontra o início de uma string\nx \u0026lt;- c(\u0026quot;maçã\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;mamão\u0026quot;)\rstr_view(x, \u0026quot;^m\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\r$ encontra o final\nstr_view(x, \u0026quot;a$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\rPara forçar a expressão a achar apenas a palavra completa, use os dois\nx \u0026lt;- c(\u0026quot;vitamina de banana\u0026quot;, \u0026quot;sundae de banana\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_view(x, \u0026quot;banana\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;^banana$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rUse classes de caracteres para encontrar genéricos\nQualquer digito:\nx \u0026lt;- \u0026quot;15 de Maio de 2021.\u0026quot;\rstr_view(x, \u0026quot;\\\\d\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer espaço em branco:\nstr_view(x, \u0026quot;\\\\s\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere de um grupo: [abc]\nstr_view(x, \u0026quot;[M]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[eM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[deM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere menos esses: [^abc]\nstr_view(x, \u0026quot;[^15]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de Maio de ]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rUsar uma classe pra evitar digitar 5 milhões de contrabarras\nstr_view(x, \u0026quot;[.]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(\u0026quot;a*c\u0026quot;, \u0026quot;[*]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n a*c\\n\"},\"evals\":[],\"jsHooks\":[]}\rVocê pode misturar strings com classes também\nx \u0026lt;- c(\u0026quot;15 de Maio de 2021.\u0026quot;, \u0026quot;16 de Maio de 2021.\u0026quot;)\rstr_view(x, \u0026quot;1[56] de Maio\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n 16 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rInfelizmente, alguns caracteres tem significado especial dentro das classes, e você tem que usar contrabarras para fugir deles: ] \\ ^ e -.\nVocê pode lidar com repetições\nx \u0026lt;- c(\u0026quot;Mariele\u0026quot;, \u0026quot;Marielle\u0026quot;, \u0026quot;Mariellle\u0026quot;, \u0026quot;Marie\u0026quot;)\rstr_view(x, \u0026quot;Mariell?e\u0026quot;) # l aparece 0 ou 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel+e\u0026quot;) # l aparece 1 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel*\u0026quot;) # l aparece 0 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{0}\u0026quot;) # l aparece exatamente 0 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1}\u0026quot;) # l aparece exatamente 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2}\u0026quot;) # l aparece exatamente 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{3}\u0026quot;) # l aparece exatamente 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,}\u0026quot;) # l aparece exatamente 1 vez ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,}\u0026quot;) # l aparece exatamente 2 vezes ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,2}\u0026quot;) # l aparece de 1 a 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,3}\u0026quot;) # l aparece de 2 a 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rEsse assunto é enorme, e ainda estamos só na superfície. Há grupos, lookarounds, e muitos outros detalhes envolvendo expressões regulares, e vocês podem consultar os livros de referência para mergulhar mais fundo. Mas vamos parar por aqui para nos concentrar no que interessa.\nEm geral, temos um banco de dados com strings problemáticas, tipo erros de digitação, inconsistências etc. O primeiro passo, em geral, é detectar os problemas.\nx \u0026lt;- c(\u0026quot;São Paulo\u0026quot;, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;Sao Paulo\u0026quot;, \u0026quot;sp\u0026quot;, \u0026quot;SP\u0026quot;, \u0026quot;Sp\u0026quot;)\rstr_detect(x, \u0026quot;ã\u0026quot;)\r ## [1] TRUE FALSE FALSE FALSE FALSE FALSE\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] FALSE FALSE FALSE TRUE TRUE TRUE\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;)\r ## [1] FALSE TRUE TRUE FALSE FALSE FALSE\r Você pode se utilizar do fato da resposta ser um vetor lógico para descobrir quantos problemas você tem\n# Contagens\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% sum()\r ## [1] 1\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% sum()\r ## [1] 3\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% sum()\r ## [1] 2\r # Proporções\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.1666667\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.5\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.3333333\r Depois de detectar seus problemas, você pode querer extrair uma parte dos seus casos: use str_subset\nstr_subset(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Em geral, no entanto, você vai estar trabalhando num data frame. Então use dplyr::filter e str_detect.\ndf \u0026lt;- tibble::tibble(\rnome = c(\u0026quot;Marcos\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;cebolinha\u0026quot;, \u0026quot;Beiçola\u0026quot;, \u0026quot;nadir\u0026quot;, \u0026quot;Monica\u0026quot;),\ruf = x,\rdtnsc = c(\u0026quot;15 de Maio de 1980\u0026quot;, \u0026quot;1 de Jan de 2001\u0026quot;, \u0026quot;6 de Ago de 1993\u0026quot;, \u0026quot;20 de Abril de 1964\u0026quot;, \u0026quot;24 de Nov de 1975\u0026quot;, \u0026quot;14 de Dezembro de 1997\u0026quot;)\r)\rdf %\u0026gt;% dplyr::filter(str_detect(uf, \u0026quot;[Ss][Pp]\u0026quot;))\r ## # A tibble: 3 x 3\r## nome uf dtnsc ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Beiçola sp 20 de Abril de 1964 ## 2 nadir SP 24 de Nov de 1975 ## 3 Monica Sp 14 de Dezembro de 1997\r Você pode contar quantos matches você tem str_count\nstr_count(x, \u0026quot;o\u0026quot;)\r ## [1] 2 0 2 0 0 0\r str_count(x, \u0026quot;[Oo]\u0026quot;)\r ## [1] 2 2 2 0 0 0\r # e usar num data frame\rdf %\u0026gt;% dplyr::mutate(vogais = str_count(uf, \u0026quot;[aeiou]\u0026quot;),\rconsoantes = str_count(uf, \u0026quot;[^aeiou]\u0026quot;))\r ## # A tibble: 6 x 5\r## nome uf dtnsc vogais consoantes\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 4 5\r## 2 rogério SAO PAULO 1 de Jan de 2001 0 9\r## 3 cebolinha Sao Paulo 6 de Ago de 1993 5 4\r## 4 Beiçola sp 20 de Abril de 1964 0 2\r## 5 nadir SP 24 de Nov de 1975 0 2\r## 6 Monica Sp 14 de Dezembro de 1997 0 2\r Você pode extrair str_extract as informações que você quer\nstr_extract(df$dtnsc, \u0026quot;\\\\d+\u0026quot;)\r ## [1] \u0026quot;15\u0026quot; \u0026quot;1\u0026quot; \u0026quot;6\u0026quot; \u0026quot;20\u0026quot; \u0026quot;24\u0026quot; \u0026quot;14\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\d+$\u0026quot;)\r ## [1] \u0026quot;1980\u0026quot; \u0026quot;2001\u0026quot; \u0026quot;1993\u0026quot; \u0026quot;1964\u0026quot; \u0026quot;1975\u0026quot; \u0026quot;1997\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;)\r ## [1] \u0026quot; de Maio de \u0026quot; \u0026quot; de Jan de \u0026quot; \u0026quot; de Ago de \u0026quot; \u0026quot; de Abril de \u0026quot; ## [5] \u0026quot; de Nov de \u0026quot; \u0026quot; de Dezembro de \u0026quot;\r # Na tibble\rdf %\u0026gt;% dplyr::mutate(\rdia = str_extract(dtnsc, \u0026quot;\\\\d+\u0026quot;),\rmes = str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;),\rano = str_extract(dtnsc, \u0026quot;\\\\d+$\u0026quot;))\r ## # A tibble: 6 x 6\r## nome uf dtnsc dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 15 \u0026quot; de Maio de \u0026quot; 1980 ## 2 rogério SAO PAULO 1 de Jan de 2001 1 \u0026quot; de Jan de \u0026quot; 2001 ## 3 cebolinha Sao Paulo 6 de Ago de 1993 6 \u0026quot; de Ago de \u0026quot; 1993 ## 4 Beiçola sp 20 de Abril de 1964 20 \u0026quot; de Abril de \u0026quot; 1964 ## 5 nadir SP 24 de Nov de 1975 24 \u0026quot; de Nov de \u0026quot; 1975 ## 6 Monica Sp 14 de Dezembro de 1997 14 \u0026quot; de Dezembro de \u0026quot; 1997\r # Melhor ainda\rdf %\u0026gt;% tidyr::extract(\rdtnsc, c(\u0026quot;dia\u0026quot;, \u0026quot;mes\u0026quot;, \u0026quot;ano\u0026quot;), regex = \u0026quot;(\\\\d+) de (\\\\D+) de (\\\\d+$)\u0026quot;\r)\r ## # A tibble: 6 x 5\r## nome uf dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 Maio 1980 ## 2 rogério SAO PAULO 1 Jan 2001 ## 3 cebolinha Sao Paulo 6 Ago 1993 ## 4 Beiçola sp 20 Abril 1964 ## 5 nadir SP 24 Nov 1975 ## 6 Monica Sp 14 Dezembro 1997\r Similar a ideia de extração, podemos substituir com str_replace\nstr_replace(x, \u0026quot;[Ss][Pp]\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot;\r str_replace(x, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r str_replace(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Tanto str_extract quanto str_replace substituem apenas a primeira marca, se você quiser substituir todas, utilize str_..._all\nstr_extract_all(x, \u0026quot;a\u0026quot;, simplify = TRUE)\r ## [,1] [,2]\r## [1,] \u0026quot;a\u0026quot; \u0026quot;\u0026quot; ## [2,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [3,] \u0026quot;a\u0026quot; \u0026quot;a\u0026quot; ## [4,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [5,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [6,] \u0026quot;\u0026quot; \u0026quot;\u0026quot;\r str_replace_all(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Pãulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r O assunto não acaba, mas vamos parar por aqui. Novamente, recomendo consultarem os materiais para quem quiser ir mais a fundo nisso. É bem capaz de no andar da carruagem aparecerem outros exemplos nos quais a manipulação de strings pode ser importante.\nforcats Esse é um pacotinho muito que facilita bastante a vida de quem trabalha com variável categórica, ou, no R, os factors. Ele consiste em uma série de “helper functions” baseadas em funções do base e do stats que trabalham com os componentes de um factor, ou seja, seus levels e seus values.\nImagino que todos aqui estão familiarizados com fatores e com a sua criação, então vamos direto ao que interessa. Educação é um vetor de caracteres que vem com os níveis educacionais de um população.\neducacao \u0026lt;- c(\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;,\r\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;)\rx \u0026lt;- factor(educacao, levels = c(\u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;))\rx\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Fundamental Médio Superior\r levels(x)\r ## [1] \u0026quot;Fundamental\u0026quot; \u0026quot;Médio\u0026quot; \u0026quot;Superior\u0026quot;\r relevel(x, \u0026quot;Superior\u0026quot;)\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Superior Fundamental Médio\r Em geral, diversas tarefas envolvendo fatores no base não são muito simples. Por exemplo, se eu quiser modificar os nomes dos níveis de um fator depois dele já estar criado, modificar a ordem dos níveis, ou agrupar diversos níveis em um só. forcats vem justamente oferecer soluções nesse sentido. Normalmente, estamos trabalhando com bancos de dados, e não com um vetor solitário, por isso, vamos usar o gss_cat, uma amostra do General Social Survey aplicado pelo NORC e pela Universidade de Chicago, que vem no pacote forcats.\nlibrary(forcats)\rgss_cat\r ## # A tibble: 21,483 x 9\r## year marital age race rincome partyid relig denom tvhours\r## \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 2000 Never ma~ 26 White $8000 to ~ Ind,near r~ Protesta~ Souther~ 12\r## 2 2000 Divorced 48 White $8000 to ~ Not str re~ Protesta~ Baptist~ NA\r## 3 2000 Widowed 67 White Not appli~ Independent Protesta~ No deno~ 2\r## 4 2000 Never ma~ 39 White Not appli~ Ind,near r~ Orthodox~ Not app~ 4\r## 5 2000 Divorced 25 White Not appli~ Not str de~ None Not app~ 1\r## 6 2000 Married 25 White $20000 - ~ Strong dem~ Protesta~ Souther~ NA\r## 7 2000 Never ma~ 36 White $25000 or~ Not str re~ Christian Not app~ 3\r## 8 2000 Divorced 44 White $7000 to ~ Ind,near d~ Protesta~ Luthera~ NA\r## 9 2000 Married 44 White $25000 or~ Not str de~ Protesta~ Other 0\r## 10 2000 Married 47 White $25000 or~ Strong rep~ Protesta~ Souther~ 3\r## # ... with 21,473 more rows\r Contagens\nUma das primeiras coisas que interessa ao lidar com fatores, é obter suas contagens, o que é algo muito simples utilizando a gramática do dplyr.\n# Função count\rgss_cat %\u0026gt;% count(race)\r ## # A tibble: 3 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% count(race, .drop = FALSE)\r ## # A tibble: 4 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r## 4 Not applicable 0\r # Visualização com ggplot\rlibrary(ggplot2)\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar()\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar() + scale_x_discrete(drop = FALSE)\r Note o uso do argumento drop nos dois casos, para indicar que casos com 0 observações não devem ser removidos do resultado.\nModificando a ordem A segunda tarefa comum quando trabalhamos com fatores é modificar a ordem em que eles aparecem. Não é tanto o caso quando trabalhamos com fatores ordenados, mas diversos tipos de variáveis categóricas não possuem uma ordem lógica pre-definida e, mesmo assim, nos interessa apresentá-los de acordo com uma determinada hierarquia visual, seja porque eles são os mais frequentes ou porque queremos destacar algum elemento em particular. forcats implementa diversas estratégias de reordenamento de fatores. Vamos vê-las brevemente.\nDigamos que eu queira saber o tempo médio de televisão assistida por membros das diversas religiões. Eu poderia produzir um sumário e depois plotar isso num gráfico.\nrelig_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(relig) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r O display está técnicamente correto, mas a forma desorganizada dos níveis no eixo Y dificulta a nossa capacidade de fazer comparações. Talvez fosse mais interessante ordenar este resultado por ordem decrescente do número de horas de tv. Mas, como fazer isso de forma direta, sem precisar realizar diversas computações?\n# Direto no plot\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, fct_reorder(relig, tvhours))) + geom_point()\r # Antes de passar o data.frame para a plotagem\rrelig_summary %\u0026gt;% mutate(relig = fct_reorder(relig, tvhours)) %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r Note como posso aplicar a transformação diretamente na variável durante o processo de plotagem, ou antes, e uma invocação de mutate. Na minha opinião, o segundo jeito é o mais adequado, por duas razões: é mais fácil de digitar, inserir e retirar do código e é mais fácil para um leitor identificar que uma transformação foi feita na variável plotada.\nOutro exemplo: que tal exarminarmos a relação entre a idade e a renda declarada? Primeiro, é preciso construir um sumário, parecido com o primeiro:\nrincome_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(rincome) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrincome_summary %\u0026gt;% mutate(rincome = fct_reorder(rincome, age)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Aqui, o reordenamento das variáveis de acordo com a idade não faz muito sentido, porque os níveis de renda tem uma ordem própria. Nesse caso, não é recomendado utilizar fct_reorder.\nrincome_summary %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Só que ao plotar, notamos um problema: a categoria “Not applicable” ficou primeiro e isso desorganiza visualmente nosso gráfico. Sem problema! Utilizamos fct_relevel para modificar a ordem de uma variável arbitrariamente. O padrão é colocar pro começo (Parecido com o comportamento de stats::relevel), mas você pode especificar outra posição.\nrincome_summary %\u0026gt;% mutate(rincome = fct_relevel(rincome, \u0026quot;Not applicable\u0026quot;)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Notem como nos exemplos acima, o uso do %\u0026gt;% nos permite alterar partes do nosso código de maneira interativa para chegar no resultado desejado.\nOutro tipo de mudança de ordem interessante ocorre quando temos uma terceira “dimensão” no nosso gráfico. Em geral, utilizamos cores, formas ou linhas quebradas para diferenciar entre categorias e gostaríamos que a nossa legenda acompanhasse a tendência do gráfico. Compare:\nby_age \u0026lt;- gss_cat %\u0026gt;%\rfilter(!is.na(age)) %\u0026gt;%\rcount(age, marital) %\u0026gt;%\rgroup_by(age) %\u0026gt;%\rmutate(prop = n / sum(n))\r# Sem alteração na ordem\rby_age %\u0026gt;% ggplot(aes(age, prop, colour = marital)) +\rgeom_line(na.rm = TRUE)\r # Com alteração na ordem\rggplot(by_age, aes(age, prop, colour = fct_reorder2(marital, age, prop))) +\rgeom_line() +\rlabs(colour = \u0026quot;marital\u0026quot;)\r No caso de fct_reorder2, é melhor fazer a alteração de ordem dentro da função gráfica, pois dentro uma invocação de mutate, ela não funcionou durante meus testes.\nPor último, podemos querer ordenar um gráfico de barras de acordo com a frequência das categorias, o que podemos fazer com fct_infreq e fct_rev (opcional).\ngss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r # OU\rgss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq() %\u0026gt;% fct_rev()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r Notem o uso do pipe na hora de modificar a variável “marital.”\nModificando os níveis O outro tipo de operação bastante comum é a alteração nos níves do fator. Em geral, queremos que os nossos níveis sejam representativos das nossas categorias de análise, sejam de fácil leitura e entendimento e contenham um número significativo de observações. Por essa razão, frequentemente precisamos alterar os rótulos, agrupar categorias, etc.\nVejamos o exemplo da variável partyid, que registra a identificação do entrevistado com os partidos políticos dos EUA.\ngss_cat %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 154\r## 2 Don't know 1\r## 3 Other party 393\r## 4 Strong republican 2314\r## 5 Not str republican 3032\r## 6 Ind,near rep 1791\r## 7 Independent 4119\r## 8 Ind,near dem 2499\r## 9 Not str democrat 3690\r## 10 Strong democrat 3490\r Vamos supor que, por qualquer motivo, essa forma de representação das categorias não nos satisfaz. Vejamos algumas das ferramentas que podemos utilizar para modificar esse fator.\nPodemos, simplesmente, reescrever essas categorias de forma mais completa:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r\u0026quot;Outro partido\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Não sei\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Sem resposta\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Sem resposta 154\r## 2 Não sei 1\r## 3 Outro partido 393\r## 4 Republicano, forte 2314\r## 5 Republicano, fraco 3032\r## 6 Independente, próx. repub. 1791\r## 7 Independente 4119\r## 8 Independente, próx. democ. 2499\r## 9 Democrata, fraco 3690\r## 10 Democrata, forte 3490\r A função utilizada é fct_recode e ela é a mais genérica e flexível de todas, porém, exige que cada nível seja modificado individualmente. Dentro dela, é possível agrupar vários níveis associando vários níveis antigos a um mesmo nível novo. Veja o exemplo:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r# Note o nome\r\u0026quot;Outro\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 8 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano, forte 2314\r## 3 Republicano, fraco 3032\r## 4 Independente, próx. repub. 1791\r## 5 Independente 4119\r## 6 Independente, próx. democ. 2499\r## 7 Democrata, fraco 3690\r## 8 Democrata, forte 3490\r Se você quiser recategorizar um fator que tem muitos níveis para um menor, com poucos níveis, utilize fct_collapse:\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\rOutro = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\rRepublicano = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\rIndependente = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\rDemocrata = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Repare que do lado esquerdo, nos valores novos, não foi necessário usar aspas. É preciso cuidado com essa característica dos verbos do tidyverse. Ela se chama “tidy evaluation” e está um pouco fora do escopo do curso. Basicamente, se rolar dúvida ou der erros, se for usar acentos ou algum caractere diferente, use aspas.\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\r\u0026quot;Outro\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\r\u0026quot;Republicano\u0026quot; = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\r\u0026quot;Independente\u0026quot; = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\r\u0026quot;Democrata\u0026quot; = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Outro tipo de mudança importante no número de níveis é agrupar os níveis menos frequentes, por exemplo, para produzir uma visualização que dê maior destaque aos níveis mais frequentes. Esse é o trabalho de fct_lump.\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Other 913\r Note que usando o argumento n eu indico quantos níveis eu quero. No caso, escolhi os 5 níveis mais frequentes e todos os outros são automáticamente agrupados na categoria “Other.” Posso mudar esse nome também:\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5, other_level = \u0026quot;Outros\u0026quot;)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Outros 913\r Exercícios   Encontre os vôos que:\n Atrasaram mais de duas horas Com destino a Houston (IAH ou HOU) Operados pela United, American ou Delta Decolaram entre julho e setembro Chegaram com mais de duas horas de atraso, mas não decolaram com atraso Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo Decolaram entre a meia-noite e 6 da manhã (inclusive)    Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).\n  Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.\n  As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.\n  O que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?\n  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: “150,” “219,” “312,” “471.” Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;115\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;118\u0026quot; \u0026quot;116\u0026quot; \u0026quot;100\u0026quot; \u0026quot;108\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;103\u0026quot;\r## [13] \u0026quot;116\u0026quot; \u0026quot;111\u0026quot; \u0026quot;111\u0026quot; \u0026quot;115\u0026quot; \u0026quot;114\u0026quot; \u0026quot;102\u0026quot; \u0026quot;116\u0026quot; \u0026quot;103\u0026quot; \u0026quot;120\u0026quot; \u0026quot;115\u0026quot; \u0026quot;123\u0026quot; \u0026quot;103\u0026quot;\r## [25] \u0026quot;119\u0026quot; \u0026quot;230\u0026quot; \u0026quot;228\u0026quot; \u0026quot;225\u0026quot; \u0026quot;214\u0026quot; \u0026quot;225\u0026quot; \u0026quot;206\u0026quot; \u0026quot;207\u0026quot; \u0026quot;208\u0026quot; \u0026quot;202\u0026quot; \u0026quot;210\u0026quot; \u0026quot;229\u0026quot;\r## [37] \u0026quot;204\u0026quot; \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;218\u0026quot; \u0026quot;223\u0026quot; \u0026quot;221\u0026quot; \u0026quot;205\u0026quot; \u0026quot;214\u0026quot; \u0026quot;220\u0026quot; \u0026quot;227\u0026quot; \u0026quot;202\u0026quot; \u0026quot;224\u0026quot;\r## [49] \u0026quot;214\u0026quot; \u0026quot;201\u0026quot; \u0026quot;305\u0026quot; \u0026quot;310\u0026quot; \u0026quot;309\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;303\u0026quot; \u0026quot;312\u0026quot; \u0026quot;310\u0026quot;\r## [61] \u0026quot;303\u0026quot; \u0026quot;302\u0026quot; \u0026quot;305\u0026quot; \u0026quot;303\u0026quot; \u0026quot;304\u0026quot; \u0026quot;306\u0026quot; \u0026quot;309\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;309\u0026quot; \u0026quot;306\u0026quot; \u0026quot;311\u0026quot;\r## [73] \u0026quot;306\u0026quot; \u0026quot;307\u0026quot; \u0026quot;310\u0026quot; \u0026quot;417\u0026quot; \u0026quot;477\u0026quot; \u0026quot;470\u0026quot; \u0026quot;493\u0026quot; \u0026quot;414\u0026quot; \u0026quot;446\u0026quot; \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;476\u0026quot;\r## [85] \u0026quot;432\u0026quot; \u0026quot;490\u0026quot; \u0026quot;499\u0026quot; \u0026quot;429\u0026quot; \u0026quot;414\u0026quot; \u0026quot;455\u0026quot; \u0026quot;409\u0026quot; \u0026quot;462\u0026quot; \u0026quot;447\u0026quot; \u0026quot;483\u0026quot; \u0026quot;458\u0026quot; \u0026quot;471\u0026quot;\r## [97] \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;464\u0026quot; \u0026quot;483\u0026quot;\r  Explore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?\n  Qual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?\n  A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?\n  Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?\n  ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"fa0304036676bc16efc6e61759597fd7","permalink":"https://laddem.github.io/courses/tidyverse/dia2/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia2/","section":"courses","summary":"Operações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.","tags":null,"title":"stringr, forcats e dplyr","type":"book"},{"authors":null,"categories":null,"content":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.frame e o código utilizado para gerar o gráfico. Acho que se o termo sobrecarga infromacional não existisse, eu teria inventado ele na hora.\nAnedotas a parte, não é culpa do autor. O livro pressupõe um certo conhecimento prévio que eu não tinha quando o li pela primeira vez. Imagino que a maioria de vocês já viu gráficos na vida e até construiu um ou dois deles usando esse ou outros softwares estatísticos. O que talvez nem todos tenham claro na mente é que os gráficos são uma codificação num sistema de coordenadas das informações presentes em um banco de dados através de escalas. Vamos destrinchar um pouco melhor isso:\nSuponha que você tenha o banco de dados mpg, presente na biblioteca ggplot2.\nlibrary(ggplot2)\rmpg\r ## # A tibble: 234 x 11\r## manufacturer model displ year cyl trans drv cty hwy fl class\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 audi a4 1.8 1999 4 auto(l~ f 18 29 p comp~\r## 2 audi a4 1.8 1999 4 manual~ f 21 29 p comp~\r## 3 audi a4 2 2008 4 manual~ f 20 31 p comp~\r## 4 audi a4 2 2008 4 auto(a~ f 21 30 p comp~\r## 5 audi a4 2.8 1999 6 auto(l~ f 16 26 p comp~\r## 6 audi a4 2.8 1999 6 manual~ f 18 26 p comp~\r## 7 audi a4 3.1 2008 6 auto(a~ f 18 27 p comp~\r## 8 audi a4 quat~ 1.8 1999 4 manual~ 4 18 26 p comp~\r## 9 audi a4 quat~ 1.8 1999 4 auto(l~ 4 16 25 p comp~\r## 10 audi a4 quat~ 2 2008 4 manual~ 4 20 28 p comp~\r## # ... with 224 more rows\r De posse desse banco, você gostaria de construir um gráfico relacionando a eficiência do combustível de um carro (hwy) com o seu peso (displ). Sábio e malandro no ggplot2, você escreve o código a seguir:\nggplot(mpg, aes(displ,hwy, color = class)) +\rgeom_point()\r Mas fica a dúvida: que escolhas foram feitas no momento de traduzir a minha intenção de produzir um diagrama de dispersão (scatterplot) do peso com o consumo de gasolina para a representação gráfica diante de nós? Que unidades de medidas estão dispostas nos eixos X e Y? Qual o sistema de coordenadas no qual isto foi representado? Quem define os limites de início e fim de cada eixo? Como cada ponto recebeu a sua cor? Essas perguntas podem parecer óbvias ou tontas, dependendo da perspectiva e da experiência do usuário, mas elas são centrais para entender como construir e modificar gráficos no ggplot2.\nO pacote é inspirado pela Gramática dos Gráficos, e procura decompor o processo de produção de gráficos em uma sequência de camadas que vão se sobrepondo até chegar no objeto desejado.\n a camada dos dados e do mapeamento estético (que variáveis vão em quais eixos/escalas) a camada dos objetos geométricos (pontos, linhas, barras, etc.) a camada das escalas (natural? logarítmica? escala de cores?) a camada das facetas (mini gráficos separados por alguma característica) a camada das transformações estatísticas (distribuições de probabilidade, contagens, proporções, etc.) o sistema de coordenadas (cartesiano? polar?)  Obviamente, nem todo gráfico possui essa complexidade, e na verdade, a maioria dos gráficos que fazemos se encaixa num pequeno subgrupo de todas essas especificações, então porque toda essa complexidade?\nPorque não? Em primeiro lugar, se você está produzindo visualizações simples que cumprem seu propósito, você não precisa se preocupar com quase nada disso, os padrões do ggplot2, via de regra, se encaixam perfeitamente na maioria dos problemas e, em segundo lugar, se você sentir a necessidade de ir mais fundo e produzir visualizações mais complexas, as mesmas ferramentas que você já conhece estão a sua disposição.\nTrês gráficos para entender a mecânica do ggplot2 Scatterplots Voltemos para o nosso gráfico original, vamos decompô-lo em suas camadas como se estivéssemos construindo ele passo-a-passo:\n# Primeiro, a camada dos dados e mapeamentos estéticos\rggplot(\r# Dados\rdata = mpg,\r# Que variável vai em que eixo\rmapping = aes(x = displ, y = hwy)\r)\r Examinando a saída, vemos que ggplot desenhou um canvas com nossas variáveis, mas ainda nenhum objeto geométrico. Tudo bem, adicionamos (+) uma camada de objetos geométricos, no caso, pontos.\n# Objetos geométricos começam com \u0026quot;geom_\u0026quot;\rggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + # adicionamos\rgeom_point()\r Agora, nosso gráfico já tem uma cara de diagrama de dispersão. Mas ainda não tem as cores das classes de automóvel. Tudo bem, voltamos para a primeira camada e informamos que queremos um terceiro mapeamento estético.\n# A cor é mapeada a variável class\rggplot(data = mpg, mapping = aes(\rx = displ, y = hwy,\rcolor = class) # novo mapeamento estético\r) + # adicionamos\rgeom_point()\r Ok, chegamos no gráfico original. Mas como podem entender melhor as outras camadas? Vamos pensar, por exemplo, que talvez queiramos trabalhar a variável hwy numa escala logarítmica. Poderíamos transformar a variável original, claro, mas o ggplot2 nos permite especificar as transformações diretamente nas escalas do gráfico!\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() + # adicionando uma nova \u0026quot;camada\u0026quot;\rscale_y_continuous(trans = \u0026quot;log\u0026quot;)\r Mas você, leitor, não ficou satisfeito. Você queria era transformar a variável displ em raíz quadrada. Tudo bem:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;) # especificamos a transformação na escala de x\r Outro leitor não estava interessado nas escalas dos eixos x ou y, que são contínuas nesse caso, mas sim na seleção de cores utilizadas para representar a escala das cores. Por ser um leitor conhecedor das formas de deficiência visual cromática, ele optou pelas paletas de cores do Colorbrewer:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) # transformação da escala de cores\r Um geógrafo entrou na conversa e disse que o sistema cartesiano de coordenadas estava iludindo os leitores a pensar que a relação entre peso e consumo de combustível estava distorcida pelas diferenças entre as unidades de medida das variáveis, produzida pelo sistema cartesiano de coordenadas, então ele sugeriu que usássemos um sistema de coordenadas fixas:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) +\rcoord_fixed()\r Ficou horrível, esse geógrafo não sabe nada. Como recompensa pela sua ignorância, agora ele ocupa um cargo no primeiro escalão do Ministério da Saúde.\nOutro pesquisador estava interessado em visualizar as relações entre consumo, peso e classe, mas levando em consideração o fabricante do veículo, então, ele sugeriu que construíssemos um gráfico para cada. Você, que é preguiçoso, usou a capacidade do ggplot2 de dividir gráficos através da introdução de uma camada de facets.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + # adicionamos mais uma camada\rfacet_wrap(~manufacturer) # de facetas\r Agora, muito satisfeitos com o resultado do nosso trabalho, resolvemos incluir o gráfico numa publicação, mas do jeito que está, não dá. Então adicionamos mais algumas camadas para torná-lo apresentável.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + facet_wrap(~manufacturer) +\r# Colocamos os nomes nos eixos\rlabs(title = \u0026quot;Relação entre peso e economia de combustível de automóveis\u0026quot;,\rsubtitle = \u0026quot;Separado por categoria e fabricante\u0026quot;,\rx = \u0026quot;Peso do veículo em toneladas\u0026quot;,\ry = \u0026quot;Consumo em milhas por galão de 3,5l\u0026quot;,\rcolor = \u0026quot;Categoria\u0026quot;,\rcaption = \u0026quot;Fonte: Agência de Proteção Ambiental Estadunidense.\u0026quot;) +\r# Escolhemos um tema bonito\rtheme_light() +\r# Mudamos a posição da legenda, pra ficar mais jeitozinho\rtheme(legend.position = \u0026quot;bottom\u0026quot;)\r Pronto. Mamãe vai ficar orgulhosa.\nBrincadeiras a parte, entendendo um pouco melhor a gramática do gráfico, podemos construir nossas visualizações passo a passo, até chegar no resultado desejado.\nLineplots O segundo exemplo que quero mostrar pra vocês é a construção de gráficos com linhas. Eles são interessantes porque dão bastante dor de cabeça pra quem está começando. Vamos continuar brincando com o mpg.\nAgora que eu fiz meu diagrama de dispersão, estou interessado em começar um processo de modelagem, mas primeiro quero ter uma noção visual da relação entre as variáveis.\nggplot(mpg, aes(displ, hwy)) +\rgeom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r geom_smooth ajusta um modelo aos dados e desenha a linha com os valores preditos. Agora que temos dois objetos geométricos, talvez seja interessante ver o que acontece se eu colocar as cores das classes.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Veja que ele fez o possível para aplicar as escalas nos dois objetos geométricos. Eu pedi para geom_smooth tirar os intervalos de confiança para melhorar a visibilidade. Mas e seu eu quisesse ver a cor dos pontos, mas manter a linha de tendência geral? Você pode especificar mapeamentos estéticos gerais (na primeira camada) ou mapeamentos estéticos locais (dentro de cada camada geométrica).\nggplot(mpg, aes(displ, hwy)) + # mapeamentos gerais, se aplicam a todos os objetos\rgeom_point(aes(color = class)) + # mapeamento local, só se aplica aqui\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Ok, mas e se eu quisesse um modelo linear ao invés de um \u0026ldquo;Smoother de Loess\u0026rdquo;?\nggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Não vou entrar muito nos argumentos de cada objeto geométrico e função, vocês podem aprender isso na prática olhando a documentação das funções que são do interesse de vocês. ?geom_smooth para ver todas as possibilidades. Uma dica boa é usar geom_smooth para verificar interações entre variáveis numéricas e fatores.\nggplot(mpg, aes(displ, hwy, color = factor(cyl))) + geom_point() +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Ok, mas e se temos um gráfico de linhas mais tradicional, tipo uma série histórica?\neconomics\r ## # A tibble: 574 x 6\r## date pce pop psavert uempmed unemploy\r## \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 507. 198712 12.6 4.5 2944\r## 2 1967-08-01 510. 198911 12.6 4.7 2945\r## 3 1967-09-01 516. 199113 11.9 4.6 2958\r## 4 1967-10-01 512. 199311 12.9 4.9 3143\r## 5 1967-11-01 517. 199498 12.8 4.7 3066\r## 6 1967-12-01 525. 199657 11.8 4.8 3018\r## 7 1968-01-01 531. 199808 11.7 5.1 2878\r## 8 1968-02-01 534. 199920 12.3 4.5 3001\r## 9 1968-03-01 544. 200056 11.7 4.1 2877\r## 10 1968-04-01 544 200208 12.3 4.6 2709\r## # ... with 564 more rows\r Podemos criar um gráfico de linhas tendo como base a data (date) e alguma das variáveis registradas, como a taxa de desemprego.\nggplot(economics, aes(x = date, y = uempmed)) +\rgeom_line()\r Ou o consumo em bilhões de dólares\nggplot(economics, aes(x = date, y = pce)) +\rgeom_line()\r Ou a população\nggplot(economics, aes(x = date, y = pop)) +\rgeom_line()\r Ok, mas eu quero comparar visualmente o que ocorre com uma variável quando a outra muda. Podemos recorrer ao que aprendemos sobre mapeamentos estéticos globais e locais.\nggplot(economics, aes(x = date)) +\rgeom_line(aes(y = uempmed)) +\rgeom_line(aes(y = pce)) +\rgeom_line(aes(y = pop))\r Ficou meio ruim, porque as variável tem grandezas distintas. Podemos tentar resolver esse problema aplicando transformações na variável idade, mas meio que pra qualquer lugar onde caminhos, batemos numa parede ou noutra. Esse tipo de solução é muito frequente entre pessoas que vem do base pro ggplot2, porque no base estamos acostumado a ideia de adicionar mais objetos geométricos ao nosso gráfico original adicionando invocações à funções como lines ou text. Porém, a solução preferida no tidyverse é aplicar uma transformação no banco original de tal forma que as nossas variáveis numéricas caiam todas num par que especifica o nome da variável | e o valor dela.\nlibrary(tidyr)\reconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;)\r ## # A tibble: 2,870 x 3\r## date variavel valor\r## \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 pce 507. ## 2 1967-07-01 pop 198712 ## 3 1967-07-01 psavert 12.6\r## 4 1967-07-01 uempmed 4.5\r## 5 1967-07-01 unemploy 2944 ## 6 1967-08-01 pce 510. ## 7 1967-08-01 pop 198911 ## 8 1967-08-01 psavert 12.6\r## 9 1967-08-01 uempmed 4.7\r## 10 1967-08-01 unemploy 2945 ## # ... with 2,860 more rows\r Talvez não fique imediatamente claro para todos porque eu optei por esta solução, mas talvez essa próxima figura fale mais que mil palavras.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line() +\rfacet_wrap(~variavel, scales = \u0026quot;free_y\u0026quot;, ncol = 1)\r A ênfase em usar tidy data no tidyverse decorre do fato de que todos os pacotes são programados para usar a forma de organização do banco como uma alavanca para facilitar a análise de dados. Vejam esta outra pipeline.\n# Como vamos fazer algumas transformações nos dados, vamos carregar o dplyr aqui\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r ## The following objects are masked from 'package:stats':\r## ## filter, lag\r ## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, shape = variavel)) +\rgeom_line()\r E agora vejam um dos erros mais comuns de quem está começando:\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line()\r Ao não especificar uma separação entre grupos, o ggplot2 não interpreta meus dados! Ele simplesmente conecta as observações mais ou menos na ordem em que elas aparecem no eixo x. Para resolver esse problema, precisamos especificar grupos! Seja indiretamente, através de uma escala de cores, formas ou tipos de linha, seja diretamente através da estética groups.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, group = variavel)) +\rgeom_line()\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, linetype = variavel)) +\rgeom_line()\r Legal né?\nBarcharts Para terminar e ilustrar alguns exemplos de transformação estatística, vamos fazer alguns gráficos de barras usando o diamonds, um banco de dados para fazer a alegria das piores pessoas na história da humanidade.\ndiamonds\r ## # A tibble: 53,940 x 10\r## carat cut color clarity depth table price x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43\r## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31\r## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31\r## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63\r## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75\r## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48\r## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47\r## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53\r## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49\r## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39\r## # ... with 53,930 more rows\r Que tal um gráfico básico, do número de diamantes de acordo com a qualidade de seu corte (cut). Olhando a ajuda do ?geom_bar você vai na certeza de que você entendeu a aula e escreve o seguinte código:\nggplot(diamonds, aes(x = cut, color = cut)) +\rgeom_bar()\r E agora, você fica olhando pro seu computador com cara de tacho. O que aconteceu? Bom, no caso de geoms com duas dimensões, podem existir casos em que você quer dar mapeamentos estéticos distintos para as bordas e para o conteúdo deles. Por isso, existem as estéticas color e fill. Você pode pensar nelas como a casca do pão e o recheio.\nggplot(diamonds, aes(x = cut, fill = cut)) +\rgeom_bar()\r Mas, você ainda não está satisfeito. Pela sua ampla experiência com uma das indústrias mais sangrentas e retrógadas do planeta você entende que a qualidade do corte não é o suficiente para determinar o valor de um diamante, então você quer ver a distribuição também pelo nível de transparência do diamante, codificado na variável clarity.\nggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar()\r Esse é um primeiro passo interessante, e se tivessemos apenas duas ou três categorias, a gente poderia parar por aí. Mas no geral, para facilitar comparações, queremos poder controlar o posicionamento das barras. Isso é possível ajustando o argumento position dos geoms onde isso é necessário.\n# O padrão\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;stack\u0026quot;)\r # O certo\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;dodge\u0026quot;)\r # Empilhadas a 100%, para facilitar comparações entre categorias\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;fill\u0026quot;)\r Pode parecer jocoso, mas em 99% dos casos, o correto é você usar barras lado-a-lado, assim você visualmente pode comparar as categorias simplesmente comparando a altura das barras. Da próxima vez que você pensar em construir um gráfico de pizza, desista e faça um gráfico de barras com position = \u0026quot;dodge\u0026quot;. Seus leitores vão agradecer.\nEsse exemplo também é legal para gente olhar um pouco para a parte de transformações estatísticas nas variáveis:\ndiamonds2 \u0026lt;- diamonds %\u0026gt;% count(cut) %\u0026gt;% mutate(prop = n/sum(n))\rdiamonds2 %\u0026gt;% ggplot() +\rgeom_bar(aes(x = cut, y = prop), stat = \u0026quot;identity\u0026quot;)\r Por padrão, geom_bar já faz o primeiro passo e utiliza as contagens (stat_count) para produzir o gráfico de barras, mas eu posso mudar esse comportamento através do argumento stat. Eu também posso querer mostrar proprções ao invés de contagens de outra forma mais sucinta.\nggplot(diamonds, aes(x = cut, # ao fazer isso, eu mudo o padrão de contagens para proporções.\ry = stat(prop), # preciso especificar o grupo, se não todas as barras vão a 100%.\rgroup = 1)) +\rgeom_bar()\r Você pode construir seus gráficos a partir de transformações estatísticas ao invés de objetos geométricos:\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\rfun = median\r)\r As transformações estatísticas começam sempre com stat_ e cada uma tem um objeto geométrico padrão, que você pode mudar com o argumento geom.\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\r# Não dá pra mostrar a mediana com barras de erro, sorry\r#fun = median,\rgeom = \u0026quot;errorbar\u0026quot;\r)\r E era basicamente isso que eu tinha a dizer sobre como construir gráficos no ggplot2! Abaixo, uma seção com alguns detalhes para quem tiver interesse nessa parte de embelezamento dos gráficos.\nPerfumaria Essa seção pretende introduzir um pouco uma parte de customização dos gráficos. Frequentemente, as publicações de regras mais estritas sobre formatos, fontes, temas, etc. As opções padrão do ggplot2 podem não se acomodar, então, cabe a nós ajeitar essa reta final.\nTítulos e rótulos A melhor maneira de ajustar títulos e rótulos é através de labs, porque você resolve tudo em uma só invocação. Mas também há uma função ggtitle. Com ela, é possível setar apenas título e subtítulo.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;)\r A maioria das opções de customização mais fina está na camada theme. Internamente, cada elemento do gráfico é controlado por uma função element_, por exemplo, element_text desenha textos e recebe argumentos relativos a isso, como família da fonte, tamanho, cor, etc.\nAli, você tem um controle mais direto sobre a construção do gráfico. No que diz respeito aos rótulos, podemos mudar a fonte do título.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;))\r Usando uma síntaxe similar e os argumentos da função element_text, você pode mudar qual outro elemento textual do gráfico.\nEixos Continuando o nosso frankenstein, podemos fazer alterações nos eixos, como remover pedaços de um eixo, modificar sua forma, seu ângulo e ajustar sua posição.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;),\r# você pode remover pedaços inteiros do gráfico com \u0026quot;element_blank()\u0026quot;\raxis.ticks.y = element_blank(),\raxis.text.y = element_blank(),\raxis.title.y = element_blank(),\r# você pode mudar a orientação, angulo, posição e até formato de elementos\raxis.title = element_text(angle = 90, hjust = 1),\raxis.text.x = element_text(angle = 45, vjust = 1),\raxis.ticks.x = element_line(\rcolour = \u0026quot;royalblue3\u0026quot;,\rarrow = grid::arrow(angle = 45, length = unit(0.5, \u0026quot;cm\u0026quot;), ends = \u0026quot;first\u0026quot;, type = \u0026quot;closed\u0026quot;))\r)\r Realmente, o céu é o limite e você pode deixar o seu gráfico tão horrível quanto você quiser.\nLegendas Legendas no ggplot2 são controladas em alguns lugares diferentes. Elas são tratadas como guias (guides) no sentido de que são guias para o leitor. Vamos pegar outra variável de cores, para poder brincar com diferentes tipos de legenda.\nggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point()\r Por padrão, ele entende cilindros como numérico e faz uma barra de cores contínua. Mas eu quero uma legenda!\n# Jeito 1 - Simples e rápido\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = \u0026quot;legend\u0026quot;)\r # Jeito 2 - Posso mudar detalhes!\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;))\r # Jeito 3 - Mexendo diretamente nas escalas\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(guide = \u0026quot;legend\u0026quot;, option = \u0026quot;B\u0026quot;)\r # Jeito 3 - de novo, mas agora usando a especificação mais completa do guia\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(\rguide = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;), option = \u0026quot;B\u0026quot;)\r Em qualquer lugar onde você possa especificar guides, você pode passar o valor FALSE para remover a legenda.\n# Na camada \u0026quot;guides()\u0026quot;\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rguides(color = FALSE)\r # Na própria escala\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rscale_size(guide = FALSE)\r # Bônus = no tema, mas aí você remove todas\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rtheme(legend.position = \u0026quot;none\u0026quot;)\r Escalas Já dei uma palhinha de editar escalas, antes, então aqui vai um pouco mais de detalhe:\nggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point()\r # Mudar as cores manualmente\rcores \u0026lt;- c(\u0026quot;red\u0026quot;, \u0026quot;green\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;yellow\u0026quot;, \u0026quot;purple\u0026quot;, \u0026quot;tomato\u0026quot;, \u0026quot;wheat2\u0026quot;)\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores)\r # Mudar os tamanhos\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_radius para fazer proprcional ao raio\rscale_radius(range = c(3,6))\r ggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_size para fazer proprcional a área\rscale_size(range = c(2,4))\r É possível aplicar transformações na variável diretamente na escala, mudar o número de breaks e especificar labels e alterar os limites do gráfico manualmente.\nggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;, name = \u0026quot;Peso\u0026quot;) +\rscale_y_continuous(\rname = \u0026quot;Consumo (rodovia)\u0026quot;,\rlimits = c(0, 50),\rbreaks = c(10, 20, 30, 40, 50), labels = c(\u0026quot;fogo no clima\u0026quot;, \u0026quot;aquecimento global\u0026quot;, \u0026quot;caldeira planetária\u0026quot;, \u0026quot;deixa pra próxima geração\u0026quot;, \u0026quot;desastre em câmera lenta\u0026quot;))\r Cada escala vai ter argumentos específicos que fazem sentido em seu próprio contexto. Escalas contínuas tem argumentos para transformação estatística, escalas discretas não aceitam argumentos contínuos e etc.\nIsto encerra nossa parte de ggplot2, que tal uns exercícios pra esquentar?\nExercícios  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?\n  Utilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.\n  Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.\n  No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?\n  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  ggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r  Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.\n  Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.\n  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Tente recriar o seguinte gráfico  ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"b9e37b7e1055bb09bf3bd731ebee0b86","permalink":"https://laddem.github.io/courses/tidyverse/dia3/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia3/","section":"courses","summary":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.","tags":null,"title":"ggplot2","type":"book"},{"authors":null,"categories":null,"content":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer. Pra não ficar uma coisa solta no começo da aula, aqui uma foto de gatinho pra vocês:\nO assunto da aula de hoje é talvez um pouco mais abstrato do que as aulas anteriores. Vamos falar bastante de funções, loops e programação funcional. São termos que fazem parte do jargão da computação, mas que mesmo usuários veteranos do R como software estatístico para análise de dados podem ter pouca familiaridade. Ao invés de começar definindo o que vamos fazer, vou começar definindo o que não vamos.\n  Não vamos revisar a fundo o assunto de iterações. Os livros fazem um bom serviço, é um assunto espinhoso e não basta compreender os conceitos, tem que botar a mão na massa pra ter um entendimento não apenas da teoria, mas também para conseguir resolver os muitos problemas que aparecem quando você está construindo iterações com maior nível de complexidade.\n  Não vamos cavar fundo em todos os aspectos da programação funcional ou de todas as funções do purrr. São muitas e temos poucas horas.\n  Agora o que SIM vamos fazer é revisar muito brevemente a sintaxe de um for loop, ver em que situações a gente o utilizaria e como você pode substituir seus vários for loops por funções no purrr, com exemplos de aplicação quando possível. Se der tempo, vamos entrar um pouco na ideia de utilizar programação funcional para resolver problemas mais genéricos em que precisamos generalizar alguma tarefa.\n# Primeiro, nossos pacotes!\rlibrary(tidyverse) # o purrr já é carregado automaticamente junto com os outros,\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r # Se quiser carregar apenas o purrr, descomente a linha abaixo\r# library(purrr)\r Iterações Do ponto de vista prático, uma iteração é uma repetição uma linha de código de tal forma que apenas uma pequena parte previsível do código muda entre uma repetição e outra. Por exemplo, digamos que você vai calcular uma soma de x.\nx \u0026lt;- runif(100, 0, 1000)\rx\r ## [1] 511.21033 511.89922 773.63835 75.66633 722.47241 117.13315 951.66865\r## [8] 105.49553 770.73902 497.39858 324.68612 717.92247 527.07341 585.00887\r## [15] 380.39971 17.15150 957.58816 225.99117 653.19930 276.15361 531.60984\r## [22] 496.43149 804.00073 727.48489 86.62227 951.70058 382.33849 624.78218\r## [29] 83.78090 591.81424 473.27932 777.49061 467.26225 319.52625 14.61723\r## [36] 843.51570 657.64747 509.07023 60.33003 933.35876 91.72044 351.31833\r## [43] 595.22138 148.48688 31.02683 245.96797 491.90911 303.65395 993.94694\r## [50] 14.63012 532.77839 978.14352 985.71426 259.13229 545.54421 835.12723\r## [57] 900.39120 598.04300 85.86639 917.62820 902.74467 883.72252 511.84901\r## [64] 101.90038 346.86150 655.52290 447.19990 755.65847 546.60029 341.40437\r## [71] 550.06610 356.46386 645.91008 690.29805 11.03944 831.26283 821.42773\r## [78] 216.10993 687.41842 536.72430 833.02925 298.43149 470.50705 368.70771\r## [85] 609.66773 738.84025 675.22583 348.49183 453.19584 579.29202 190.77600\r## [92] 943.77276 22.31339 641.31284 28.05916 606.97261 344.78386 874.06792\r## [99] 974.14733 618.56387\r Esqueça, por um instante, a função sum. O cálculo da soma se dá pela soma de todos os elementos do vetor x. Então, é necessário repetir a operação de soma através da acumulação dos valores. Veja que é tudo totalmente previsível, cada nova repetição simplesmente adiciona mais um valor ao vetor original e esse valor pode ser encontrado na próxima posição de x. Esse é o típico caso de iteração. No R, a melhor prática é inicializar uma variável antes e salvar os resultados da iteração nela.\n# Inicialização\rresult \u0026lt;- x[[1]]\r# Sequência\rfor (i in 2:length(x)) {\r# Corpo\rresult \u0026lt;- result + x[[i]]\r}\r# Comparando os dois resultados\rresult\r ## [1] 51405.75\r sum(x)\r ## [1] 51405.75\r Outro exemplo de mesmo tipo é repetição de uma mesma operação em vários vetores/colunas/variáveis comuns. Por exemplo, se eu tenho um data.frame com três colunas numéricas e eu gostaria de calcular a soma de cada uma.\n# Data.frame\rdf \u0026lt;- tibble(x = rnorm(100, 50, 25),\ry = rnorm(100, 100, 25),\rz = rnorm(100, 200, 25))\r# Inicialização\rresult \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = length(df))\r# Sequência\rfor (i in seq_along(df)) {\rresult[[i]] \u0026lt;- sum(df[[i]])\r}\r# Resultado\rresult\r ## [1] 5175.084 10214.559 19979.241\r Essa é a minha revisão de 5 minutos de iteração em R usando for loops. Como já é de costume, tem muito mais. Por exemplo, existe um outro tipo de iterador no R básico chamado while, que tem um funcionamento diferente do for. Ao invés de você ter um resultado de tamanho previsível, você pode ter um resultado de tamanho desconhecido. Vou deixar o while para vocês pesquisarem porque o bom e velho for costuma cobrir a maioria dos casos de uso do cientista de dados.\nProgramação funcional Beleza, agora que já dominamos (ou não) o for loop, encontramos várias situações em que a gente gostaria de realizar a mesma operação várias vezes, mas, o for loop é como uma feijoada: é gostoso, mas é pesado. For loops em geral são \u0026ldquo;verbosos\u0026rdquo;, você precisa escrever bastante para chegar em um determinado resultado e, depois de escrever alguns, você cansa de ter que repetir todos os pedaços dele. E se você pudesse abstrair o loop para uma função? Aí você não precisaria escrever toda aquela parafernalha.\nsoma \u0026lt;- function(x) {\rresult \u0026lt;- 0\rfor (i in 1:length(x)) {\rresult \u0026lt;- result + x[[i]]\r}\rresult\r}\rsoma(x)\r ## [1] 51405.75\r Ao fazer isso, eu ganho duas vantagens:\n  Manutenção: sempre que eu precisar repetir a operação, eu consigo simplificar muito meu código. Não preciso escrever um for loop para cada soma que eu precisar fazer. Se meus requerimentos mudarem no futuro, eu só preciso mudar um pedaço de código.\n  Leitura: o humano que lê um for loop vai precisar de um minuto para se familiarizar com a operação e entender o que está sendo iterado, calculado, etc. O humano que lê \u0026ldquo;soma\u0026rdquo; sabe que ocorrerá uma soma. Você alinha a expectativa com a execução.\n  Outro exemplo.\nsoma_xyz \u0026lt;- function(x) {\rsoma_xyz \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = nrow(x))\rfor (i in seq_along(x[[1]])) {\rsoma_xyz[[i]] \u0026lt;- x[[1]][[i]] + x[[2]][[i]] + x[[3]][i]\r}\rsoma_xyz\r}\rdf$soma_xyz2 \u0026lt;- soma_xyz(df)\rdf\r ## # A tibble: 100 x 4\r## x y z soma_xyz2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 64.0 84.6 204. 352.\r## 2 80.3 81.0 210. 371.\r## 3 56.7 124. 210. 391.\r## 4 88.0 99.6 222. 409.\r## 5 8.80 91.8 220. 320.\r## 6 33.6 105. 175. 314.\r## 7 63.3 94.3 202. 359.\r## 8 44.4 79.0 191. 314.\r## 9 59.4 119. 192. 371.\r## 10 27.8 45.1 202. 275.\r## # ... with 90 more rows\r Outra vantagem de ter na mão uma função, é que eu posso me apropriar das ferramentas de programação funcional do R. São as funções da família apply, que recebem uma lista de objetos e aplicam uma função em cada um. Basicamente, aquela abstração do for loop que estavamos buscando.\nVejam como eu posso recriar o exemplo das somas das colunas do data.frame usando a função soma.\nsapply(df, soma)\r ## x y z soma_xyz2 ## 5175.084 10214.559 19979.241 35368.884\r Eu sei, o exemplo é muito simples pra ter uma aplicação real. Até porque já vimos como fazer esse tipo de operação com summarize lá atrás. Mas talvez, na hora que você estiver realizando alguma operação de repetição, você se lembre dessa possibilidade e ela lhe seja útil.\no pacote purrr Até o momento, nos limitamos a utilizar funções presentes no base, mas o verdadeiro intuito dessa aula é introduzir as facilidade trazidas pelas funções do tidyverse. No pacote purrr, são importadas funções com diversas funcionalidades que facilitam o trabalho com objetos mais complexos, como listas (pense saída de modelo), iterações envolvendo mais de um argumento (pense escrever diversos objetos em diversos arquivos distintos) e assim sucessivamente. Abaixo, segue uma lista das funções do pacote com uma descrição curta.\n  a família map_(): similar a família apply do R base. Recebe uma lista de objetos de entrada e uma função e devolve uma lista com os resultados.\n  map2_(): mesma coisa, só que você pode passar duas listas de objetos e uma função que requer dois argumentos variáveis. pmap() é a generalização, em que você passa p listas e uma função que pede p argumentos.\n  imap(): aplica uma função tanto ao vetor, como a seu nome/índice. É meio louco, mas é muito útil para alguns casos de uso.\n  modify_(): permite aplicar alterações no objeto estilo o que você faria com uma pipeline de filter %\u0026gt;% mutate\n  safely(): e suas irmãs possibly() e quietly() ajudam a obter resultados mesmo quando há ocorre um erro na iteração.\n  transpose(), flatten_: manipulam e reformatam listas.\n  invoke_map(): aplica uma lista de funções a uma (opcional) segunda lista de parâmetros.\n  reduce() e accumulate(): generalizam as operações de sumarização (pense soma acumulada, média, limite, fatorial)\n  pluck(): pesca elementos de uma lista com uma sintaxe linear e bonitinha.\n  E muito mais coisas\n  No interesse de ir direto ao ponto e não tentar ser exaustivo, vamos ver algumas delas em mais detalhe.\nA função map Essa função é praticamente uma cópia de lapply.\ndf %\u0026gt;% lapply(sum)\r ## $x\r## [1] 5175.084\r## ## $y\r## [1] 10214.56\r## ## $z\r## [1] 19979.24\r## ## $soma_xyz2\r## [1] 35368.88\r df %\u0026gt;% map(sum)\r ## $x\r## [1] 5175.084\r## ## $y\r## [1] 10214.56\r## ## $z\r## [1] 19979.24\r## ## $soma_xyz2\r## [1] 35368.88\r Embora existam pequenas diferenças técnicas entre elas, a principal vantagem de map é a possibilidade de criar funções anônimas com uma síntaxe enxuta. Pense, por exemplo, em elevar ao quadrado.\ndf %\u0026gt;% lapply(function(x) x ^ 2)\r ## $x\r## [1] 4101.73466 6442.94757 3219.96411 7740.50083 77.52392 1127.58641\r## [7] 4003.18277 1970.49014 3530.47096 774.99987 2443.20895 2865.99209\r## [13] 4835.03006 2291.73704 3472.69766 1827.06745 1954.20529 5005.39589\r## [19] 599.55337 6840.21539 2690.90027 4443.48342 8176.61716 1122.35347\r## [25] 6124.43204 4090.38758 1258.12990 2903.93407 1505.60524 816.50506\r## [31] 2762.76527 10206.93299 3383.39474 3929.24440 858.32911 299.32177\r## [37] 6349.05638 465.28473 1911.37533 7033.14246 813.33451 1467.96694\r## [43] 2018.47077 2411.16517 1945.70017 3561.26161 1401.68199 3657.67548\r## [49] 5975.33518 3707.27733 82.02548 8828.42227 6899.83497 938.19812\r## [55] 3413.88464 927.31285 1181.68012 2922.96590 2157.63334 4754.98150\r## [61] 3069.83817 2994.45852 20.95274 3286.19224 5448.84573 4614.42975\r## [67] 5147.05677 3342.69959 2750.92683 916.98522 138.26289 3952.18991\r## [73] 5720.72876 2815.19365 2091.69446 1278.02274 10.68606 1700.03805\r## [79] 3664.47310 5700.26729 155.81705 964.87730 1704.68622 1187.67307\r## [85] 2495.20060 5450.75572 934.23105 4995.71787 3996.69171 3570.77096\r## [91] 3647.71154 8265.66190 8104.97900 2787.03070 105.38002 2139.97839\r## [97] 2188.88388 4027.12053 1516.84960 4629.35075\r## ## $y\r## [1] 7151.412 6565.904 15465.469 9912.371 8422.026 11062.683 8898.726\r## [8] 6233.135 14195.810 2030.401 5565.017 15515.046 11528.588 9451.909\r## [15] 6173.870 4146.633 3164.735 18272.908 24261.140 17448.823 17156.170\r## [22] 4154.849 10407.268 10852.507 12008.867 11661.905 9962.577 5827.709\r## [29] 1917.046 11350.607 12628.009 14620.744 8851.069 7313.565 10635.098\r## [36] 8405.690 11204.093 10624.971 6625.751 17180.077 6758.962 14635.734\r## [43] 15028.864 6287.385 9670.247 27097.833 12444.103 5174.200 1987.106\r## [50] 3968.708 14741.992 7745.702 7529.071 11367.992 11004.793 13263.630\r## [57] 14356.074 15834.530 11392.086 13884.453 8110.941 3459.290 17805.823\r## [64] 9464.322 10653.107 13969.328 16219.520 4533.473 5779.148 7423.940\r## [71] 19330.647 20030.626 10051.328 7654.627 2168.127 17940.152 11978.961\r## [78] 7928.637 15345.071 5966.271 15963.726 14123.782 4730.376 22526.893\r## [85] 13404.375 15081.751 19130.641 27500.443 6542.030 10927.504 3684.683\r## [92] 9811.098 15832.925 17041.849 17629.378 6607.492 5663.422 11701.811\r## [99] 6023.724 21869.526\r## ## $z\r## [1] 41508.55 43955.22 44122.17 49181.30 48234.98 30624.13 40730.31 36356.66\r## [9] 36849.43 40839.24 47870.88 55940.49 56158.85 52453.95 36367.21 33702.16\r## [17] 40651.44 37526.54 33466.91 40098.83 21280.36 31668.90 59987.43 42429.94\r## [25] 47436.91 56383.51 42850.74 33140.52 30740.82 33382.25 39325.68 29803.55\r## [33] 27582.72 36055.88 30141.33 43135.68 49081.05 35531.51 40896.89 40136.05\r## [41] 58039.94 40374.40 20277.93 48318.24 41539.72 53062.55 61468.63 33130.61\r## [49] 41153.57 25438.34 34253.86 50562.05 24140.92 42847.66 38727.46 36720.32\r## [57] 51322.56 51123.33 30686.04 26044.65 35205.08 55941.68 39308.71 34987.88\r## [65] 42918.57 31031.96 52151.91 25617.74 21877.90 43197.98 50814.30 41798.91\r## [73] 58608.88 42227.48 54186.38 59475.44 41981.70 23404.82 40336.76 35826.02\r## [81] 46172.67 58244.33 31089.67 40382.25 57512.31 29234.02 46584.44 42845.56\r## [89] 31071.13 43848.77 44352.73 40918.43 32501.86 25508.47 48716.72 43616.08\r## [97] 44454.40 26486.83 27212.78 35157.45\r## ## $soma_xyz2\r## [1] 124148.61 137606.30 153004.39 167534.34 102528.67 98443.05 129183.67\r## [8] 98605.19 137289.51 75617.30 117526.93 171902.94 171300.16 139966.73\r## [15] 107718.82 84518.14 91254.97 159715.19 131903.56 172263.61 108065.60\r## [22] 95527.45 191287.26 118103.71 164546.97 167607.18 117160.41 97514.41\r## [29] 66521.08 101010.74 131945.81 155695.49 101332.42 114302.78 93658.30\r## [36] 100282.91 165708.24 98060.42 107156.57 172454.54 123655.43 129762.85\r## [43] 96050.56 121250.73 119896.30 206700.80 157546.17 98865.47 105456.51\r## [50] 80303.71 99572.67 165510.17 105760.85 118506.39 129690.11 113734.26\r## [57] 144960.84 164839.64 107819.22 121223.89 110953.64 122540.12 113084.32\r## [64] 116731.92 147608.24 131247.09 182727.87 81340.51 76386.89 105160.94\r## [71] 124394.78 167153.29 174711.06 119745.34 105675.64 171036.97 100877.23\r## [78] 80236.65 148417.75 116977.26 125109.75 153072.34 82018.20 148614.57\r## [85] 164467.96 135141.96 148004.12 196696.37 102638.38 139645.42 110024.06\r## [92] 153859.84 156926.37 117683.63 132321.18 113158.92 110811.31 111811.48\r## [99] 79254.85 162752.56\r df %\u0026gt;% map(~ .x ^ 2)\r ## $x\r## [1] 4101.73466 6442.94757 3219.96411 7740.50083 77.52392 1127.58641\r## [7] 4003.18277 1970.49014 3530.47096 774.99987 2443.20895 2865.99209\r## [13] 4835.03006 2291.73704 3472.69766 1827.06745 1954.20529 5005.39589\r## [19] 599.55337 6840.21539 2690.90027 4443.48342 8176.61716 1122.35347\r## [25] 6124.43204 4090.38758 1258.12990 2903.93407 1505.60524 816.50506\r## [31] 2762.76527 10206.93299 3383.39474 3929.24440 858.32911 299.32177\r## [37] 6349.05638 465.28473 1911.37533 7033.14246 813.33451 1467.96694\r## [43] 2018.47077 2411.16517 1945.70017 3561.26161 1401.68199 3657.67548\r## [49] 5975.33518 3707.27733 82.02548 8828.42227 6899.83497 938.19812\r## [55] 3413.88464 927.31285 1181.68012 2922.96590 2157.63334 4754.98150\r## [61] 3069.83817 2994.45852 20.95274 3286.19224 5448.84573 4614.42975\r## [67] 5147.05677 3342.69959 2750.92683 916.98522 138.26289 3952.18991\r## [73] 5720.72876 2815.19365 2091.69446 1278.02274 10.68606 1700.03805\r## [79] 3664.47310 5700.26729 155.81705 964.87730 1704.68622 1187.67307\r## [85] 2495.20060 5450.75572 934.23105 4995.71787 3996.69171 3570.77096\r## [91] 3647.71154 8265.66190 8104.97900 2787.03070 105.38002 2139.97839\r## [97] 2188.88388 4027.12053 1516.84960 4629.35075\r## ## $y\r## [1] 7151.412 6565.904 15465.469 9912.371 8422.026 11062.683 8898.726\r## [8] 6233.135 14195.810 2030.401 5565.017 15515.046 11528.588 9451.909\r## [15] 6173.870 4146.633 3164.735 18272.908 24261.140 17448.823 17156.170\r## [22] 4154.849 10407.268 10852.507 12008.867 11661.905 9962.577 5827.709\r## [29] 1917.046 11350.607 12628.009 14620.744 8851.069 7313.565 10635.098\r## [36] 8405.690 11204.093 10624.971 6625.751 17180.077 6758.962 14635.734\r## [43] 15028.864 6287.385 9670.247 27097.833 12444.103 5174.200 1987.106\r## [50] 3968.708 14741.992 7745.702 7529.071 11367.992 11004.793 13263.630\r## [57] 14356.074 15834.530 11392.086 13884.453 8110.941 3459.290 17805.823\r## [64] 9464.322 10653.107 13969.328 16219.520 4533.473 5779.148 7423.940\r## [71] 19330.647 20030.626 10051.328 7654.627 2168.127 17940.152 11978.961\r## [78] 7928.637 15345.071 5966.271 15963.726 14123.782 4730.376 22526.893\r## [85] 13404.375 15081.751 19130.641 27500.443 6542.030 10927.504 3684.683\r## [92] 9811.098 15832.925 17041.849 17629.378 6607.492 5663.422 11701.811\r## [99] 6023.724 21869.526\r## ## $z\r## [1] 41508.55 43955.22 44122.17 49181.30 48234.98 30624.13 40730.31 36356.66\r## [9] 36849.43 40839.24 47870.88 55940.49 56158.85 52453.95 36367.21 33702.16\r## [17] 40651.44 37526.54 33466.91 40098.83 21280.36 31668.90 59987.43 42429.94\r## [25] 47436.91 56383.51 42850.74 33140.52 30740.82 33382.25 39325.68 29803.55\r## [33] 27582.72 36055.88 30141.33 43135.68 49081.05 35531.51 40896.89 40136.05\r## [41] 58039.94 40374.40 20277.93 48318.24 41539.72 53062.55 61468.63 33130.61\r## [49] 41153.57 25438.34 34253.86 50562.05 24140.92 42847.66 38727.46 36720.32\r## [57] 51322.56 51123.33 30686.04 26044.65 35205.08 55941.68 39308.71 34987.88\r## [65] 42918.57 31031.96 52151.91 25617.74 21877.90 43197.98 50814.30 41798.91\r## [73] 58608.88 42227.48 54186.38 59475.44 41981.70 23404.82 40336.76 35826.02\r## [81] 46172.67 58244.33 31089.67 40382.25 57512.31 29234.02 46584.44 42845.56\r## [89] 31071.13 43848.77 44352.73 40918.43 32501.86 25508.47 48716.72 43616.08\r## [97] 44454.40 26486.83 27212.78 35157.45\r## ## $soma_xyz2\r## [1] 124148.61 137606.30 153004.39 167534.34 102528.67 98443.05 129183.67\r## [8] 98605.19 137289.51 75617.30 117526.93 171902.94 171300.16 139966.73\r## [15] 107718.82 84518.14 91254.97 159715.19 131903.56 172263.61 108065.60\r## [22] 95527.45 191287.26 118103.71 164546.97 167607.18 117160.41 97514.41\r## [29] 66521.08 101010.74 131945.81 155695.49 101332.42 114302.78 93658.30\r## [36] 100282.91 165708.24 98060.42 107156.57 172454.54 123655.43 129762.85\r## [43] 96050.56 121250.73 119896.30 206700.80 157546.17 98865.47 105456.51\r## [50] 80303.71 99572.67 165510.17 105760.85 118506.39 129690.11 113734.26\r## [57] 144960.84 164839.64 107819.22 121223.89 110953.64 122540.12 113084.32\r## [64] 116731.92 147608.24 131247.09 182727.87 81340.51 76386.89 105160.94\r## [71] 124394.78 167153.29 174711.06 119745.34 105675.64 171036.97 100877.23\r## [78] 80236.65 148417.75 116977.26 125109.75 153072.34 82018.20 148614.57\r## [85] 164467.96 135141.96 148004.12 196696.37 102638.38 139645.42 110024.06\r## [92] 153859.84 156926.37 117683.63 132321.18 113158.92 110811.31 111811.48\r## [99] 79254.85 162752.56\r Através do uso de fórmulas ~ é possível especificar funções anônimas simples economizando caracteres e utilizando o autocompletar.\nQue tal esta pipeline?\nlibrary(nycflights13)\r# Médias de todas as variáveis numéricas usando where()\rflights %\u0026gt;% select(where(is.numeric)) %\u0026gt;% map(mean)\r ## $year\r## [1] 2013\r## ## $month\r## [1] 6.54851\r## ## $day\r## [1] 15.71079\r## ## $dep_time\r## [1] NA\r## ## $sched_dep_time\r## [1] 1344.255\r## ## $dep_delay\r## [1] NA\r## ## $arr_time\r## [1] NA\r## ## $sched_arr_time\r## [1] 1536.38\r## ## $arr_delay\r## [1] NA\r## ## $flight\r## [1] 1971.924\r## ## $air_time\r## [1] NA\r## ## $distance\r## [1] 1039.913\r## ## $hour\r## [1] 13.18025\r## ## $minute\r## [1] 26.2301\r Ou esta\n# Proporção de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(mean)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 0.02451184\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 0.02451184\r## ## $arr_time\r## [1] 0.0258718\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 0.02800081\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 0.007458964\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 0.02800081\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r # Contagem de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(sum)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 8255\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 8255\r## ## $arr_time\r## [1] 8713\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 9430\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 2512\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 9430\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r A outra grande vantagem do map é ter acesso fácil ao controle do tipo de saída.\n# Vetor numérico\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_dbl(mean)\r ## year month day dep_time sched_dep_time ## 0.000000000 0.000000000 0.000000000 0.024511842 0.000000000 ## dep_delay arr_time sched_arr_time arr_delay carrier ## 0.024511842 0.025871796 0.000000000 0.028000808 0.000000000 ## flight tailnum origin dest air_time ## 0.000000000 0.007458964 0.000000000 0.000000000 0.028000808 ## distance hour minute time_hour ## 0.000000000 0.000000000 0.000000000 0.000000000\r # Vetor de caracteres\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_chr(mean)\r ## year month day dep_time sched_dep_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.024512\u0026quot; \u0026quot;0.000000\u0026quot; ## dep_delay arr_time sched_arr_time arr_delay carrier ## \u0026quot;0.024512\u0026quot; \u0026quot;0.025872\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; \u0026quot;0.000000\u0026quot; ## flight tailnum origin dest air_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.007459\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; ## distance hour minute time_hour ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot;\r Um exemplo um pouco mais elaborado: avaliação inicial de variáveis em um modelo. Em geral, é comum rodar um modelo para cada variável numérica para ver como elas se comportam.\nrespvar \u0026lt;- \u0026quot;hwy\u0026quot;\rpredvars \u0026lt;- names(select(mpg, where(is.numeric), -hwy))\rtibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rsummary = map(fit, summary),\rr2 = map_dbl(summary, \u0026quot;r.squared\u0026quot;),\rFStat = map_df(summary, \u0026quot;fstatistic\u0026quot;),\rcoefs = map_df(fit, coef),\r)\r ## # A tibble: 4 x 6\r## names fit summary r2 FStat$value $numdf $dendf coefs$`(Interce~ $displ\r## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.87e-1 329. 1 232 35.7 -3.53\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;smmry~ 4.66e-6 0.00108 1 232 17.7 NA ## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.81e-1 321. 1 232 40.0 NA ## 4 cty \u0026lt;lm\u0026gt; \u0026lt;smmry~ 9.14e-1 2459. 1 232 0.892 NA\r Ok, a saída não está muito bonitinha! Mas com um pouco mais de trabalho, programadores melhores que eu fizeram isso:\nmodels \u0026lt;- tibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rtidied = fit %\u0026gt;% map(broom::tidy),\rglanced = fit %\u0026gt;% map(broom::glance),\raugmented = fit %\u0026gt;% map(broom::augment)\r)\rmodels\r ## # A tibble: 4 x 5\r## names fit tidied glanced augmented ## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; ## 1 displ \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 4 cty \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r Grande coisa, Vinícius, o output é ilegível! Calma! Lembram da primeira aula em que eu comentei que havia mais funções no tidyr?\n# Coeficientes\rmodels %\u0026gt;% select(tidied) %\u0026gt;%\rtidyr::unnest(tidied) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)\r ## # A tibble: 4 x 5\r## term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ -3.53 0.195 -18.2 2.04e- 46\r## 2 year 0.00285 0.0867 0.0329 9.74e- 1\r## 3 cyl -2.82 0.157 -17.9 1.18e- 45\r## 4 cty 1.34 0.0270 49.6 1.87e-125\r # Estatísticas do modelo\rmodels %\u0026gt;% select(names, glanced) %\u0026gt;% unnest(glanced)\r ## # A tibble: 4 x 13\r## names r.squared adj.r.squared sigma statistic p.value df logLik AIC\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 0.587 0.585 3.84 329. 2.04e- 46 1 -646. 1297.\r## 2 year 0.00000466 -0.00431 5.97 0.00108 9.74e- 1 1 -749. 1504.\r## 3 cyl 0.581 0.579 3.87 321. 1.18e- 45 1 -647. 1301.\r## 4 cty 0.914 0.913 1.75 2459. 1.87e-125 1 -462. 931.\r## # ... with 4 more variables: BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;, df.residual \u0026lt;int\u0026gt;,\r## # nobs \u0026lt;int\u0026gt;\r # Bancos \u0026quot;aumentados\u0026quot; com valores ajustados, resíduos, distâncias de cook, etc.\rmodels %\u0026gt;% filter(names == \u0026quot;displ\u0026quot;) %\u0026gt;% select(names, augmented) %\u0026gt;% unnest(augmented)\r ## # A tibble: 234 x 9\r## names hwy displ .fitted .resid .hat .sigma .cooksd .std.resid\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 2 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 3 displ 31 2 28.6 2.36 0.00984 3.84 0.00191 0.619 ## 4 displ 30 2 28.6 1.36 0.00984 3.84 0.000634 0.357 ## 5 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 6 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 7 displ 27 3.1 24.8 2.25 0.00463 3.84 0.000802 0.587 ## 8 displ 26 1.8 29.3 -3.34 0.0115 3.84 0.00445 -0.876 ## 9 displ 25 1.8 29.3 -4.34 0.0115 3.83 0.00751 -1.14 ## 10 displ 28 2 28.6 -0.636 0.00984 3.84 0.000138 -0.167 ## # ... with 224 more rows\r Isso aqui é só uma palhinha de modelagem com o tidyverse, mas acho que é uma demonstração muito convincente da aplicabilidade dos exemplos que vimos usando programação funcional.\nOutro exemplo mais simples com map2: salvar vários arquivos de uma vez só.\ndf1 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf2 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf3 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf4 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdfs \u0026lt;- list(df1, df2, df3, df4)\rdfs\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.423 0.647 0.340 ## 2 0.168 -0.654 0.134 ## 3 0.317 -1.52 0.479 ## 4 -0.0876 0.229 -0.579 ## 5 1.08 1.01 -1.05 ## 6 0.0523 0.726 -0.790 ## 7 0.967 -1.01 -0.814 ## 8 0.772 0.262 1.28 ## 9 -1.07 -0.549 -0.759 ## 10 1.19 0.768 -0.0372\r## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.426 0.427 -0.428 ## 2 -0.532 0.0595 -1.46 ## 3 0.211 -0.125 1.14 ## 4 0.853 -0.376 -0.0773 ## 5 1.45 1.32 -0.248 ## 6 -1.11 0.785 -0.0661 ## 7 -1.03 -0.237 -0.00866\r## 8 0.950 0.449 1.25 ## 9 -0.467 -0.0485 0.168 ## 10 0.886 -0.338 -0.376 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.69 -0.524 -0.0254 ## 2 -2.34 2.02 0.459 ## 3 -1.01 -0.0508 0.678 ## 4 0.117 -0.427 -0.240 ## 5 -2.26 -0.598 -0.863 ## 6 0.801 0.397 -0.923 ## 7 -0.484 0.501 0.00797\r## 8 1.07 1.49 0.587 ## 9 0.102 -1.25 0.393 ## 10 -1.09 -0.789 1.65 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.563 -0.756 1.34 ## 2 0.150 0.664 0.373 ## 3 -0.762 1.28 -1.12 ## 4 0.888 0.920 -0.0385\r## 5 -0.786 1.66 -0.914 ## 6 1.27 -0.454 0.721 ## 7 1.39 -0.567 0.289 ## 8 -1.49 0.489 0.545 ## 9 -0.173 0.780 -1.17 ## 10 0.335 -0.947 -0.959 ## # ... with 90 more rows\r paths \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:4)\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r map2(dfs, paths, ~write_csv(x = .x, file = .y))\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.423 0.647 0.340 ## 2 0.168 -0.654 0.134 ## 3 0.317 -1.52 0.479 ## 4 -0.0876 0.229 -0.579 ## 5 1.08 1.01 -1.05 ## 6 0.0523 0.726 -0.790 ## 7 0.967 -1.01 -0.814 ## 8 0.772 0.262 1.28 ## 9 -1.07 -0.549 -0.759 ## 10 1.19 0.768 -0.0372\r## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.426 0.427 -0.428 ## 2 -0.532 0.0595 -1.46 ## 3 0.211 -0.125 1.14 ## 4 0.853 -0.376 -0.0773 ## 5 1.45 1.32 -0.248 ## 6 -1.11 0.785 -0.0661 ## 7 -1.03 -0.237 -0.00866\r## 8 0.950 0.449 1.25 ## 9 -0.467 -0.0485 0.168 ## 10 0.886 -0.338 -0.376 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.69 -0.524 -0.0254 ## 2 -2.34 2.02 0.459 ## 3 -1.01 -0.0508 0.678 ## 4 0.117 -0.427 -0.240 ## 5 -2.26 -0.598 -0.863 ## 6 0.801 0.397 -0.923 ## 7 -0.484 0.501 0.00797\r## 8 1.07 1.49 0.587 ## 9 0.102 -1.25 0.393 ## 10 -1.09 -0.789 1.65 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.563 -0.756 1.34 ## 2 0.150 0.664 0.373 ## 3 -0.762 1.28 -1.12 ## 4 0.888 0.920 -0.0385\r## 5 -0.786 1.66 -0.914 ## 6 1.27 -0.454 0.721 ## 7 1.39 -0.567 0.289 ## 8 -1.49 0.489 0.545 ## 9 -0.173 0.780 -1.17 ## 10 0.335 -0.947 -0.959 ## # ... with 90 more rows\r E se eu quiser ler um banco de dados que está em vários arquivos diferentes? Vamos usar os que acabamos de criar\n# Bum! Uma linha\rpaths %\u0026gt;% map_dfr(read_csv, .id = \u0026quot;arquivo\u0026quot;)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r ## # A tibble: 400 x 4\r## arquivo x y z\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 -0.423 0.647 0.340 ## 2 1 0.168 -0.654 0.134 ## 3 1 0.317 -1.52 0.479 ## 4 1 -0.0876 0.229 -0.579 ## 5 1 1.08 1.01 -1.05 ## 6 1 0.0523 0.726 -0.790 ## 7 1 0.967 -1.01 -0.814 ## 8 1 0.772 0.262 1.28 ## 9 1 -1.07 -0.549 -0.759 ## 10 1 1.19 0.768 -0.0372\r## # ... with 390 more rows\r As possibilidades são inúmeras. A regra é a seguinte: viu uma tarefa que precisa ser repetida muitas vezes? Pense com carinho em usar uma função vetorizada através de map_.\nPredicados O objetivo de um função predicado é selecionar elementos de uma lista com base em uma função. Em geral, são funções simples que retornam um valor TRUE ou FALSE com base em alguma característica do objeto, como o tipo.\nl \u0026lt;- list(c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c(1, 2, 3))\rl %\u0026gt;% str()\r ## List of 2\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.numeric) %\u0026gt;% str()\r ## List of 1\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.character) %\u0026gt;% str()\r ## List of 1\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r O uso mais frequente que vejo de keep e discard é como uma espécie de atalho para select. Como data.frames são secretamente listas, você pode rapidamente selecionar todas as variáveis do banco que tenham o mesmo tipo.\nflights %\u0026gt;% keep(is.numeric)\r ## # A tibble: 336,776 x 14\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 6 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;\r flights %\u0026gt;% discard(is.character)\r ## # A tibble: 336,776 x 15\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 7 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;,\r## # time_hour \u0026lt;dttm\u0026gt;\r Como outros aspectos do purrr, a grande vantagem aqui é a generalidade. Essas funções funcionam em qualquer lista de objetos e não apenas em data.frames.\nLidando com a presença de erros A próxima dica forte é utilizar os advérbios (chique) safely() e companhia para lidar com erros.\nx \u0026lt;- list(a = c(1,2,3), b = c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c = c(99, 88, 77))\rx %\u0026gt;% map(sum)\r ## Error in .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm): 'type' inválido (character) do argumento\r Não conseguimos nada! A mensagem de erro nem nos informa onde o problema ocorreu. E agora?\nx %\u0026gt;% map(safely(sum)) %\u0026gt;% str()\r ## List of 3\r## $ a:List of 2\r## ..$ result: num 6\r## ..$ error : NULL\r## $ b:List of 2\r## ..$ result: NULL\r## ..$ error :List of 2\r## .. ..$ message: chr \u0026quot;'type' inválido (character) do argumento\u0026quot;\r## .. ..$ call : language .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm)\r## .. ..- attr(*, \u0026quot;class\u0026quot;)= chr [1:3] \u0026quot;simpleError\u0026quot; \u0026quot;error\u0026quot; \u0026quot;condition\u0026quot;\r## $ c:List of 2\r## ..$ result: num 264\r## ..$ error : NULL\r x %\u0026gt;% map(possibly(sum, otherwise = NA_real_)) %\u0026gt;% str()\r ## List of 3\r## $ a: num 6\r## $ b: num NA\r## $ c: num 264\r Essas funções permitem alterar a saída de uma função quando ocorrer um erro. quietly é parecido, mas ela captura mais a saída do R, o texto em si.\nx \u0026lt;- list(1, -1)\rx %\u0026gt;% map(quietly(log)) %\u0026gt;% str()\r ## List of 2\r## $ :List of 4\r## ..$ result : num 0\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr(0) ## ..$ messages: chr(0) ## $ :List of 4\r## ..$ result : num NaN\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr \u0026quot;NaNs produzidos\u0026quot;\r## ..$ messages: chr(0)\r Chamando listas de funções Vamos supor que você tem um vetor de números e você quer aplicar um monte de funções diferentes nele, mas você não quer ter que ficar copiando e colando tudo.\nnumeros \u0026lt;- rnorm(25, 50, 10)\rnumeros\r ## [1] 40.28363 47.05338 55.52213 67.17898 63.43975 31.32029 26.02457 44.61720\r## [9] 65.55023 49.84583 51.14611 55.58084 49.75603 46.89402 59.27724 55.44557\r## [17] 54.67422 60.47497 44.36346 40.90925 53.91280 53.97654 74.11447 60.40166\r## [25] 52.34901\r Nessas situações, você gostaria de chamar várias funções no mesmo objeto ou grupo de objetos, mas você não sabe bem como fazer isso\u0026hellip; Então, invoke_map vem ao resgate.\nfuncs \u0026lt;- list(\u0026quot;mean\u0026quot;, \u0026quot;sd\u0026quot;, \u0026quot;IQR\u0026quot;, \u0026quot;sum\u0026quot;, \u0026quot;length\u0026quot;, \u0026quot;range\u0026quot;, \u0026quot;min\u0026quot;, \u0026quot;max\u0026quot;)\rargs \u0026lt;- list(list(na.rm = T, trim = 0.05),\rlist(na.rm=T), list(type = 2),\rlist(na.rm = T), list(),\rlist(na.rm = T), list(na.rm = T), list(na.rm = T))\rfuncs %\u0026gt;% str()\r ## List of 8\r## $ : chr \u0026quot;mean\u0026quot;\r## $ : chr \u0026quot;sd\u0026quot;\r## $ : chr \u0026quot;IQR\u0026quot;\r## $ : chr \u0026quot;sum\u0026quot;\r## $ : chr \u0026quot;length\u0026quot;\r## $ : chr \u0026quot;range\u0026quot;\r## $ : chr \u0026quot;min\u0026quot;\r## $ : chr \u0026quot;max\u0026quot;\r args %\u0026gt;% str()\r ## List of 8\r## $ :List of 2\r## ..$ na.rm: logi TRUE\r## ..$ trim : num 0.05\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ type: num 2\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ : list()\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r invoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ : num 52.3\r## $ : num 10.8\r## $ : num 12.4\r## $ : num 1304\r## $ : int 25\r## $ : num [1:2] 26 74.1\r## $ : num 26\r## $ : num 74.1\r Fica mais bonito se você nomear os argumentos, ai o output fica melhorzinho.\nnames(funcs) \u0026lt;- unlist(funcs)\rinvoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ mean : num 52.3\r## $ sd : num 10.8\r## $ IQR : num 12.4\r## $ sum : num 1304\r## $ length: int 25\r## $ range : num [1:2] 26 74.1\r## $ min : num 26\r## $ max : num 74.1\r Claro que esse exemplo aqui talvez não seja útil para vocês, mas espero que quando vocês encontrarem uma situação em que você gostaria de aplicar uma bateria de funções no mesmo objeto ou grupo de objetos, vocês se lembrem dessa possibilidade.\nreduce e accumulate Essas duas funções são desenhadas para fazer aplicações recursivas de funções que recebem dois argumentos (operadores matemáticos, _joins, etc. Recursividade em linhas gerais, é você repetir uma operação com o resultado da repetição anterior. Pense em somas ou produtos acumulados, em que o próximo valor é determinado pela aplicação de uma regra sobre o anterior.\naccumulate(1:10, `+`)\r ## [1] 1 3 6 10 15 21 28 36 45 55\r accumulate(1:10, `*`)\r ## [1] 1 2 6 24 120 720 5040 40320 362880\r## [10] 3628800\r A principal diferença entre accumulate e reduce é que a primeira guarda os resultados intermediários, enquanto a segunda retorna apenas o último.\nreduce(1:10, `+`)\r ## [1] 55\r reduce(1:10, `*`)\r ## [1] 3628800\r Uma aplicação bastante prática dessas funções é a produção de um único banco de dados a partir de vários arquivos separados.\n# Lembra dos nossos arquivos lá em cima?\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r Vamos fingir que não temos acesso a map_dfr e precisamos importar esses objetos e todos compõem um único banco. Imaginaem que tratam-se de dados por ano.\ndfs \u0026lt;- map(paths, read_csv)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r glimpse(dfs)\r ## List of 4\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.4228 0.1677 0.3166 -0.0876 1.0804 ...\r## ..$ y: num [1:100] 0.647 -0.654 -1.521 0.229 1.014 ...\r## ..$ z: num [1:100] 0.34 0.134 0.479 -0.579 -1.048 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.426 -0.532 0.211 0.853 1.452 ...\r## ..$ y: num [1:100] 0.4268 0.0595 -0.1254 -0.3762 1.3227 ...\r## ..$ z: num [1:100] -0.4284 -1.4608 1.1365 -0.0773 -0.2477 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] 1.689 -2.343 -1.015 0.117 -2.26 ...\r## ..$ y: num [1:100] -0.524 2.0172 -0.0508 -0.4266 -0.598 ...\r## ..$ z: num [1:100] -0.0254 0.4592 0.6776 -0.2399 -0.8627 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] 0.563 0.15 -0.762 0.888 -0.786 ...\r## ..$ y: num [1:100] -0.756 0.664 1.281 0.92 1.659 ...\r## ..$ z: num [1:100] 1.3386 0.3727 -1.1177 -0.0385 -0.9144 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r new_df \u0026lt;- reduce(dfs, bind_rows)\rnew_df\r ## # A tibble: 400 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.423 0.647 0.340 ## 2 0.168 -0.654 0.134 ## 3 0.317 -1.52 0.479 ## 4 -0.0876 0.229 -0.579 ## 5 1.08 1.01 -1.05 ## 6 0.0523 0.726 -0.790 ## 7 0.967 -1.01 -0.814 ## 8 0.772 0.262 1.28 ## 9 -1.07 -0.549 -0.759 ## 10 1.19 0.768 -0.0372\r## # ... with 390 more rows\r O resultado é o mesmo observado em map_dfr, mas essa abordagem é genérica, ou seja, ela se aplica para qualquer grupo de objetos e para qualquer função que recebe dois argumentos e precisa ser repetida de maneira recursiva.\n# Apaga os arquivos pra eles não ficarem ai gastando memória a toa\rfile.remove(paths)\r ## [1] TRUE TRUE TRUE TRUE\r pluck Esta função é um atalho para as tesouras duplas do r [[. Seu objeto é facilitar a leitura de códigos que pescam elementos profundos de uma lista aninhada.\nl \u0026lt;- list(\rlist(-1, x = 1, y = c(2), z = \u0026quot;a\u0026quot;),\rlist(-2, x = 4, y = c(5, 6), z = \u0026quot;b\u0026quot;),\rlist(-3, x = 8, y = c(9, 10, 11))\r)\rglimpse(l)\r ## List of 3\r## $ :List of 4\r## ..$ : num -1\r## ..$ x: num 1\r## ..$ y: num 2\r## ..$ z: chr \u0026quot;a\u0026quot;\r## $ :List of 4\r## ..$ : num -2\r## ..$ x: num 4\r## ..$ y: num [1:2] 5 6\r## ..$ z: chr \u0026quot;b\u0026quot;\r## $ :List of 3\r## ..$ : num -3\r## ..$ x: num 8\r## ..$ y: num [1:3] 9 10 11\r Se você chamar map_ nessa lista, você pode extrair os elementos delas pelo nome.\nmap_dbl(l, \u0026quot;x\u0026quot;)\r ## [1] 1 4 8\r map(l, \u0026quot;y\u0026quot;)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r map(l, \u0026quot;z\u0026quot;)\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r Ou pela posição na lista\nmap_dbl(l, 1)\r ## [1] -1 -2 -3\r map_dbl(l, 2)\r ## [1] 1 4 8\r map(l, 3)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r Ou os dois\nmap_dbl(l, list(\u0026quot;x\u0026quot;, 1))\r ## [1] 1 4 8\r map(l, list(\u0026quot;z\u0026quot;, 1))\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r map(l, list(\u0026quot;y\u0026quot;, 3))\r ## [[1]]\r## NULL\r## ## [[2]]\r## NULL\r## ## [[3]]\r## [1] 11\r Se um componente não existir, você recebe um erro\nmap_chr(l, \u0026quot;z\u0026quot;)\r ## Error: Result 3 must be a single string, not NULL of length 0\r Mas você pode resolver isso passando um valor padrão\nmap_chr(l, \u0026quot;z\u0026quot;, .default = NA_character_)\r ## [1] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; NA\r Tudo isso funciona com base na função pluck\npluck(l, 1)\r ## [[1]]\r## [1] -1\r## ## $x\r## [1] 1\r## ## $y\r## [1] 2\r## ## $z\r## [1] \u0026quot;a\u0026quot;\r pluck(l, 1, 2)\r ## [1] 1\r pluck(l, 2, 3)\r ## [1] 5 6\r pluck(l, 1, \u0026quot;x\u0026quot;)\r ## [1] 1\r pluck(l, 2, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;b\u0026quot;\r pluck(l, 3, \u0026quot;y\u0026quot;)\r ## [1] 9 10 11\r Exercícios   Utilize uma das funções map_ para:\n  Calcular a média de cada coluna em mtcars.\n  Determinar o tipo de cada coluna em flights.\n  Computar o número de valores únicos em cada coluna de iris.\n  Gere 10 distribuições aleatórias (rnorm) com médias -10, 0, 10 e 100.\n  Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?\n  Usando as funções predicado keep e discard:\n  Selecione todas as colunas caractere no banco flights.\n  Descarte os caracteres em mpg.\n  Selecione os fatores ordenados em diamonds.\n  Descarte as variáveis não-numéricas em iris\n  Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.\n  Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.\n  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"8fc2c9a43ba39b58554f36d137f8df4b","permalink":"https://laddem.github.io/courses/tidyverse/dia4/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia4/","section":"courses","summary":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.","tags":null,"title":"purrr","type":"book"},{"authors":null,"categories":null,"content":"Soluções dos exercícios.\nreadr, tibble, tidyr # Não esqueça dos pacotes!\rlibrary(tidyverse)\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Primeiro, é bom verificar como estão dispostas as informações no arquivo texto\nread_lines(file, n_max = 10)\r ## [1] \u0026quot;ALFA ROMEO ALFA ROMEO 78010003\u0026quot;\r## [2] \u0026quot;ALFETTA 03 81 8 74 7 89 9 ALFETTA 78010053\u0026quot;\r## [3] \u0026quot;SPIDER 2000 01 SPIDER 2000 78010103\u0026quot;\r## [4] \u0026quot;AMC AMC 78020002\u0026quot;\r## [5] \u0026quot;GREMLIN 03 79 9 79 9 GREMLIN 78020053\u0026quot;\r## [6] \u0026quot;PACER 04 89 11 89 11 PACER 78020103\u0026quot;\r## [7] \u0026quot;PACER WAGON 07 90 26 91 26 PACER WAGON 78020153\u0026quot;\r## [8] \u0026quot;CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 78020203\u0026quot;\r## [9] \u0026quot;CONCORD WAGON 07 91 30 91 30 CONCORD WAGON 78020253\u0026quot;\r## [10] \u0026quot;MATADOR COUPE 05 97 14 97 14 MATADOR COUPE 78020303\u0026quot;\r Ao identificar que se trata de um arquivo colunado, mas que as colunas são separadas por espaços, escolho o read_fwf com o fwf_empty.\ndic \u0026lt;- fwf_empty(file)\rdf \u0026lt;- read_fwf(file, col_positions = dic)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_double(),\r## X4 = col_double(),\r## X5 = col_double(),\r## X6 = col_double(),\r## X7 = col_double(),\r## X8 = col_double(),\r## X9 = col_double(),\r## X10 = col_double(),\r## X11 = col_character(),\r## X12 = col_double()\r## )\r df\r ## # A tibble: 20 x 12\r## X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 ALFA RO~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ALFA R~ 7.80e7\r## 2 ALFETTA 03 81 8 74 7 89 9 NA NA ALFETTA 7.80e7\r## 3 SPIDER ~ 01 NA NA NA NA NA NA NA NA SPIDER~ 7.80e7\r## 4 AMC \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AMC 7.80e7\r## 5 GREMLIN 03 79 9 NA NA NA NA 79 9 GREMLIN 7.80e7\r## 6 PACER 04 89 11 NA NA NA NA 89 11 PACER 7.80e7\r## 7 PACER W~ 07 90 26 91 26 NA NA NA NA PACER ~ 7.80e7\r## 8 CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 7.80e7\r## 9 CONCORD~ 07 91 30 NA NA 91 30 NA NA CONCOR~ 7.80e7\r## 10 MATADOR~ 05 97 14 97 14 NA NA NA NA MATADO~ 7.80e7\r## 11 MATADOR~ 06 110 20 NA NA 110 20 NA NA MATADO~ 7.80e7\r## 12 MATADOR~ 09 112 50 NA NA 112 50 NA NA MATADO~ 7.80e7\r## 13 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 14 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 15 AUDI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AUDI 7.81e7\r## 16 FOX 03 84 11 84 11 84 11 NA NA FOX 7.81e7\r## 17 FOX WAG~ 07 83 40 NA NA 83 40 NA NA FOX WA~ 7.81e7\r## 18 5000 04 90 15 NA NA 90 15 NA NA 5000 7.81e7\r## 19 AVANTI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AVANTI 7.81e7\r## 20 AVANTI ~ 02 75 8 75 8 NA NA NA NA AVANTI~ 7.81e7\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  Ao verificar as primeiras 10 linhas do banco, podemos notar algo estranho\nfile \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\rread_lines(file, n_max = 10)\r ## [1] \u0026quot;x,y\u0026quot; \u0026quot;404,NA\u0026quot; \u0026quot;4172,NA\u0026quot; \u0026quot;3004,NA\u0026quot; \u0026quot;787,NA\u0026quot; \u0026quot;37,NA\u0026quot; \u0026quot;2332,NA\u0026quot;\r## [8] \u0026quot;2489,NA\u0026quot; \u0026quot;1449,NA\u0026quot; \u0026quot;3665,NA\u0026quot;\r Parece ser um arquivo csv comum, com duas colunas, mas uma delas parece ter apenas NAs. Se a gente proceder com a importação padrão, chegaremos em\ndf \u0026lt;- read_csv(file)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_logical()\r## )\r ## Warning: 1000 parsing failures.\r## row col expected actual file\r## 1001 y 1/0/T/F/TRUE/FALSE 2015-01-16 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1002 y 1/0/T/F/TRUE/FALSE 2018-05-18 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1003 y 1/0/T/F/TRUE/FALSE 2015-09-05 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1004 y 1/0/T/F/TRUE/FALSE 2012-11-28 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1005 y 1/0/T/F/TRUE/FALSE 2020-01-13 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## .... ... .................. .......... ........................................................................\r## See problems(...) for more details.\r df\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;lgl\u0026gt;\r## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r No console de vocês, deve aparecer que foram importadas as colunas x como double e y como logical. Mas uma chuva de \u0026ldquo;parsing failures\u0026rdquo;, indicando que expected = 1/0/T/F/TRUE/FALSE, actual = 2015-01-16.\nNa verdade, ao tentar adivinhar o tipo de colunas, o readr lê as primeiras 1000 observações em busca de um padrão. Você pode resolver esse problema:\n# 1. Aumentando o número de observações utilizadas para adivinhar as colunas\rdf \u0026lt;- read_csv(file, guess_max = 1001)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_date(format = \u0026quot;\u0026quot;)\r## )\r # A específicação da coluna Y agora é \u0026lt;date\u0026gt;\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r # 2. escolhendo diretamente o tipo de coluna antes da importação\rtipos \u0026lt;- cols(\ry = col_date()\r)\rdf \u0026lt;- read_csv(file, col_types = tipos)\r# Mesmo resultado\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r É sempre bom começar planejando o banco que queremos construir. Queremos um banco que tenha 3 variáveis: o nome, o tipo de prova aplicada e a nota de cada aluno. Para isso, precisamos colocar os nomes das colunas teste1, teste2 e prova1 numa variável e os valores das células em outra. Vamos chamar essas colunas de \u0026ldquo;avaliação\u0026rdquo; e \u0026ldquo;nota\u0026rdquo;, elas formam um par.\nAgora vamos chamar pivot_wider e especificar esses argumentos.\nsala_aula %\u0026gt;% pivot_longer(\r# Primeiro, identificamos as colunas que serão modificadas\rcols = c(teste1, teste2, prova1),\r# Agora, indicamos os nomes das colunas que receberão\r# os nomes das colunas transformadas\rnames_to = \u0026quot;avaliacao\u0026quot;,\r# os valores das células\rvalues_to = \u0026quot;nota\u0026quot;\r)\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r O banco relig_income parece ter uma organização em que temos 2 variáveis, mas uma delas está numa coluna \u0026ldquo;religion\u0026rdquo; e a outra está em 10 colunas, \u0026ldquo;income\u0026rdquo;. Queremos um banco que tenha 3 colunas: a religião, o nível de renda, e o número de pessoas em cada combinação das duas primeiras.\nComo no exerício anterior, vamos chamar pivot_longer e especificar\nrelig_income %\u0026gt;% pivot_longer(\r# As colunas a serem modificadas, notem o uso de ':' para selecionar várias\r# colunas em sequência\rcols = `\u0026lt;$10k`:`Don't know/refused`,\r# Variável recebe os nomes da antiga coluna\rnames_to = \u0026quot;nivel_renda\u0026quot;,\r# Variável recebe os valores das células\rvalues_to = \u0026quot;contagem\u0026quot;\r)\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.   Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\n billboard\r ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r Da mesma forma como fizemos nos anteriores, queremos transformar as várias wk1:wk76 em um par de colunas, uma que me diga a semana e a outra que me diga em que posição no ranking a música estava.\nbillboard %\u0026gt;% pivot_longer(\r# Colunas que serão transformadas\rcols = wk1:wk76,\r# Nome da variável que receberá os nomes das colunas\rnames_to = \u0026quot;semana\u0026quot;,\r# Nome da variável que receberá os valores das células\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\r# Nesse caso, uso o argumento opcional para eliminar os NAs\rvalues_drop_na = TRUE\r# Experimente mudar este argumento para FALSE e veja o resultado\r# Quando uma música não está mais nas paradas, ela recebe NA. Acho\r# justificado excluir os NAs nesse caso.\r)\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?  Vou começar enxugando os códigos anteriores para criar os resultados que produzimos e salvá-los em objetos.\nsala_aula_long \u0026lt;- sala_aula %\u0026gt;% pivot_longer(\rcols = c(teste1, teste2, prova1),\rnames_to = \u0026quot;avaliacao\u0026quot;,\rvalues_to = \u0026quot;nota\u0026quot;\r)\rrelig_income_long \u0026lt;- relig_income %\u0026gt;% pivot_longer(\rcols = `\u0026lt;$10k`:`Don't know/refused`,\rnames_to = \u0026quot;nivel_renda\u0026quot;,\rvalues_to = \u0026quot;contagem\u0026quot;\r)\rbillboard_long \u0026lt;- billboard %\u0026gt;% pivot_longer(\rcols = wk1:wk76,\rnames_to = \u0026quot;semana\u0026quot;,\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\rvalues_drop_na = TRUE\r)\rsala_aula_long\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r relig_income_long\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r billboard_long\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r O caminho inverso desses bancos de dados, é utilizar pivot_wider. Aqui, vamos escolher um par de colunas que contém:\n O nome das colunas que queremos criar O valor que queremos passar para as células dessas novas colunas  Vamos ver exemplos comentados como no anterior\nsala_aula_long %\u0026gt;% pivot_wider(\r# Aqui, identificamos colunas que NÃO SERÃO MODIFICADAS\r# É o contrário de pivot_longer. Por padrão, são todas as que não são\r# mencionadas na transformação, mas para deixar bem claro, # vou deixar explícito.\rid_cols = name,\r# Variável com os nomes para as novas colunas\rnames_from = avaliacao,\r# Variável com os valores para as células\rvalues_from = nota\r)\r ## # A tibble: 4 x 4\r## name teste1 teste2 prova1\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Billy \u0026lt;NA\u0026gt; D C ## 2 Suzy F \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; ## 3 Lionel B C B ## 4 Jenny A A B\r relig_income_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = religion,\r# Variável com os nomes para as novas colunas\rnames_from = nivel_renda,\r# Variável com os valores para as células\rvalues_from = contagem\r)\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r billboard_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = c(artist, track, date.entered),\r# Variável com os nomes para as novas colunas\rnames_from = semana,\r# Variável com os valores para as células\rvalues_from = posicao_rank\r)\r ## # A tibble: 317 x 68\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 57 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;\r Tanto pivot_longer quanto pivot_wider tem mais argumentos para lidar com situações complexas, como quando você precisa aplicar transformações em variáveis antes de reformatar o banco ou precisa utilizar múltiplas colunas, mas eu deixo isso para vocês descobrirem por conta própria quando estiverem confortáveis com a sintaxe básica.\nO que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r Por padrão, separate espera que todas as colunas sendo separadas tenham o mesmo comprimento. Por exemplo, no primeiro caso, indicamos que vamos criar três novas colunas, chamadas de \u0026ldquo;um\u0026rdquo;, \u0026ldquo;dois\u0026rdquo; e \u0026ldquo;tres\u0026rdquo;. Mas os vetores tem tamanhos diferentes. Um deles tem 4 letras ao invés de 3. No segundo exemplo, um deles tem duas letras ao invés de três. Esse tipo de situação é bastante comum quando lidamos com erros de digitação. Então, o que fazer com o elemento que está sobrando ou faltando?\n# Sobrando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;warn\u0026quot;) # avise que ocorreu (padrão)\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;drop\u0026quot;) # descarte o que sobrou\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;merge\u0026quot;) # junte com o último\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f,g ## 3 h i j\r # Note especialmente no último caso o que ocorreu com as colunas.\r# Faltando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;warn\u0026quot;) # avise e preencha a direita\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;left\u0026quot;) # preencha a esquerda\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 \u0026lt;NA\u0026gt; d e ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;right\u0026quot;) # preencha a direta\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r # Note na sua saída do R como ficou a tibble e onde foram colocados NAs\r# em cada caso\r Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?  Acho que a melhor forma de compreender isso é utilizar um banco de dados. Vamos pegar aquele da população retirado da Wikipédia.\npopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Vamos ver dois exemplos, um com unite e outro com separate para exemplificar o que remove faz.\n# Unir as colunas Day, Month, Year, remove = TRUE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = TRUE) # padrão\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19_May_20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19_May_20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31_Dec_20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19_May_20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19_May_20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1_Jan_2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2_Mar_2020 2020 census result[9]\r # Unir as colunas Day, Month, Year, remove = FALSE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = FALSE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Data Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_~ 1 Nov 2020 Seventh Ce~\r## 2 2 India 1377123716 17.5% 19_May~ 19 May 2021 National p~\r## 3 3 United S~ 331695937 4.22% 19_May~ 19 May 2021 National p~\r## 4 4 Indonesia 271350000 3.45% 31_Dec~ 31 Dec 2020 National a~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_~ 1 Jul 2021 UN project~\r## 6 6 Brazil 213154869 2.71% 19_May~ 19 May 2021 National p~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_~ 1 Jul 2021 UN project~\r## 8 8 Banglade~ 170689832 2.17% 19_May~ 19 May 2021 National p~\r## 9 9 Russia 146171015 1.86% 1_Jan_~ 1 Jan 2021 National a~\r## 10 10 Mexico 126014024 1.60% 2_Mar_~ 2 Mar 2020 2020 censu~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Agora com separate: Separar a coluna year em século e ano, apenas como exemplo\n# remove = TRUE, padrão\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = TRUE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Day Month seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 20 20 Seventh Cen~\r## 2 2 India 1377123716 17.5% 19 May 20 21 National po~\r## 3 3 United S~ 331695937 4.22% 19 May 20 21 National po~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20 20 National an~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 20 21 UN projecti~\r## 6 6 Brazil 213154869 2.71% 19 May 20 21 National po~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 20 21 UN projecti~\r## 8 8 Banglade~ 170689832 2.17% 19 May 20 21 National po~\r## 9 9 Russia 146171015 1.86% 1 Jan 20 21 National an~\r## 10 10 Mexico 126014024 1.60% 2 Mar 20 20 2020 census~\r # remove = FALSE\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = FALSE)\r ## # A tibble: 10 x 10\r## Rank Country Population `% of world` Day Month Year seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 20 20 Sevent~\r## 2 2 India 1377123716 17.5% 19 May 2021 20 21 Nation~\r## 3 3 United ~ 331695937 4.22% 19 May 2021 20 21 Nation~\r## 4 4 Indones~ 271350000 3.45% 31 Dec 2020 20 20 Nation~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 20 21 UN pro~\r## 6 6 Brazil 213154869 2.71% 19 May 2021 20 21 Nation~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 20 21 UN pro~\r## 8 8 Banglad~ 170689832 2.17% 19 May 2021 20 21 Nation~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 20 21 Nation~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 20 20 2020 c~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Eu gosto de utilizar esse argumento quando eu tenho dúvida sobre o resultado e quero fazer inspeção visual para detectar eventuais problemas na separação ou junção. Uma vez que estou satisfeito com o resultado, em geral eu uso o remove=TRUE. Vocês tem que decidir se precisam manter as colunas originais ou se a coluna transformada é o suficiente.\nCompare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?  A resposta curta é simples: em pivot_wider, podemos ter aqueles missings \u0026ldquo;implícitos\u0026rdquo; que não apareciam no nosso banco longo e, durante a transformação, eles viram NAs nas colunas. Ó argumento values_fill indica um valor para ser preenchido no lugar de NA.\nEm complete, temos uma situação similar. O que fazer quando for encontrada uma combinação de valores no banco longo que é um \u0026ldquo;missing implícito\u0026rdquo;? Você pode especificar um valor padrão para preenchê-lo.\nSão funções similares, mas uma funciona sem reformatar o banco e a outra durante o processo de reformatação. Veja um exemplo abaixo com aquela tibble das ações.\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\racoes\r ## # A tibble: 7 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 2 0.92\r## 6 2016 3 0.17\r## 7 2016 4 2.66\r # Vamos supor que o NA implícito significa que a empresa teve # lucro = 0 naquele quadrimestre.\r# pivot_wider, values_fill\racoes %\u0026gt;% pivot_wider(\rid_cols = ano,\rnames_from = qdr,\rvalues_from = lucro,\rvalues_fill = 0\r)\r ## # A tibble: 2 x 5\r## ano `1` `2` `3` `4`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1.88 0.59 0.35 NA ## 2 2016 0 0.92 0.17 2.66\r # complete, fill\racoes %\u0026gt;% complete(ano, qdr, fill = list(lucro = 0))\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 0 ## 5 2016 1 0 ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Note o resultado. E note também que values_fill em pivot_wider é um pouco mais criterioso na hora de fazer as transformações.\nstringr, forcats e dplyr library(nycflights13)\r   Encontre os vôos que:\n  Atrasaram mais de duas horas\n  flights %\u0026gt;% filter(dep_delay \u0026gt; 120)\r ## # A tibble: 9,723 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 848 1835 853 1001 1950\r## 2 2013 1 1 957 733 144 1056 853\r## 3 2013 1 1 1114 900 134 1447 1222\r## 4 2013 1 1 1540 1338 122 2020 1825\r## 5 2013 1 1 1815 1325 290 2120 1542\r## 6 2013 1 1 1842 1422 260 1958 1535\r## 7 2013 1 1 1856 1645 131 2212 2005\r## 8 2013 1 1 1934 1725 129 2126 1855\r## 9 2013 1 1 1938 1703 155 2109 1823\r## 10 2013 1 1 1942 1705 157 2124 1830\r## # ... with 9,713 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Com destino a Houston (IAH ou HOU)  flights %\u0026gt;% filter(dest %in% c(\u0026quot;IAH\u0026quot;, \u0026quot;HOU\u0026quot;))\r ## # A tibble: 9,313 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 623 627 -4 933 932\r## 4 2013 1 1 728 732 -4 1041 1038\r## 5 2013 1 1 739 739 0 1104 1038\r## 6 2013 1 1 908 908 0 1228 1219\r## 7 2013 1 1 1028 1026 2 1350 1339\r## 8 2013 1 1 1044 1045 -1 1352 1351\r## 9 2013 1 1 1114 900 134 1447 1222\r## 10 2013 1 1 1205 1200 5 1503 1505\r## # ... with 9,303 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Operados pela United, American ou Delta  unique(flights$carrier)\r ## [1] \u0026quot;UA\u0026quot; \u0026quot;AA\u0026quot; \u0026quot;B6\u0026quot; \u0026quot;DL\u0026quot; \u0026quot;EV\u0026quot; \u0026quot;MQ\u0026quot; \u0026quot;US\u0026quot; \u0026quot;WN\u0026quot; \u0026quot;VX\u0026quot; \u0026quot;FL\u0026quot; \u0026quot;AS\u0026quot; \u0026quot;9E\u0026quot; \u0026quot;F9\u0026quot; \u0026quot;HA\u0026quot; \u0026quot;YV\u0026quot;\r## [16] \u0026quot;OO\u0026quot;\r flights %\u0026gt;% filter(carrier %in% c(\u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;DL\u0026quot;))\r ## # A tibble: 139,504 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 554 600 -6 812 837\r## 5 2013 1 1 554 558 -4 740 728\r## 6 2013 1 1 558 600 -2 753 745\r## 7 2013 1 1 558 600 -2 924 917\r## 8 2013 1 1 558 600 -2 923 937\r## 9 2013 1 1 559 600 -1 941 910\r## 10 2013 1 1 559 600 -1 854 902\r## # ... with 139,494 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre julho e setembro  flights %\u0026gt;% filter(between(month, 7, 9))\r ## # A tibble: 86,326 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 7 1 1 2029 212 236 2359\r## 2 2013 7 1 2 2359 3 344 344\r## 3 2013 7 1 29 2245 104 151 1\r## 4 2013 7 1 43 2130 193 322 14\r## 5 2013 7 1 44 2150 174 300 100\r## 6 2013 7 1 46 2051 235 304 2358\r## 7 2013 7 1 48 2001 287 308 2305\r## 8 2013 7 1 58 2155 183 335 43\r## 9 2013 7 1 100 2146 194 327 30\r## 10 2013 7 1 100 2245 135 337 135\r## # ... with 86,316 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Chegaram com mais de duas horas de atraso, mas não decolaram com atraso  flights %\u0026gt;% filter(arr_delay \u0026gt; 120, dep_delay \u0026lt;= 0)\r ## # A tibble: 29 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 27 1419 1420 -1 1754 1550\r## 2 2013 10 7 1350 1350 0 1736 1526\r## 3 2013 10 7 1357 1359 -2 1858 1654\r## 4 2013 10 16 657 700 -3 1258 1056\r## 5 2013 11 1 658 700 -2 1329 1015\r## 6 2013 3 18 1844 1847 -3 39 2219\r## 7 2013 4 17 1635 1640 -5 2049 1845\r## 8 2013 4 18 558 600 -2 1149 850\r## 9 2013 4 18 655 700 -5 1213 950\r## 10 2013 5 22 1827 1830 -3 2217 2010\r## # ... with 19 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo  flights %\u0026gt;% filter(dep_delay \u0026gt; 60, dep_delay - arr_delay \u0026gt;= 30)\r ## # A tibble: 2,046 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 1716 1545 91 2140 2039\r## 2 2013 1 1 2205 1720 285 46 2040\r## 3 2013 1 1 2326 2130 116 131 18\r## 4 2013 1 3 1503 1221 162 1803 1555\r## 5 2013 1 3 1821 1530 171 2131 1910\r## 6 2013 1 3 1839 1700 99 2056 1950\r## 7 2013 1 3 1850 1745 65 2148 2120\r## 8 2013 1 3 1923 1815 68 2036 1958\r## 9 2013 1 3 1941 1759 102 2246 2139\r## 10 2013 1 3 1950 1845 65 2228 2227\r## # ... with 2,036 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre a meia-noite e 6 da manhã (inclusive)  flights %\u0026gt;% filter(between(hour, 0, 5) | (hour == 6 \u0026amp; minute == 0))\r ## # A tibble: 8,970 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 8,960 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).  flights %\u0026gt;% select(air_time, distance) %\u0026gt;% mutate(speed = distance/air_time) %\u0026gt;% arrange(desc(speed))\r ## # A tibble: 336,776 x 3\r## air_time distance speed\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 65 762 11.7 ## 2 93 1008 10.8 ## 3 55 594 10.8 ## 4 70 748 10.7 ## 5 105 1035 9.86\r## 6 170 1598 9.4 ## 7 172 1598 9.29\r## 8 175 1623 9.27\r## 9 173 1598 9.24\r## 10 173 1598 9.24\r## # ... with 336,766 more rows\r Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.  flights %\u0026gt;% select(dep_time, dep_delay, arr_time, arr_delay)\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(matches(\u0026quot;^arr|^dep\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(!starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;car\u0026quot;)) \u0026amp; contains(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(ends_with(c(\u0026quot;time\u0026quot;, \u0026quot;delay\u0026quot;)) \u0026amp; !starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;air\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time arr_time dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 830 2 11\r## 2 533 850 4 20\r## 3 542 923 2 33\r## 4 544 1004 -1 -18\r## 5 554 812 -6 -25\r## 6 554 740 -4 12\r## 7 555 913 -5 19\r## 8 557 709 -3 -14\r## 9 557 838 -3 -8\r## 10 558 753 -2 8\r## # ... with 336,766 more rows\r As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.  flights %\u0026gt;% mutate(\rdep_hour = dep_time %/% 100,\rdep_minute = dep_time %% 100,\rsched_dep_hour = sched_dep_time %/% 100,\rsched_arr_minute = sched_arr_time %% 100\r)\r ## # A tibble: 336,776 x 23\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 15 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;,\r## # dep_hour \u0026lt;dbl\u0026gt;, dep_minute \u0026lt;dbl\u0026gt;, sched_dep_hour \u0026lt;dbl\u0026gt;,\r## # sched_arr_minute \u0026lt;dbl\u0026gt;\r # Há uma outra solução com separate!\rflights %\u0026gt;% separate(\rcol = dep_time,\rinto = c(\u0026quot;dep_hour\u0026quot;, \u0026quot;dep_minute\u0026quot;),\rsep = 1,\r# Esse argumento é importante! Teste com FALSE para ver a diferença\rconvert = TRUE) %\u0026gt;% separate(\rcol = sched_dep_time,\rinto = c(\u0026quot;sched_dep_hour\u0026quot;, \u0026quot;sched_dep_minute\u0026quot;),\rsep = 1,\rconvert = TRUE)\r ## # A tibble: 336,776 x 21\r## year month day dep_hour dep_minute sched_dep_hour sched_dep_minute\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 17 5 15\r## 2 2013 1 1 5 33 5 29\r## 3 2013 1 1 5 42 5 40\r## 4 2013 1 1 5 44 5 45\r## 5 2013 1 1 5 54 6 0\r## 6 2013 1 1 5 54 5 58\r## 7 2013 1 1 5 55 6 0\r## 8 2013 1 1 5 57 6 0\r## 9 2013 1 1 5 57 6 0\r## 10 2013 1 1 5 58 6 0\r## # ... with 336,766 more rows, and 14 more variables: dep_delay \u0026lt;dbl\u0026gt;,\r## # arr_time \u0026lt;int\u0026gt;, sched_arr_time \u0026lt;int\u0026gt;, arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Existe uma outra solução possível para essa questão usando manipulação de strings, com str_sub também. Fica como desafio!\nPensando na legibilidade do código e na flexibilidade da abordagem, qual das duas soluções acima você implementaria? mutate ou duas separate? Reflita.\nO que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Essa tem uma resposta mais qualitativa. A primeira parte é parecida com a questão anterior, mas estamos manualmente tentando calcular os tempos de viagem. Acontece que os valores não batem com os tempos de vôo identificados no banco. Isso se deve a pelo menos três questões distintas.\n Uma delas diz respeito ao registro dos tempos, a definição de air_time pode não estar considerando tempos em que o avião está manobrando ou em solo ou mesmo podem existir erros de preenchimento. A segunda diz respeito ao fuso horário distinto entre aeroportos de saída e chegada, que complica o cálculo dos tempos reais, então nosso cálculo está muito cru para identificar isso. A última questão são os vôos longos, que começam em um dia e terminam no dia seguinte, que podem prejudicar nosso método de cálculo. Para corrigir alguns desses problemas, você precisaria escrever um código que minimamente levasse essas questões em consideração. Como esse não é o objetivo do curso, eu deixo para quem quiser tentar. Há uma solução postada aqui.  Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\rstr_c(z, w, y, sep = \u0026quot; \u0026quot;) %\u0026gt;% str_c(x, sep = \u0026quot;\u0026quot;) %\u0026gt;% str_to_sentence()\r ## [1] \u0026quot;Hoje acordei feliz.\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r# Sem dplyr\rdf$pais \u0026lt;- str_to_title(df$pais)\rdf$primeiro_nome \u0026lt;- str_to_title(df$primeiro_nome)\rdf$segundo_nome \u0026lt;- str_to_title(df$segundo_nome)\rdf \u0026lt;- df %\u0026gt;% tidyr::unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;)\rdf[ str_order(df$nomes), ]\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r # Com dplyr\rdf \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\rdf %\u0026gt;% mutate(pais = str_to_title(pais),\rprimeiro_nome = str_to_title(primeiro_nome),\rsegundo_nome = str_to_title(segundo_nome)) %\u0026gt;% unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;) %\u0026gt;% arrange(str_order(nomes))\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r x \u0026lt;- c(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\rx[1] \u0026lt;- str_sub(x[1], 1, 1) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[2] \u0026lt;- str_sub(x[2], 4, 4) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[3] \u0026lt;- str_to_upper(x[3])\rstr_c(c(x[3], x[1], x[2]), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;MAIA V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: \u0026ldquo;150\u0026rdquo;, \u0026ldquo;219\u0026rdquo;, \u0026ldquo;312\u0026rdquo;, \u0026ldquo;471\u0026rdquo;. Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;118\u0026quot; \u0026quot;114\u0026quot; \u0026quot;118\u0026quot; \u0026quot;120\u0026quot; \u0026quot;109\u0026quot; \u0026quot;104\u0026quot; \u0026quot;114\u0026quot; \u0026quot;117\u0026quot; \u0026quot;122\u0026quot; \u0026quot;109\u0026quot; \u0026quot;110\u0026quot; \u0026quot;113\u0026quot;\r## [13] \u0026quot;106\u0026quot; \u0026quot;100\u0026quot; \u0026quot;122\u0026quot; \u0026quot;121\u0026quot; \u0026quot;124\u0026quot; \u0026quot;124\u0026quot; \u0026quot;110\u0026quot; \u0026quot;100\u0026quot; \u0026quot;117\u0026quot; \u0026quot;119\u0026quot; \u0026quot;105\u0026quot; \u0026quot;118\u0026quot;\r## [25] \u0026quot;122\u0026quot; \u0026quot;201\u0026quot; \u0026quot;205\u0026quot; \u0026quot;212\u0026quot; \u0026quot;216\u0026quot; \u0026quot;228\u0026quot; \u0026quot;213\u0026quot; \u0026quot;227\u0026quot; \u0026quot;221\u0026quot; \u0026quot;214\u0026quot; \u0026quot;227\u0026quot; \u0026quot;206\u0026quot;\r## [37] \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;224\u0026quot; \u0026quot;223\u0026quot; \u0026quot;203\u0026quot; \u0026quot;221\u0026quot; \u0026quot;215\u0026quot; \u0026quot;225\u0026quot; \u0026quot;210\u0026quot; \u0026quot;208\u0026quot; \u0026quot;219\u0026quot; \u0026quot;207\u0026quot;\r## [49] \u0026quot;221\u0026quot; \u0026quot;227\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;301\u0026quot; \u0026quot;304\u0026quot; \u0026quot;310\u0026quot; \u0026quot;307\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;308\u0026quot; \u0026quot;306\u0026quot;\r## [61] \u0026quot;308\u0026quot; \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;306\u0026quot; \u0026quot;302\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;301\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;304\u0026quot;\r## [73] \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;307\u0026quot; \u0026quot;401\u0026quot; \u0026quot;459\u0026quot; \u0026quot;429\u0026quot; \u0026quot;435\u0026quot; \u0026quot;435\u0026quot; \u0026quot;415\u0026quot; \u0026quot;475\u0026quot; \u0026quot;414\u0026quot; \u0026quot;419\u0026quot;\r## [85] \u0026quot;495\u0026quot; \u0026quot;475\u0026quot; \u0026quot;431\u0026quot; \u0026quot;460\u0026quot; \u0026quot;478\u0026quot; \u0026quot;447\u0026quot; \u0026quot;436\u0026quot; \u0026quot;412\u0026quot; \u0026quot;403\u0026quot; \u0026quot;423\u0026quot; \u0026quot;467\u0026quot; \u0026quot;438\u0026quot;\r## [97] \u0026quot;475\u0026quot; \u0026quot;467\u0026quot; \u0026quot;418\u0026quot; \u0026quot;476\u0026quot;\r # Esse exercício é um pouco mais difícil mesmo!\rx %\u0026gt;% str_extract(\u0026quot;\\\\d\u0026quot;)\r ## [1] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot;\r## [19] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot;\r## [37] \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [55] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [73] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r## [91] \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r tibble(\rtipo_idade = str_sub(x, 1, 1),\ridade = str_sub(x, 2, 3),\ridade_anos =\rif_else(\rstr_detect(tipo_idade, \u0026quot;1\u0026quot;),\ras.numeric(idade) / (24 * 30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;2\u0026quot;),\ras.numeric(idade) / (30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;3\u0026quot;),\ras.numeric(idade) / 12,\ras.numeric(idade)\r)\r)\r)\r) %\u0026gt;% print(n = Inf)\r ## # A tibble: 100 x 3\r## tipo_idade idade idade_anos\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 18 0.00208 ## 2 1 14 0.00162 ## 3 1 18 0.00208 ## 4 1 20 0.00231 ## 5 1 09 0.00104 ## 6 1 04 0.000463\r## 7 1 14 0.00162 ## 8 1 17 0.00197 ## 9 1 22 0.00255 ## 10 1 09 0.00104 ## 11 1 10 0.00116 ## 12 1 13 0.00150 ## 13 1 06 0.000694\r## 14 1 00 0 ## 15 1 22 0.00255 ## 16 1 21 0.00243 ## 17 1 24 0.00278 ## 18 1 24 0.00278 ## 19 1 10 0.00116 ## 20 1 00 0 ## 21 1 17 0.00197 ## 22 1 19 0.00220 ## 23 1 05 0.000579\r## 24 1 18 0.00208 ## 25 1 22 0.00255 ## 26 2 01 0.00278 ## 27 2 05 0.0139 ## 28 2 12 0.0333 ## 29 2 16 0.0444 ## 30 2 28 0.0778 ## 31 2 13 0.0361 ## 32 2 27 0.075 ## 33 2 21 0.0583 ## 34 2 14 0.0389 ## 35 2 27 0.075 ## 36 2 06 0.0167 ## 37 2 07 0.0194 ## 38 2 15 0.0417 ## 39 2 24 0.0667 ## 40 2 23 0.0639 ## 41 2 03 0.00833 ## 42 2 21 0.0583 ## 43 2 15 0.0417 ## 44 2 25 0.0694 ## 45 2 10 0.0278 ## 46 2 08 0.0222 ## 47 2 19 0.0528 ## 48 2 07 0.0194 ## 49 2 21 0.0583 ## 50 2 27 0.075 ## 51 3 10 0.833 ## 52 3 05 0.417 ## 53 3 01 0.0833 ## 54 3 04 0.333 ## 55 3 10 0.833 ## 56 3 07 0.583 ## 57 3 05 0.417 ## 58 3 09 0.75 ## 59 3 08 0.667 ## 60 3 06 0.5 ## 61 3 08 0.667 ## 62 3 05 0.417 ## 63 3 04 0.333 ## 64 3 03 0.25 ## 65 3 06 0.5 ## 66 3 02 0.167 ## 67 3 10 0.833 ## 68 3 06 0.5 ## 69 3 01 0.0833 ## 70 3 10 0.833 ## 71 3 06 0.5 ## 72 3 04 0.333 ## 73 3 05 0.417 ## 74 3 04 0.333 ## 75 3 07 0.583 ## 76 4 01 1 ## 77 4 59 59 ## 78 4 29 29 ## 79 4 35 35 ## 80 4 35 35 ## 81 4 15 15 ## 82 4 75 75 ## 83 4 14 14 ## 84 4 19 19 ## 85 4 95 95 ## 86 4 75 75 ## 87 4 31 31 ## 88 4 60 60 ## 89 4 78 78 ## 90 4 47 47 ## 91 4 36 36 ## 92 4 12 12 ## 93 4 03 3 ## 94 4 23 23 ## 95 4 67 67 ## 96 4 38 38 ## 97 4 75 75 ## 98 4 67 67 ## 99 4 18 18 ## 100 4 76 76\r Ao invés de utilizar essas chamadas recursivas de if_else, que são muito ruins de ler, como você poderia reescrever a condição usando case_when?\nExplore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?  gss_cat %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r Em geral, contagens de variáveis ficam bem em gráficos de barras ou visualizações equivalentes, em que é possível comparar visualmente as contagens das diversas categorias. Mais sobre isso na aula do ggplot2.\nQual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?  # Religião\rgss_cat %\u0026gt;% count(relig) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 15 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Protestant 10846\r## 2 Catholic 5124\r## 3 None 3523\r## 4 Christian 689\r## 5 Jewish 388\r## 6 Other 224\r## 7 Buddhism 147\r## 8 Inter-nondenominational 109\r## 9 Moslem/islam 104\r## 10 Orthodox-christian 95\r## 11 No answer 93\r## 12 Hinduism 71\r## 13 Other eastern 32\r## 14 Native american 23\r## 15 Don't know 15\r # Partido\rgss_cat %\u0026gt;% count(partyid) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Independent 4119\r## 2 Not str democrat 3690\r## 3 Strong democrat 3490\r## 4 Not str republican 3032\r## 5 Ind,near dem 2499\r## 6 Strong republican 2314\r## 7 Ind,near rep 1791\r## 8 Other party 393\r## 9 No answer 154\r## 10 Don't know 1\r A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?  Você pode chamar count com várias variáveis para fazer uma tabulação cruzada.\ngss_cat %\u0026gt;% count(relig, denom) %\u0026gt;% print(n = Inf)\r ## # A tibble: 47 x 3\r## relig denom n\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer No answer 93\r## 2 Don't know Not applicable 15\r## 3 Inter-nondenominational Not applicable 109\r## 4 Native american Not applicable 23\r## 5 Christian No answer 2\r## 6 Christian Don't know 11\r## 7 Christian No denomination 452\r## 8 Christian Not applicable 224\r## 9 Orthodox-christian Not applicable 95\r## 10 Moslem/islam Not applicable 104\r## 11 Other eastern Not applicable 32\r## 12 Hinduism Not applicable 71\r## 13 Buddhism Not applicable 147\r## 14 Other No denomination 7\r## 15 Other Not applicable 217\r## 16 None Not applicable 3523\r## 17 Jewish Not applicable 388\r## 18 Catholic Not applicable 5124\r## 19 Protestant No answer 22\r## 20 Protestant Don't know 41\r## 21 Protestant No denomination 1224\r## 22 Protestant Other 2534\r## 23 Protestant Episcopal 397\r## 24 Protestant Presbyterian-dk wh 244\r## 25 Protestant Presbyterian, merged 67\r## 26 Protestant Other presbyterian 47\r## 27 Protestant United pres ch in us 110\r## 28 Protestant Presbyterian c in us 104\r## 29 Protestant Lutheran-dk which 267\r## 30 Protestant Evangelical luth 122\r## 31 Protestant Other lutheran 30\r## 32 Protestant Wi evan luth synod 71\r## 33 Protestant Lutheran-mo synod 212\r## 34 Protestant Luth ch in america 71\r## 35 Protestant Am lutheran 146\r## 36 Protestant Methodist-dk which 239\r## 37 Protestant Other methodist 33\r## 38 Protestant United methodist 1067\r## 39 Protestant Afr meth ep zion 32\r## 40 Protestant Afr meth episcopal 77\r## 41 Protestant Baptist-dk which 1457\r## 42 Protestant Other baptists 213\r## 43 Protestant Southern baptist 1536\r## 44 Protestant Nat bapt conv usa 40\r## 45 Protestant Nat bapt conv of am 76\r## 46 Protestant Am bapt ch in usa 130\r## 47 Protestant Am baptist asso 237\r Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?  A melhor função para redução de fatores é fct_collapse. Veja como ficam a coluna original e a transformada.\ngss_cat2 \u0026lt;- gss_cat %\u0026gt;% # Aqui vou salvar em \u0026quot;rincome2\u0026quot; para a gente poder ver as duas\rmutate(rincome2 = fct_collapse(\rrincome,\r\u0026quot;Non-response\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Refused\u0026quot;, \u0026quot;Not applicable\u0026quot;),\r\u0026quot;Até 5k\u0026quot; = c(\u0026quot;$4000 to 4999\u0026quot;, \u0026quot;$3000 to 3999\u0026quot;, \u0026quot;$1000 to 2999\u0026quot;, \u0026quot;Lt $1000\u0026quot;),\r\u0026quot;5k-10k\u0026quot; = c( \u0026quot;$8000 to 9999\u0026quot;, \u0026quot;$7000 to 7999\u0026quot;, \u0026quot;$6000 to 6999\u0026quot;, \u0026quot;$5000 to 5999\u0026quot;),\r\u0026quot;10k-20k\u0026quot; = c(\u0026quot;$15000 - 19999\u0026quot;, \u0026quot;$10000 - 14999\u0026quot;),\r\u0026quot;20k+\u0026quot; = c(\u0026quot;$25000 or more\u0026quot;, \u0026quot;$20000 - 24999\u0026quot;))) %\u0026gt;% select(rincome, rincome2)\r# E veja as contagens\rgss_cat2 %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r gss_cat2 %\u0026gt;% count(rincome2)\r ## # A tibble: 5 x 2\r## rincome2 n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Non-response 8468\r## 2 20k+ 8646\r## 3 10k-20k 2216\r## 4 5k-10k 970\r## 5 Até 5k 1183\r ggplot2  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r Os pontos não ficam azuis porque você não está especificando cores! Dentro da função aes() você está especificando variáveis para serem mapeadas a uma escala de cores. Portanto, o ggplot interpreta \u0026ldquo;blue\u0026rdquo; como uma variável sem nome que tem o valor \u0026ldquo;blue\u0026rdquo; e mapeia ela para a escala de cores padrão, que é vermelha. Se você quer controlar apenas a \u0026ldquo;aparência\u0026rdquo; dos pontos e não está preocupada em mapear nenhuma variável, você pode passar essa estética fora da função aes().\nggplot(data = mpg) + geom_point(\rmapping = aes(x = displ, y = hwy), # aqui acabam os mapeamentos estéticos\rcolor = \u0026quot;blue\u0026quot;, # alteração apenas na aparência do geom\rsize = 2, # alteração apenas na aparência do geom\rshape = 6 # alteração apenas na aparência do geom\r)  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?  ggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point()\r ## Warning: The shape palette can deal with a maximum of 6 discrete values because\r## more than 6 becomes difficult to discriminate; you have 15. Consider\r## specifying shapes manually if you must have them.\r ## Warning: Removed 112 rows containing missing values (geom_point).\r Ao cumprir as instruções como dadas, logo de cara você recebe um aviso do ggplot2. A paleta de \u0026ldquo;shapes\u0026rdquo; só recebe por padrão 6 shapes diferentes, porque de acordo com o autor, mais de 6 torna difícil de distinguir. Mas eu sou teimoso.\nggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point() +\rscale_shape_manual(values = 1:15, guide = \u0026quot;legend\u0026quot;)\r Esse gráfico é mais um exemplo para vocês verem como diferentes escalas se comportam. A variável cyl é numérica e ordenada, então faz sentido colocá-la num mapeamento como size, já que visualmente é possível indicar que a grandeza aumenta com o tamanho. Classe é uma variável categórica, então ela fica melhor em mapeamentos que ressaltam diferenças entre as categorias, como colors ou shapes. O pacote também impõe algumas restrições sobre o que é possível mapear. Por exemplo, ele retorna erro se você tenta mapear uma variável discreta para uma escala contínua.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rscale_color_continuous()\r ## Error: Discrete value supplied to continuous scale\r Experimentem tentar mapear diferentes variáveis no banco mpg para as diferentes escalas e vejam os resultados. Em alguns casos, é possível, mas o gráfico é pouco informativo, em outros, você verá mensagens de erro.\nUtilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.  Esse exercício não tem uma resposta correta. O objetivo era que vocês explorassem as transformações estatísticas e as escalas de cores diferentes presentes no ggplot, através do argumento trans, ou mesmo fazer outras transformações que interessassem vocês nas variáveis. Abaixo um exemplo de transformação de Yeo-Johnson, um tipo de transformação BoxCox que aceita valores negativos e uma das escalas de cor do pacote viridis.\nggplot(diamonds, aes(carat, price, color = clarity)) +\rgeom_point() +\rscale_x_continuous(trans = scales::yj_trans(p = 2)) +\rscale_color_viridis_d(option = \u0026quot;magma\u0026quot;)\r Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.  Segundo a mesma lógica, o objetivo era explorar as opções de visualização de modelos simples através do argumento method. Abaixo um exemplo de gam. Uma mudança que fiz foi usar a variável cut ao invés de clarity, porque o gráfico não-transformado de clarity estava muito poluído.\nggplot(diamonds, aes(carat, price, color = cut)) +\rgeom_point(alpha = 0.1) + # pontos translúcidos para reduzir a poluição\rgeom_smooth(method = \u0026quot;gam\u0026quot;, se = FALSE) +\rscale_color_viridis_d(option = \u0026quot;plasma\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ s(x, bs = \u0026quot;cs\u0026quot;)'\r No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r Acabei explicando isso na aula, devido a uma pergunta, mas para quem perdeu, trata-se do comportamento padrão quando há proporções: cada barra terá sua própria proporção e todas somarão a 100%. O uso de group = 1 indica à função que as proporções que somam a 100% são o total dos níveis do fator e não cada nível individualmente.\nggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop), group = 1))\r # No caso em que há um \u0026quot;fill\u0026quot;, precisamos normalizar as alturas das barras\rggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(prop),\rfill = clarity\r))\r ggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(count)/sum(stat(count)),\rfill = clarity\r))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  geom_smooth chama stat_smooth quando você utiliza a função para calcular as \u0026ldquo;médias condicionais\u0026rdquo; que correspondem a linha de tendência desenhada no gráfico. É assim com todos os geoms no pacote. Há uma conexão entre o objeto geométrico e uma transformação estatística. Mesmo que seja a transformação _identity, que mantém a variável exatamente como ela estava no dado. A grande vantagem de construir um gráfico com stat_smooth ao invés de geom_smooth é que você pode especificar outro objeto geométrico que não seja o padrão (geom_line + geom_ribbon). É isso que os gráficos abaixo demonstram.\nggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.  Esse aqui é para demonstrar o uso de facet_grid, que permite especificar fatores de classificação diferentes nas linhas e colunas, diferente de facet_wrap mostrado na aula, que só permite especificar uma dimensão.\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rfacet_grid(cyl ~ drv)\r Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Mesmo antes de rodar o código, o observador astuto notará que os mapeamentos locais no segundo gráfico são idênticos entre si e aos mapeamentos globais, então os dois gráficos são iguais.\nTente recriar o seguinte gráfico  O objetivo dessa era fazer vocês fuçarem um pouco na ajuda para tentar recriar o mais fielmente possível o gráfico final. Não precisava ter acertado, o objetivo era chegar o mais próximo possível.\nggplot(mpg, aes(displ, hwy, color = drv)) +\rgeom_point() +\rgeom_smooth(method = lm, se = FALSE) +\rlabs(x = \u0026quot;Rodovia\u0026quot;, y = \u0026quot;Toneladas\u0026quot;, color = \u0026quot;Tração\u0026quot;) +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r Depois de simplesmente especificar coord_polar, em geral o gráfico fica meio estranho, não tem aquela cara bonita de pizza. É preciso corrigir os seguintes problemas:\n A largura das barras deve ser igual a proporção das contagens, mas a altura deve ser igual a 1! Portanto, eu inverto as coisas e passo as contagens/proporções para \u0026ldquo;x\u0026rdquo; e \u0026ldquo;y\u0026rdquo; fica com o valor fixo = 1.  ggplot(diamonds, aes(\r# calculando as proporções do total,\r# também funciona com o padrão stat(count)\rx = stat(count)/sum(stat(count)),\ry = 1, # altura igual a 1\rfill = cut)) + # cores\rgeom_bar() +\rcoord_polar() + # coordenadas polares\r# opcional: remover aspectos do tema para um visual mais clean\rtheme_void()\r Como desafio, tentem adicionar elementos textuais das proporções no gráfico. O problema a ser resolvido é como posicionar o texto num sistema de coordenadas polares. Boa sorte!\nGráficos de pizza são polêmicos na análise de dados porque nossos olhos não captam bem diferenças entre formatos curvos e complexos, então a comparação entre as categorias fica prejudicada se houverem mais de 2 ou 3. Eu sempre dou preferência para barras. Há um tipo de gráfico de pizza melhorzinho chamado \u0026ldquo;donut plot\u0026rdquo;, em que o meio do círculo é oco, mas eu ainda prefiro as barras.\npurrr  Utilize uma das funções map_ para:  Nos exemplos abaixo, eu utilizo sempre str() no final para facilitar a visualização das listas, mas não é obrigatório utilizar esse comando.\n1. Calcular a média de cada coluna em `mtcars`.\r map(mtcars, mean) %\u0026gt;% str()\r ## List of 11\r## $ mpg : num 20.1\r## $ cyl : num 6.19\r## $ disp: num 231\r## $ hp : num 147\r## $ drat: num 3.6\r## $ wt : num 3.22\r## $ qsec: num 17.8\r## $ vs : num 0.438\r## $ am : num 0.406\r## $ gear: num 3.69\r## $ carb: num 2.81\r 2. Determinar o tipo de cada coluna em `flights`.\r flights %\u0026gt;% map(class) %\u0026gt;% str()\r ## List of 19\r## $ year : chr \u0026quot;integer\u0026quot;\r## $ month : chr \u0026quot;integer\u0026quot;\r## $ day : chr \u0026quot;integer\u0026quot;\r## $ dep_time : chr \u0026quot;integer\u0026quot;\r## $ sched_dep_time: chr \u0026quot;integer\u0026quot;\r## $ dep_delay : chr \u0026quot;numeric\u0026quot;\r## $ arr_time : chr \u0026quot;integer\u0026quot;\r## $ sched_arr_time: chr \u0026quot;integer\u0026quot;\r## $ arr_delay : chr \u0026quot;numeric\u0026quot;\r## $ carrier : chr \u0026quot;character\u0026quot;\r## $ flight : chr \u0026quot;integer\u0026quot;\r## $ tailnum : chr \u0026quot;character\u0026quot;\r## $ origin : chr \u0026quot;character\u0026quot;\r## $ dest : chr \u0026quot;character\u0026quot;\r## $ air_time : chr \u0026quot;numeric\u0026quot;\r## $ distance : chr \u0026quot;numeric\u0026quot;\r## $ hour : chr \u0026quot;numeric\u0026quot;\r## $ minute : chr \u0026quot;numeric\u0026quot;\r## $ time_hour : chr [1:2] \u0026quot;POSIXct\u0026quot; \u0026quot;POSIXt\u0026quot;\r 3. Computar o número de valores únicos em cada coluna de `iris`.\r flights %\u0026gt;% map(unique) %\u0026gt;% map(length) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r # Sugestão do Pedro Gomes\rflights %\u0026gt;% map(n_distinct) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r 4. Gere 10 distribuições aleatórias (`rnorm`) com médias -10, 0, 10 e 100.\r x \u0026lt;- rep(100, 40)\rmedias \u0026lt;- rep(c(-10, 0, 10, 100), each = 10)\rmap2(x, medias, ~rnorm(.x, mean = .y)) %\u0026gt;% str()\r ## List of 40\r## $ : num [1:100] -9.96 -9.53 -9.12 -9.64 -10.36 ...\r## $ : num [1:100] -11.71 -10.76 -9.41 -9.22 -10.53 ...\r## $ : num [1:100] -11.33 -9.51 -8.98 -10.91 -9.52 ...\r## $ : num [1:100] -11.4 -10.9 -10.7 -12.1 -9.8 ...\r## $ : num [1:100] -11.06 -10.66 -10.33 -9.13 -9.13 ...\r## $ : num [1:100] -10.22 -9.59 -9.81 -10.71 -10.24 ...\r## $ : num [1:100] -11 -9.14 -10.91 -9.38 -9.63 ...\r## $ : num [1:100] -9.83 -9.61 -11.23 -9.68 -10.47 ...\r## $ : num [1:100] -9.11 -10.03 -10.62 -9.65 -10.2 ...\r## $ : num [1:100] -9.06 -10.41 -10.84 -9.16 -9.41 ...\r## $ : num [1:100] -0.8378 0.1102 0.7519 -0.2477 0.0342 ...\r## $ : num [1:100] 0.607 -0.902 -2.185 -0.397 -1.019 ...\r## $ : num [1:100] -0.452 2.067 1.45 -1.184 0.893 ...\r## $ : num [1:100] -0.604 -0.783 1.767 -0.632 1.322 ...\r## $ : num [1:100] -2.515 0.43 0.694 1.239 1.091 ...\r## $ : num [1:100] -1.462 1.177 -0.376 0.037 0.387 ...\r## $ : num [1:100] -0.0803 -0.0421 2.4765 0.0509 -0.1479 ...\r## $ : num [1:100] 1.118 0.662 -1.439 -1.074 0.493 ...\r## $ : num [1:100] -0.3136 0.4455 -0.947 2.0658 -0.0188 ...\r## $ : num [1:100] 0.193 0.625 2.281 0.297 -0.629 ...\r## $ : num [1:100] 9.29 9.1 9.54 9.99 10.2 ...\r## $ : num [1:100] 7.96 7.32 10.7 9.13 10.3 ...\r## $ : num [1:100] 9.96 10.24 10.31 10.54 11.65 ...\r## $ : num [1:100] 10.88 10.41 8.19 10.37 10.28 ...\r## $ : num [1:100] 11.27 9.74 11.75 11.7 9.31 ...\r## $ : num [1:100] 9.62 11.35 10.78 10.79 9.7 ...\r## $ : num [1:100] 9.04 10.24 11.85 9.82 10.66 ...\r## $ : num [1:100] 10.48 6.97 8.97 9.69 11.03 ...\r## $ : num [1:100] 8.48 10.12 9.09 8.18 10.11 ...\r## $ : num [1:100] 9.97 9.27 10.19 10.93 11.07 ...\r## $ : num [1:100] 100 99.2 99.6 100.3 99.2 ...\r## $ : num [1:100] 99 99.9 100.7 98.7 99.7 ...\r## $ : num [1:100] 99.6 99.2 100.1 100 99.9 ...\r## $ : num [1:100] 100.5 100.4 100.2 98.4 98.9 ...\r## $ : num [1:100] 99.8 99.8 100 99.1 101.1 ...\r## $ : num [1:100] 100.7 100 100.1 98.6 100 ...\r## $ : num [1:100] 99 99.4 100.5 100.1 99.3 ...\r## $ : num [1:100] 99.2 98.6 99.2 100.9 97.4 ...\r## $ : num [1:100] 99.7 99.8 100.9 100.5 99.9 ...\r## $ : num [1:100] 99.5 100.9 98.5 99.7 100 ...\r Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?  # Flights por exemplo\rflights %\u0026gt;% # Lembrem-se que a pergunta pedia para criar um vetor!\rmap_lgl(is.factor)\r ## year month day dep_time sched_dep_time ## FALSE FALSE FALSE FALSE FALSE ## dep_delay arr_time sched_arr_time arr_delay carrier ## FALSE FALSE FALSE FALSE FALSE ## flight tailnum origin dest air_time ## FALSE FALSE FALSE FALSE FALSE ## distance hour minute time_hour ## FALSE FALSE FALSE FALSE\r  Usando as funções predicado keep e discard:\n Selecione todas as colunas caractere no banco flights.    flights %\u0026gt;% keep(is.character)\r ## # A tibble: 336,776 x 4\r## carrier tailnum origin dest ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 UA N14228 EWR IAH ## 2 UA N24211 LGA IAH ## 3 AA N619AA JFK MIA ## 4 B6 N804JB JFK BQN ## 5 DL N668DN LGA ATL ## 6 UA N39463 EWR ORD ## 7 B6 N516JB EWR FLL ## 8 EV N829AS LGA IAD ## 9 B6 N593JB JFK MCO ## 10 AA N3ALAA LGA ORD ## # ... with 336,766 more rows\r 2. Descarte os caracteres em `mpg`.\r mpg %\u0026gt;% discard(is.character)\r ## # A tibble: 234 x 5\r## displ year cyl cty hwy\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1.8 1999 4 18 29\r## 2 1.8 1999 4 21 29\r## 3 2 2008 4 20 31\r## 4 2 2008 4 21 30\r## 5 2.8 1999 6 16 26\r## 6 2.8 1999 6 18 26\r## 7 3.1 2008 6 18 27\r## 8 1.8 1999 4 18 26\r## 9 1.8 1999 4 16 25\r## 10 2 2008 4 20 28\r## # ... with 224 more rows\r 3. Selecione os fatores ordenados em `diamonds`.\r diamonds %\u0026gt;% keep(is.ordered)\r ## # A tibble: 53,940 x 3\r## cut color clarity\r## \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; ## 1 Ideal E SI2 ## 2 Premium E SI1 ## 3 Good E VS1 ## 4 Premium I VS2 ## 5 Good J SI2 ## 6 Very Good J VVS2 ## 7 Very Good I VVS1 ## 8 Very Good H SI1 ## 9 Fair E VS2 ## 10 Very Good H VS1 ## # ... with 53,930 more rows\r 4. Descarte as variáveis não-numéricas em `iris`\r iris %\u0026gt;% discard(negate(is.numeric))\r ## Sepal.Length Sepal.Width Petal.Length Petal.Width\r## 1 5.1 3.5 1.4 0.2\r## 2 4.9 3.0 1.4 0.2\r## 3 4.7 3.2 1.3 0.2\r## 4 4.6 3.1 1.5 0.2\r## 5 5.0 3.6 1.4 0.2\r## 6 5.4 3.9 1.7 0.4\r## 7 4.6 3.4 1.4 0.3\r## 8 5.0 3.4 1.5 0.2\r## 9 4.4 2.9 1.4 0.2\r## 10 4.9 3.1 1.5 0.1\r## 11 5.4 3.7 1.5 0.2\r## 12 4.8 3.4 1.6 0.2\r## 13 4.8 3.0 1.4 0.1\r## 14 4.3 3.0 1.1 0.1\r## 15 5.8 4.0 1.2 0.2\r## 16 5.7 4.4 1.5 0.4\r## 17 5.4 3.9 1.3 0.4\r## 18 5.1 3.5 1.4 0.3\r## 19 5.7 3.8 1.7 0.3\r## 20 5.1 3.8 1.5 0.3\r## 21 5.4 3.4 1.7 0.2\r## 22 5.1 3.7 1.5 0.4\r## 23 4.6 3.6 1.0 0.2\r## 24 5.1 3.3 1.7 0.5\r## 25 4.8 3.4 1.9 0.2\r## 26 5.0 3.0 1.6 0.2\r## 27 5.0 3.4 1.6 0.4\r## 28 5.2 3.5 1.5 0.2\r## 29 5.2 3.4 1.4 0.2\r## 30 4.7 3.2 1.6 0.2\r## 31 4.8 3.1 1.6 0.2\r## 32 5.4 3.4 1.5 0.4\r## 33 5.2 4.1 1.5 0.1\r## 34 5.5 4.2 1.4 0.2\r## 35 4.9 3.1 1.5 0.2\r## 36 5.0 3.2 1.2 0.2\r## 37 5.5 3.5 1.3 0.2\r## 38 4.9 3.6 1.4 0.1\r## 39 4.4 3.0 1.3 0.2\r## 40 5.1 3.4 1.5 0.2\r## 41 5.0 3.5 1.3 0.3\r## 42 4.5 2.3 1.3 0.3\r## 43 4.4 3.2 1.3 0.2\r## 44 5.0 3.5 1.6 0.6\r## 45 5.1 3.8 1.9 0.4\r## 46 4.8 3.0 1.4 0.3\r## 47 5.1 3.8 1.6 0.2\r## 48 4.6 3.2 1.4 0.2\r## 49 5.3 3.7 1.5 0.2\r## 50 5.0 3.3 1.4 0.2\r## 51 7.0 3.2 4.7 1.4\r## 52 6.4 3.2 4.5 1.5\r## 53 6.9 3.1 4.9 1.5\r## 54 5.5 2.3 4.0 1.3\r## 55 6.5 2.8 4.6 1.5\r## 56 5.7 2.8 4.5 1.3\r## 57 6.3 3.3 4.7 1.6\r## 58 4.9 2.4 3.3 1.0\r## 59 6.6 2.9 4.6 1.3\r## 60 5.2 2.7 3.9 1.4\r## 61 5.0 2.0 3.5 1.0\r## 62 5.9 3.0 4.2 1.5\r## 63 6.0 2.2 4.0 1.0\r## 64 6.1 2.9 4.7 1.4\r## 65 5.6 2.9 3.6 1.3\r## 66 6.7 3.1 4.4 1.4\r## 67 5.6 3.0 4.5 1.5\r## 68 5.8 2.7 4.1 1.0\r## 69 6.2 2.2 4.5 1.5\r## 70 5.6 2.5 3.9 1.1\r## 71 5.9 3.2 4.8 1.8\r## 72 6.1 2.8 4.0 1.3\r## 73 6.3 2.5 4.9 1.5\r## 74 6.1 2.8 4.7 1.2\r## 75 6.4 2.9 4.3 1.3\r## 76 6.6 3.0 4.4 1.4\r## 77 6.8 2.8 4.8 1.4\r## 78 6.7 3.0 5.0 1.7\r## 79 6.0 2.9 4.5 1.5\r## 80 5.7 2.6 3.5 1.0\r## 81 5.5 2.4 3.8 1.1\r## 82 5.5 2.4 3.7 1.0\r## 83 5.8 2.7 3.9 1.2\r## 84 6.0 2.7 5.1 1.6\r## 85 5.4 3.0 4.5 1.5\r## 86 6.0 3.4 4.5 1.6\r## 87 6.7 3.1 4.7 1.5\r## 88 6.3 2.3 4.4 1.3\r## 89 5.6 3.0 4.1 1.3\r## 90 5.5 2.5 4.0 1.3\r## 91 5.5 2.6 4.4 1.2\r## 92 6.1 3.0 4.6 1.4\r## 93 5.8 2.6 4.0 1.2\r## 94 5.0 2.3 3.3 1.0\r## 95 5.6 2.7 4.2 1.3\r## 96 5.7 3.0 4.2 1.2\r## 97 5.7 2.9 4.2 1.3\r## 98 6.2 2.9 4.3 1.3\r## 99 5.1 2.5 3.0 1.1\r## 100 5.7 2.8 4.1 1.3\r## 101 6.3 3.3 6.0 2.5\r## 102 5.8 2.7 5.1 1.9\r## 103 7.1 3.0 5.9 2.1\r## 104 6.3 2.9 5.6 1.8\r## 105 6.5 3.0 5.8 2.2\r## 106 7.6 3.0 6.6 2.1\r## 107 4.9 2.5 4.5 1.7\r## 108 7.3 2.9 6.3 1.8\r## 109 6.7 2.5 5.8 1.8\r## 110 7.2 3.6 6.1 2.5\r## 111 6.5 3.2 5.1 2.0\r## 112 6.4 2.7 5.3 1.9\r## 113 6.8 3.0 5.5 2.1\r## 114 5.7 2.5 5.0 2.0\r## 115 5.8 2.8 5.1 2.4\r## 116 6.4 3.2 5.3 2.3\r## 117 6.5 3.0 5.5 1.8\r## 118 7.7 3.8 6.7 2.2\r## 119 7.7 2.6 6.9 2.3\r## 120 6.0 2.2 5.0 1.5\r## 121 6.9 3.2 5.7 2.3\r## 122 5.6 2.8 4.9 2.0\r## 123 7.7 2.8 6.7 2.0\r## 124 6.3 2.7 4.9 1.8\r## 125 6.7 3.3 5.7 2.1\r## 126 7.2 3.2 6.0 1.8\r## 127 6.2 2.8 4.8 1.8\r## 128 6.1 3.0 4.9 1.8\r## 129 6.4 2.8 5.6 2.1\r## 130 7.2 3.0 5.8 1.6\r## 131 7.4 2.8 6.1 1.9\r## 132 7.9 3.8 6.4 2.0\r## 133 6.4 2.8 5.6 2.2\r## 134 6.3 2.8 5.1 1.5\r## 135 6.1 2.6 5.6 1.4\r## 136 7.7 3.0 6.1 2.3\r## 137 6.3 3.4 5.6 2.4\r## 138 6.4 3.1 5.5 1.8\r## 139 6.0 3.0 4.8 1.8\r## 140 6.9 3.1 5.4 2.1\r## 141 6.7 3.1 5.6 2.4\r## 142 6.9 3.1 5.1 2.3\r## 143 5.8 2.7 5.1 1.9\r## 144 6.8 3.2 5.9 2.3\r## 145 6.7 3.3 5.7 2.5\r## 146 6.7 3.0 5.2 2.3\r## 147 6.3 2.5 5.0 1.9\r## 148 6.5 3.0 5.2 2.0\r## 149 6.2 3.4 5.4 2.3\r## 150 5.9 3.0 5.1 1.8\r Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.  # Vamos usar um diretório temporário que vamos preencher com vários tibbles\rpasta \u0026lt;- tempdir()\r# Criamos 100 tibbles e guardamos em 100 arquivos csv.\rx \u0026lt;- rep(10, 100)\rarqs \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:100)\rmap(x, ~tibble(var1 = rnorm(.x), var2 = rnorm(.x))) %\u0026gt;% map2(arqs, ~write_csv(.x, file.path(pasta, .y))) %\u0026gt;% str()\r # Nossos arquivos estão salvos no diretório temporário:\rdir(pasta)\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo10.csv\u0026quot; \u0026quot;arquivo100.csv\u0026quot; \u0026quot;arquivo11.csv\u0026quot; ## [5] \u0026quot;arquivo12.csv\u0026quot; \u0026quot;arquivo13.csv\u0026quot; \u0026quot;arquivo14.csv\u0026quot; \u0026quot;arquivo15.csv\u0026quot; ## [9] \u0026quot;arquivo16.csv\u0026quot; \u0026quot;arquivo17.csv\u0026quot; \u0026quot;arquivo18.csv\u0026quot; \u0026quot;arquivo19.csv\u0026quot; ## [13] \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo20.csv\u0026quot; \u0026quot;arquivo21.csv\u0026quot; \u0026quot;arquivo22.csv\u0026quot; ## [17] \u0026quot;arquivo23.csv\u0026quot; \u0026quot;arquivo24.csv\u0026quot; \u0026quot;arquivo25.csv\u0026quot; \u0026quot;arquivo26.csv\u0026quot; ## [21] \u0026quot;arquivo27.csv\u0026quot; \u0026quot;arquivo28.csv\u0026quot; \u0026quot;arquivo29.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; ## [25] \u0026quot;arquivo30.csv\u0026quot; \u0026quot;arquivo31.csv\u0026quot; \u0026quot;arquivo32.csv\u0026quot; \u0026quot;arquivo33.csv\u0026quot; ## [29] \u0026quot;arquivo34.csv\u0026quot; \u0026quot;arquivo35.csv\u0026quot; \u0026quot;arquivo36.csv\u0026quot; \u0026quot;arquivo37.csv\u0026quot; ## [33] \u0026quot;arquivo38.csv\u0026quot; \u0026quot;arquivo39.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot; \u0026quot;arquivo40.csv\u0026quot; ## [37] \u0026quot;arquivo41.csv\u0026quot; \u0026quot;arquivo42.csv\u0026quot; \u0026quot;arquivo43.csv\u0026quot; \u0026quot;arquivo44.csv\u0026quot; ## [41] \u0026quot;arquivo45.csv\u0026quot; \u0026quot;arquivo46.csv\u0026quot; \u0026quot;arquivo47.csv\u0026quot; \u0026quot;arquivo48.csv\u0026quot; ## [45] \u0026quot;arquivo49.csv\u0026quot; \u0026quot;arquivo5.csv\u0026quot; \u0026quot;arquivo50.csv\u0026quot; \u0026quot;arquivo51.csv\u0026quot; ## [49] \u0026quot;arquivo52.csv\u0026quot; \u0026quot;arquivo53.csv\u0026quot; \u0026quot;arquivo54.csv\u0026quot; \u0026quot;arquivo55.csv\u0026quot; ## [53] \u0026quot;arquivo56.csv\u0026quot; \u0026quot;arquivo57.csv\u0026quot; \u0026quot;arquivo58.csv\u0026quot; \u0026quot;arquivo59.csv\u0026quot; ## [57] \u0026quot;arquivo6.csv\u0026quot; \u0026quot;arquivo60.csv\u0026quot; \u0026quot;arquivo61.csv\u0026quot; \u0026quot;arquivo62.csv\u0026quot; ## [61] \u0026quot;arquivo63.csv\u0026quot; \u0026quot;arquivo64.csv\u0026quot; \u0026quot;arquivo65.csv\u0026quot; \u0026quot;arquivo66.csv\u0026quot; ## [65] \u0026quot;arquivo67.csv\u0026quot; \u0026quot;arquivo68.csv\u0026quot; \u0026quot;arquivo69.csv\u0026quot; \u0026quot;arquivo7.csv\u0026quot; ## [69] \u0026quot;arquivo70.csv\u0026quot; \u0026quot;arquivo71.csv\u0026quot; \u0026quot;arquivo72.csv\u0026quot; \u0026quot;arquivo73.csv\u0026quot; ## [73] \u0026quot;arquivo74.csv\u0026quot; \u0026quot;arquivo75.csv\u0026quot; \u0026quot;arquivo76.csv\u0026quot; \u0026quot;arquivo77.csv\u0026quot; ## [77] \u0026quot;arquivo78.csv\u0026quot; \u0026quot;arquivo79.csv\u0026quot; \u0026quot;arquivo8.csv\u0026quot; \u0026quot;arquivo80.csv\u0026quot; ## [81] \u0026quot;arquivo81.csv\u0026quot; \u0026quot;arquivo82.csv\u0026quot; \u0026quot;arquivo83.csv\u0026quot; \u0026quot;arquivo84.csv\u0026quot; ## [85] \u0026quot;arquivo85.csv\u0026quot; \u0026quot;arquivo86.csv\u0026quot; \u0026quot;arquivo87.csv\u0026quot; \u0026quot;arquivo88.csv\u0026quot; ## [89] \u0026quot;arquivo89.csv\u0026quot; \u0026quot;arquivo9.csv\u0026quot; \u0026quot;arquivo90.csv\u0026quot; \u0026quot;arquivo91.csv\u0026quot; ## [93] \u0026quot;arquivo92.csv\u0026quot; \u0026quot;arquivo93.csv\u0026quot; \u0026quot;arquivo94.csv\u0026quot; \u0026quot;arquivo95.csv\u0026quot; ## [97] \u0026quot;arquivo96.csv\u0026quot; \u0026quot;arquivo97.csv\u0026quot; \u0026quot;arquivo98.csv\u0026quot; \u0026quot;arquivo99.csv\u0026quot; ## [101] \u0026quot;filecf810bd36a5\u0026quot; \u0026quot;filecf81149221d\u0026quot; \u0026quot;filecf81164e23\u0026quot; \u0026quot;filecf8161f65f7\u0026quot;\r## [105] \u0026quot;filecf8171030fd\u0026quot; \u0026quot;filecf819e43f49\u0026quot; \u0026quot;filecf81ad26a9f\u0026quot; \u0026quot;filecf81bed9f1\u0026quot; ## [109] \u0026quot;filecf81e7a7e68\u0026quot; \u0026quot;filecf81ef03542\u0026quot; \u0026quot;filecf81fa64a3e\u0026quot; \u0026quot;filecf8239d75ab\u0026quot;\r## [113] \u0026quot;filecf8261936\u0026quot; \u0026quot;filecf826d55378\u0026quot; \u0026quot;filecf8291061a0\u0026quot; \u0026quot;filecf82b985019\u0026quot;\r## [117] \u0026quot;filecf82c00737b\u0026quot; \u0026quot;filecf8339f5\u0026quot; \u0026quot;filecf8341e67d6\u0026quot; \u0026quot;filecf8344158ac\u0026quot;\r## [121] \u0026quot;filecf837a47cc7\u0026quot; \u0026quot;filecf837f15510\u0026quot; \u0026quot;filecf8387a3d29\u0026quot; \u0026quot;filecf83a71232b\u0026quot;\r## [125] \u0026quot;filecf83ac3253a\u0026quot; \u0026quot;filecf83af94598\u0026quot; \u0026quot;filecf83f794f64\u0026quot; \u0026quot;filecf8402156c1\u0026quot;\r## [129] \u0026quot;filecf840c15566\u0026quot; \u0026quot;filecf84163761c\u0026quot; \u0026quot;filecf841d3b53\u0026quot; \u0026quot;filecf844d5642\u0026quot; ## [133] \u0026quot;filecf845e73bac\u0026quot; \u0026quot;filecf8462819d6\u0026quot; \u0026quot;filecf84b8b3144\u0026quot; \u0026quot;filecf84ddc73a0\u0026quot;\r## [137] \u0026quot;filecf84fe515d4\u0026quot; \u0026quot;filecf8500a5a10\u0026quot; \u0026quot;filecf8512766ea\u0026quot; \u0026quot;filecf852fe119b\u0026quot;\r## [141] \u0026quot;filecf8550a39d\u0026quot; \u0026quot;filecf85b14fec\u0026quot; \u0026quot;filecf85e053c83\u0026quot; \u0026quot;filecf85e6a12f4\u0026quot;\r## [145] \u0026quot;filecf8639c6053\u0026quot; \u0026quot;filecf863dc5f3b\u0026quot; \u0026quot;filecf8646e477f\u0026quot; \u0026quot;filecf865645c5d\u0026quot;\r## [149] \u0026quot;filecf868634c0d\u0026quot; \u0026quot;filecf869137c8a\u0026quot; \u0026quot;filecf86a7852d4\u0026quot; \u0026quot;filecf86b5b250\u0026quot; ## [153] \u0026quot;filecf86b9e3bb7\u0026quot; \u0026quot;filecf86d216ac\u0026quot; \u0026quot;filecf86e894a16\u0026quot; \u0026quot;filecf86ea916d3\u0026quot;\r## [157] \u0026quot;filecf86f22266\u0026quot; \u0026quot;filecf86f975377\u0026quot; \u0026quot;filecf8757a72be\u0026quot; \u0026quot;filecf876956e82\u0026quot;\r## [161] \u0026quot;filecf876967b1\u0026quot; \u0026quot;filecf8787a1370\u0026quot; \u0026quot;filecf879037c39\u0026quot; \u0026quot;filecf87964711\u0026quot; ## [165] \u0026quot;filecf87afe7046\u0026quot; \u0026quot;filecf88456ae0\u0026quot; \u0026quot;filecf898344ab\u0026quot;\r # Agora vamos ler todos de volta para uma tibble só.\rarqs \u0026lt;- dir(pasta, pattern = \u0026quot;.csv\u0026quot;, full.names = T)\r # Juntando linhas\rdf \u0026lt;- map_dfr(arqs, read_csv)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # Juntando colunas\rdf \u0026lt;- map_dfc(arqs, read_csv)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r # Usando reduce\r# linhas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_rows)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # colunas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_cols)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r# Estou usando funções do pacote broom, mas você não era obrigado a apresentar\r# os resultados bonitinho. O objetivo era treinar esse tipo de workflow.\rmodelos_saida \u0026lt;- tibble(\respecificacao = modelos,\rajuste = map(especificacao, lm, data = mtcars),\rcoefs = map(ajuste, broom::tidy),\rstats = map(ajuste, broom::glance),\raums = map(ajuste, broom::augment)\r)\rmodelos_saida %\u0026gt;% select(especificacao, coefs) %\u0026gt;% unnest(coefs) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)  ## # A tibble: 10 x 6\r## especificacao term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt wt -5.34 0.559 -9.56 1.29e-10\r## 2 mpg ~ wt + cyl wt -3.19 0.757 -4.22 2.22e- 4\r## 3 mpg ~ wt + cyl cyl -1.51 0.415 -3.64 1.06e- 3\r## 4 mpg ~ wt + cyl + drat wt -3.19 0.829 -3.85 6.24e- 4\r## 5 mpg ~ wt + cyl + drat cyl -1.51 0.446 -3.38 2.14e- 3\r## 6 mpg ~ wt + cyl + drat drat -0.0162 1.32 -0.0122 9.90e- 1\r## 7 mpg ~ wt + cyl + drat + am wt -3.13 0.932 -3.36 2.32e- 3\r## 8 mpg ~ wt + cyl + drat + am cyl -1.53 0.465 -3.28 2.88e- 3\r## 9 mpg ~ wt + cyl + drat + am drat -0.130 1.53 -0.0851 9.33e- 1\r## 10 mpg ~ wt + cyl + drat + am am 0.237 1.51 0.157 8.76e- 1\r modelos_saida %\u0026gt;% select(especificacao, stats) %\u0026gt;% unnest(stats)\r ## # A tibble: 4 x 13\r## especificacao r.squared adj.r.squared sigma statistic p.value df logLik\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt 0.753 0.745 3.05 91.4 1.29e-10 1 -80.0\r## 2 mpg ~ wt + cyl 0.830 0.819 2.57 70.9 6.81e-12 2 -74.0\r## 3 mpg ~ wt + cyl ~ 0.830 0.812 2.61 45.6 6.57e-11 3 -74.0\r## 4 mpg ~ wt + cyl ~ 0.830 0.805 2.66 33.0 4.84e-10 4 -74.0\r## # ... with 5 more variables: AIC \u0026lt;dbl\u0026gt;, BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;,\r## # df.residual \u0026lt;int\u0026gt;, nobs \u0026lt;int\u0026gt;\r modelos_saida %\u0026gt;% select(especificacao, aums) %\u0026gt;% filter(especificacao == \u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;) %\u0026gt;% unnest(aums)\r ## # A tibble: 32 x 13\r## especificacao .rownames mpg wt cyl drat am .fitted .resid .hat\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt + cyl~ Mazda RX4 21 2.62 6 3.9 1 22.3 -1.35 0.0899\r## 2 mpg ~ wt + cyl~ Mazda RX~ 21 2.88 6 3.9 1 21.6 -0.550 0.0924\r## 3 mpg ~ wt + cyl~ Datsun 7~ 22.8 2.32 4 3.85 1 26.3 -3.55 0.137 ## 4 mpg ~ wt + cyl~ Hornet 4~ 21.4 3.22 6 3.08 0 20.4 1.05 0.113 ## 5 mpg ~ wt + cyl~ Hornet S~ 18.7 3.44 8 3.15 0 16.6 2.11 0.122 ## 6 mpg ~ wt + cyl~ Valiant 18.1 3.46 6 2.76 0 19.6 -1.53 0.207 ## 7 mpg ~ wt + cyl~ Duster 3~ 14.3 3.57 8 3.21 0 16.2 -1.87 0.103 ## 8 mpg ~ wt + cyl~ Merc 240D 24.4 3.19 4 3.69 0 23.4 0.996 0.189 ## 9 mpg ~ wt + cyl~ Merc 230 22.8 3.15 4 3.92 0 23.5 -0.700 0.207 ## 10 mpg ~ wt + cyl~ Merc 280 19.2 3.44 6 3.92 0 19.5 -0.340 0.149 ## # ... with 22 more rows, and 3 more variables: .sigma \u0026lt;dbl\u0026gt;, .cooksd \u0026lt;dbl\u0026gt;,\r## # .std.resid \u0026lt;dbl\u0026gt;\r ","date":1621900800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621900800,"objectID":"c1c74f268683837301969e7167daf1ed","permalink":"https://laddem.github.io/courses/tidyverse/solucoes/","publishdate":"2021-05-25T00:00:00Z","relpermalink":"/courses/tidyverse/solucoes/","section":"courses","summary":"Soluções dos exercícios","tags":null,"title":"Soluções","type":"book"},{"authors":["LADDEM"],"categories":null,"content":"\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://laddem.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot;\rif porridge == \u0026quot;blueberry\u0026quot;:\rprint(\u0026quot;Eating...\u0026quot;)\r  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}}\r{{% fragment %}} **Two** {{% /fragment %}}\r{{% fragment %}} Three {{% /fragment %}}\r Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}}\r- Only the speaker can read these notes\r- Press `S` key to view\r{{% /speaker_note %}}\r Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}}\r{{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}\r  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1,\r.reveal section h2,\r.reveal section h3 {\rcolor: navy;\r}\r  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://laddem.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://laddem.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://laddem.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://laddem.github.io/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]
=======
<<<<<<< HEAD
[{"authors":null,"categories":null,"content":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://laddem.github.io/author/laddem/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/laddem/","section":"authors","summary":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.","tags":null,"title":"LADDEM","type":"authors"},{"authors":null,"categories":null,"content":"\r\r Table of Contents\r O que você vai aprender O curso Programação Instrutores Links úteis  \r\rO que você vai aprender  A filosofia de design por trás de um dos pacotes mais populares no R Importação, Manipulação e Visualização de dados na prática tidyr, dplyr, ggplot2 e vários outros pacotes para simplificar sua rotina de análise de dados  O curso Uma semana, com aulas à noite, no formato workshop, com muitos exercícios para praticar e pegar o jeito.\nProgramação \rreadr, tibble e tidyr\rUm modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\n\r\rstringr, forcats e dplyr\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\n\r\rggplot2\rO pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.\n\r\rpurrr\rO autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.\n\r\rSoluções\rSoluções dos exercícios\n\r\rInstrutores Vinícius de Souza Maia\nNatália Martins Arruda\nLinks úteis Ciência de dados em R\nR for Data Science\n","date":1621728000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1621728000,"objectID":"02eadce3bea228c4a3968729e322add5","permalink":"https://laddem.github.io/courses/tidyverse/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/","section":"courses","summary":"Aprenda a utilizar o tidyverse nas suas análises de dados.","tags":null,"title":"📊 Aprenda a utilizar o tidyverse","type":"book"},{"authors":null,"categories":null,"content":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\nEla acaba sendo um ponto de partida interessante porque contextualiza a maioria dos pacotes que vamos utilizar. O readr é uma maneira de facilitar e tornar mais rápida a importação de dados em formatos comuns, como o texto delimitado por separadores e o formato colunado com larguras-fixas utilizado pelo IBGE.\nA tibble é uma proposta de modernização para o data.frame, aproveitando a estrutura flexível e poderosa, mas mudando certas convenções, como a conversão de strings para fatores, permitindo a criação de colunas de listas, utilização de nomes mais complexos para colunas, etc.\nO tidyr é uma forma de reformatar (reshape) bancos de dados que vêm em formatos que dificultam seu processamento, permitindo que o analista facilmente reconfigure a informação para o formato mais adequado. Ele é o primeiro pacote que veremos sobre a parte de \u0026ldquo;cozinha\u0026rdquo; dos dados, no qual é preciso processar o dado bruto para torná-lo passível de análise.\nO mesmo pode ser dito para os outros pacotes que veremos nos próximos dias. Cada um deles foi pensado para resolver um problema ou facilitar uma rotina de trabalho relacionada com um dos passos descritos acima.\nProgramação literária Vários dos conceitos que guiam o design do tidyverse são orientados por uma certa filosofia. Esta filosofia dita que a principal preocupação por trás de um programa não é que ele funcione. Eventualmente e com um pouco de persistência, é quase sempre possível chegar a uma solução técnica adequada. A principal questão é que o programa é uma ferramenta de comunicação com outras pessoas que o lerão, seja seus colegas, colaboradores, alunos ou você mesmo, daqui a 2 anos, quando lembrar que você já escreveu um programa para aquela tarefa. Trago aqui alguns trechos de Literate Programming, de Donald Knuth (1984), traduzidos livremente por este que vos fala:\n Creio que chegou a hora de melhorar significativamente a documentação dos programas, e que podemos atingir este objetivo tratando programas como obras literárias. Por isso o título: \u0026ldquo;Programação Literária\u0026rdquo;. Abandonemos os velhos hábitos de construir programas: ao invés de imaginar que nossa tarefa principal é instruir um computador sobre o que deve ser feito, concentremo-nos em explicar aos seres humanos o que queremos que o computador faça. O praticante da programação literária pode ser visto como um ensaísta, cuja principal preocupação é com a clareza da exposição e a excelência no estilo. Tal autor, com um dicionário na mão, escolhe os nomes das variáveis com cuidado e explica claramente seu significado. Ele ou ela esmera por um programa que é compreensível porque seus conceitos foram introduzidos na melhor ordem possível para o entendimento humano, utilizando uma mistura de métodos formais e informais que se complementam.\n Assim, várias das escolhas feitas na construção de tidyverse procuram reforçar essa característica de interpretabilidade dos programas, como a ordem lógica das operações com o pipe (%\u0026gt;%), funções com nomes mais longos e semânticos, a utilização de uma função específica para cada tarefa, ao invés da adaptação de funções genéricas para uma grande variedade de tarefas. O propósito de um código escrito como tidyverse é que, no limite, a própria síntaxe do código funcione como parte da documentação do programa.\nO mistério do pipe: %\u0026gt;% Usuários de longa data do R já podem ter encontrado no mato esse animal estranho e podem ter ficado confusos com seu significado. O pipe é de origem humilde e nasceu nos sistemas Unix há muitas décadas atrás. Seu objetivo é muito simples: e se você tiver uma sequência de computações em que cada uma recebe o resultado daquela feita anteriormente? Claro que você poderia fazer:\nx \u0026lt;- 1:10\ry \u0026lt;- diff(x)\rmean(y)\r ## [1] 1\r Mas não seria interessante pular os objetos intermediários e ir direto ao ponto? O pipe vem do pacote magrittr, mas ele vêm carregado em quase todos os pacotes do tidyverse. Vamos carregar logo o tibble.\n# Para ter acesso ao pipe, basta carregar um pacote do tidyverse, como tibble, dplyr, tidyr, etc.\r# Vamos carregar o tibble agora\rlibrary(tibble)\rx %\u0026gt;% diff() %\u0026gt;% mean()\r ## [1] 1\r Vejamos um exemplo mais real, quantos artistas existem no dataset billboard? Podemos usar unique e length para descobrir.\nx \u0026lt;- unique(tidyr::billboard$artist)\rlength(x)\r ## [1] 228\r Mas com %\u0026gt;% fica bem melhor:\ntidyr::billboard %\u0026gt;% .$artist %\u0026gt;% unique() %\u0026gt;% length()\r ## [1] 228\r Ok, mas como ele funciona? É simples, o pipe carrega o objeto a sua esquerda num ponto . invisível que é automaticamente passado como o primeiro argumento da função à direita.\nx \u0026lt;- 1:10\rmean(x)\r ## [1] 5.5\r x %\u0026gt;% mean()\r ## [1] 5.5\r OK, mas e se meu argumento não for o primeiro, ainda posso usar pipe? Pode! É só usar explicitamente um ponto no lugar onde você quer aproveitar o efeito:\niris %\u0026gt;% boxplot(Sepal.Length ~ Species, data = .)\r O ponto . depois de data indica indica que ali deve ser colocado o iris. O pipe é uma peça chave de muitas funções do tidyverse, não porque ele seja obrigatório, mas sim porque ele permite expressar sequências de operações numa ordem mais lógica, do tipo: \u0026ldquo;Primeiro faça a, então b, então c, \u0026hellip; \u0026ldquo;, ao contrário da forma como isto é geralmente feito usando parênteses para precedência.\n# Compare\rmean(diff(1:10))\r ## [1] 1\r 1:10 %\u0026gt;% diff %\u0026gt;% mean\r ## [1] 1\r E assim fica desmistificado o mistério do pipe! Um último pulo do gato: pelo amor de deus ninguém digita Shift + %, \u0026gt;, Shift + %, basta usar o atalho: Ctrl + Shift + M que ele põe um pipe separado por espaços %\u0026gt;%.\nreadr Usuários do R provavelmente vão estar familiarizados com os nossos leitores de arquivos mais comuns: read.table e read.csv. Talvez muitos de vocês já até memorizaram alguns dos argumentos mais comuns. Não é o caso aqui de revisitar esta função, mas o readr tem muitos paralelos com elas, porque é pensado como uma nova versão da mesma coisa.\n# Comecemos carregando o readr\rlibrary(readr)\r Debaixo do capô O readr, como as funções de leitura do base é uma coleção de parsers, que transformam texto em objetos R com o tipo desejado.\nparse_number(c(\u0026quot;1\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;38\u0026quot;))\r ## [1] 1 20 38\r parse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;ma\u0026lt;e7\u0026gt;\u0026lt;e3\u0026gt;\u0026quot; \u0026quot;p\u0026lt;ea\u0026gt;ra\u0026quot;\r # Note os acentos e caracteres especiais\rparse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;), locale = locale(encoding = \u0026quot;Windows-1252\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;maçã\u0026quot; \u0026quot;pêra\u0026quot;\r parse_logical(c(\u0026quot;true\u0026quot;, \u0026quot;false\u0026quot;, \u0026quot;true\u0026quot;))\r ## [1] TRUE FALSE TRUE\r Em geral, a gente não precisa descer tanto o nível, a gente vai trabalhar mesmo é com os leitores de dados \u0026ldquo;retangulares\u0026rdquo;. Como os do base, eles são read_csv, read_table, etc. Vamos trabalhar com bancos de dados que já vêm no pacote, para facilitar o processo.\n# Lista os datasets que vem no pacote\rreadr_example()\r ## [1] \u0026quot;challenge.csv\u0026quot; \u0026quot;epa78.txt\u0026quot; \u0026quot;example.log\u0026quot; ## [4] \u0026quot;fwf-sample.txt\u0026quot; \u0026quot;massey-rating.txt\u0026quot; \u0026quot;mtcars.csv\u0026quot; ## [7] \u0026quot;mtcars.csv.bz2\u0026quot; \u0026quot;mtcars.csv.zip\u0026quot;\r Uma coisa que gosto de fazer é olhar como o arquivo está organizado antes de tentar abrí-lo. Muitos de vocês podem fazer isso com readLines. Ela ganhou sua versão no pacote com read_lines.\n# Vamos tentar abrir massey-rating.txt\rread_lines(readr_example(\u0026quot;massey-rating.txt\u0026quot;), n_max = 10)\r ## [1] \u0026quot;UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf\u0026quot; ## [2] \u0026quot; 1 1 1 1 1 1 1 1 1 1 1 Ohio St B10 \u0026quot;\r## [3] \u0026quot; 2 2 2 2 2 2 2 2 4 2 2 Oregon P12 \u0026quot;\r## [4] \u0026quot; 3 4 3 4 3 4 3 4 2 3 3 Alabama SEC \u0026quot;\r## [5] \u0026quot; 4 3 4 3 4 3 5 3 3 4 4 TCU B12 \u0026quot;\r## [6] \u0026quot; 6 6 6 5 5 7 6 5 6 11 5 Michigan St B10 \u0026quot;\r## [7] \u0026quot; 7 7 7 6 7 6 11 8 7 8 6 Georgia SEC \u0026quot;\r## [8] \u0026quot; 5 5 5 7 6 8 4 6 5 5 7 Florida St ACC \u0026quot;\r## [9] \u0026quot; 8 8 9 9 10 5 7 7 10 7 8 Baylor B12 \u0026quot;\r## [10] \u0026quot; 9 11 8 13 11 11 12 9 14 9 9 Georgia Tech ACC \u0026quot;\r # Identificando o separador, escolho a função adequada\rread_table(readr_example(\u0026quot;massey-rating.txt\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## UCC = col_double(),\r## PAY = col_double(),\r## LAZ = col_double(),\r## KPK = col_double(),\r## RT = col_double(),\r## COF = col_double(),\r## BIH = col_double(),\r## DII = col_double(),\r## ENG = col_double(),\r## ACU = col_double(),\r## Rank = col_double(),\r## Team = col_character(),\r## Conf = col_character()\r## )\r ## # A tibble: 10 x 13\r## UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf ## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 1 1 1 1 1 1 1 1 1 1 Ohio~ B10 ## 2 2 2 2 2 2 2 2 2 4 2 2 Oreg~ P12 ## 3 3 4 3 4 3 4 3 4 2 3 3 Alab~ SEC ## 4 4 3 4 3 4 3 5 3 3 4 4 TCU B12 ## 5 6 6 6 5 5 7 6 5 6 11 5 Mich~ B10 ## 6 7 7 7 6 7 6 11 8 7 8 6 Geor~ SEC ## 7 5 5 5 7 6 8 4 6 5 5 7 Flor~ ACC ## 8 8 8 9 9 10 5 7 7 10 7 8 Bayl~ B12 ## 9 9 11 8 13 11 11 12 9 14 9 9 Geor~ ACC ## 10 13 10 13 11 8 9 10 11 9 10 10 Miss~ SEC\r Como identifiquei que as colunas estavam separadas por espaços, utilizei read_table cujo delimitador é o espaço \u0026quot; \u0026quot;.\nA segunda feature mais interessante do readr, é uma interface para selecionar os tipos de colunas que serão importadas. Vejamos o seguinte exemplo.\n# Vamos abrir mtcars.csv\rread_lines(readr_example(\u0026quot;mtcars.csv\u0026quot;), n_max = 10)\r ## [1] \u0026quot;\\\u0026quot;mpg\\\u0026quot;,\\\u0026quot;cyl\\\u0026quot;,\\\u0026quot;disp\\\u0026quot;,\\\u0026quot;hp\\\u0026quot;,\\\u0026quot;drat\\\u0026quot;,\\\u0026quot;wt\\\u0026quot;,\\\u0026quot;qsec\\\u0026quot;,\\\u0026quot;vs\\\u0026quot;,\\\u0026quot;am\\\u0026quot;,\\\u0026quot;gear\\\u0026quot;,\\\u0026quot;carb\\\u0026quot;\u0026quot;\r## [2] \u0026quot;21,6,160,110,3.9,2.62,16.46,0,1,4,4\u0026quot; ## [3] \u0026quot;21,6,160,110,3.9,2.875,17.02,0,1,4,4\u0026quot; ## [4] \u0026quot;22.8,4,108,93,3.85,2.32,18.61,1,1,4,1\u0026quot; ## [5] \u0026quot;21.4,6,258,110,3.08,3.215,19.44,1,0,3,1\u0026quot; ## [6] \u0026quot;18.7,8,360,175,3.15,3.44,17.02,0,0,3,2\u0026quot; ## [7] \u0026quot;18.1,6,225,105,2.76,3.46,20.22,1,0,3,1\u0026quot; ## [8] \u0026quot;14.3,8,360,245,3.21,3.57,15.84,0,0,3,4\u0026quot; ## [9] \u0026quot;24.4,4,146.7,62,3.69,3.19,20,1,0,4,2\u0026quot; ## [10] \u0026quot;22.8,4,140.8,95,3.92,3.15,22.9,1,0,4,2\u0026quot;\r # Identificamos o separador de colunas, selecionamos a função adequada\rread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r O console nos mostra que a leitura do banco foi completada, mas também mostra Column Specification. Isto indica qual o tipo de dado que foi identificado automaticamente numa análise feita pela função guess_parser. Em diversos casos, nós podemos querer identificar manualmente as colunas. Vejamos um exemplo:\n# Vamos identificar as colunas com spec\rspec_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r # Copia e cola, modifica as colunas que queremos alterar\rspec_cols \u0026lt;- cols(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\rdisp = col_double(),\rhp = col_double(),\rdrat = col_double(),\rwt = col_double(),\rqsec = col_double(),\rvs = col_double(),\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols)\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r # Para importar apenas colunas selecionadas, utilize 'cols_only()'\rspec_cols2 \u0026lt;- cols_only(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf2 \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols2)\rdf2\r ## # A tibble: 32 x 5\r## mpg cyl am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 1 4 4\r## 2 21 6 1 4 4\r## 3 22.8 4 1 4 1\r## 4 21.4 6 0 3 1\r## 5 18.7 8 0 3 2\r## 6 18.1 6 0 3 1\r## 7 14.3 8 0 3 4\r## 8 24.4 4 0 4 2\r## 9 22.8 4 0 4 2\r## 10 19.2 6 0 4 4\r## # ... with 22 more rows\r # Para indicar os tipos de colunas de um jeito mais sucinto, utilize uma string:\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = \u0026quot;dfddddddfdd\u0026quot;)\r# Só cuidado pra não perder a conta dos ds!\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nmeu_locale \u0026lt;- locale(encoding = \u0026quot;UTF-8\u0026quot;, decimal_mark = \u0026quot;,\u0026quot;, grouping_mark = \u0026quot;.\u0026quot;)\r Aí é só passar isso pra uma das funções do pacote sob o argumento locale\nread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), locale = meu_locale)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_number(),\r## cyl = col_double(),\r## disp = col_number(),\r## hp = col_double(),\r## drat = col_number(),\r## wt = col_number(),\r## qsec = col_number(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 39 262 1646 0 1 4 4\r## 2 21 6 160 110 39 2875 1702 0 1 4 4\r## 3 228 4 108 93 385 232 1861 1 1 4 1\r## 4 214 6 258 110 308 3215 1944 1 0 3 1\r## 5 187 8 360 175 315 344 1702 0 0 3 2\r## 6 181 6 225 105 276 346 2022 1 0 3 1\r## 7 143 8 360 245 321 357 1584 0 0 3 4\r## 8 244 4 1467 62 369 319 20 1 0 4 2\r## 9 228 4 1408 95 392 315 229 1 0 4 2\r## 10 192 6 1676 123 392 344 183 1 0 4 4\r## # ... with 22 more rows\r Existe ainda a possibilidade de ler dados colunados com largura-fixa. readr implementa quatro funções diferentes para ajudar na construção do dicionário:\n# Nossos dados\rx \u0026lt;- readr_example(\u0026quot;fwf-sample.txt\u0026quot;)\rread_lines(x, n_max = 10)\r ## [1] \u0026quot;John Smith WA 418-Y11-4111\u0026quot;\r## [2] \u0026quot;Mary Hartford CA 319-Z19-4341\u0026quot;\r## [3] \u0026quot;Evan Nolan IL 219-532-c301\u0026quot;\r # separados por espaço\rdic1 \u0026lt;- fwf_empty(x)\rdic1\r ## $begin\r## [1] 0 5 20 30\r## ## $end\r## [1] 4 13 22 NA\r## ## $skip\r## [1] 0\r## ## $col_names\r## [1] \u0026quot;X1\u0026quot; \u0026quot;X2\u0026quot; \u0026quot;X3\u0026quot; \u0026quot;X4\u0026quot;\r df \u0026lt;- read_fwf(file = x, col_positions = dic1)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character(),\r## X4 = col_character()\r## )\r df\r ## # A tibble: 3 x 4\r## X1 X2 X3 X4 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando a largura da coluna\rlarguras \u0026lt;- c(20, 10, 12)\rdic2 \u0026lt;- fwf_widths(larguras)\rdic2\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 30 X2 ## 3 30 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic2)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando onde cada coluna começa e termina\rcomeca \u0026lt;- c(1, 21, 30)\rtermina \u0026lt;- c(20, 29, 42)\rdic3 \u0026lt;- fwf_positions(comeca, termina)\rdic3\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 29 X2 ## 3 29 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic3)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando pares nome-valor\rdic4 \u0026lt;- fwf_cols(\rnome = c(1, 20),\ruf = c(21, 29),\rnumero = c(30, 42))\rdic4\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 nome ## 2 20 29 uf ## 3 29 42 numero\r df \u0026lt;- read_fwf(file = x, col_positions = dic4)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## nome = col_character(),\r## uf = col_character(),\r## numero = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## nome uf numero ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r Especificar dicionários para arquivos colunados é um pé-no-saco, por sorte, existem pacotes que já fizeram parte desse trabalho por nós. O readr não melhora muita o serviço manual de construção de dicionários, o que ele oferece é um ganho de performance tremendo. read_fwf é centenas de vezes mais rápido que o base read.fwf.\nEm termos do que o pacote faz, é basicamente isso. A única coisa que falta mencionar é que ele importa os dados como tibbles ao invés do data.frame padrão, mas isso já é um ótimo gancho pra nossa próxima parte.\ntibbles Tibbles são basicamente data.frames com um método mais bonitinho de print. Elas automaticamente se ajustam a largura da sua tela, omitindo as colunas que estouram, e por padrão imprimem só as 10 primeiras observações. Outras características que pessoalmente gosto, é que elas informam o tipo de variável junto com o nome, arrendondam digitos significativos, destacam números grandes, negativos, NAs e etc.\ndf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = cols()) # omitir a especificação\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Do ponto de vista prático, elas funcionam exatamente igual a data.frames, tudo que você pode fazer com um data.frame, você faz com tibbles. O que elas trazem de novidade é:\n Elas nunca mudam o tipo de dado inputado.  df1 \u0026lt;- data.frame(x = list(1:5, 1:10, 1:20))\rdf1\r ## x.1.5 x.1.10 x.1.20\r## 1 1 1 1\r## 2 2 2 2\r## 3 3 3 3\r## 4 4 4 4\r## 5 5 5 5\r## 6 1 6 6\r## 7 2 7 7\r## 8 3 8 8\r## 9 4 9 9\r## 10 5 10 10\r## 11 1 1 11\r## 12 2 2 12\r## 13 3 3 13\r## 14 4 4 14\r## 15 5 5 15\r## 16 1 6 16\r## 17 2 7 17\r## 18 3 8 18\r## 19 4 9 19\r## 20 5 10 20\r df2 \u0026lt;- tibble(x = list(1:5, 1:10, 1:20))\rdf2\r ## # A tibble: 3 x 1\r## x ## \u0026lt;list\u0026gt; ## 1 \u0026lt;int [5]\u0026gt; ## 2 \u0026lt;int [10]\u0026gt;\r## 3 \u0026lt;int [20]\u0026gt;\r  Elas nunca ajustam os nomes das variáveis  names(data.frame(`nome hipster` = 1))\r ## [1] \u0026quot;nome.hipster\u0026quot;\r names(tibble(`nome hipster` = 1))\r ## [1] \u0026quot;nome hipster\u0026quot;\r  Ela avalia cada argumento de forma \u0026ldquo;preguiçosa\u0026rdquo; e sequencial  # erro\rdata.frame(x = 1:5, y = x ^ 2)\r ## Error in x^2: argumento não-numérico para operador binário\r # funciona\rtibble(x = 1:5, y = x ^ 2)\r ## # A tibble: 5 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 4\r## 3 3 9\r## 4 4 16\r## 5 5 25\r  Ela nunca utiliza row.names  head(data.frame(state.x77))\r ## Population Income Illiteracy Life.Exp Murder HS.Grad Frost Area\r## Alabama 3615 3624 2.1 69.05 15.1 41.3 20 50708\r## Alaska 365 6315 1.5 69.31 11.3 66.7 152 566432\r## Arizona 2212 4530 1.8 70.55 7.8 58.1 15 113417\r## Arkansas 2110 3378 1.9 70.66 10.1 39.9 65 51945\r## California 21198 5114 1.1 71.71 10.3 62.6 20 156361\r## Colorado 2541 4884 0.7 72.06 6.8 63.9 166 103766\r as_tibble(state.x77)\r ## # A tibble: 50 x 8\r## Population Income Illiteracy `Life Exp` Murder `HS Grad` Frost Area\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 3615 3624 2.1 69.0 15.1 41.3 20 50708\r## 2 365 6315 1.5 69.3 11.3 66.7 152 566432\r## 3 2212 4530 1.8 70.6 7.8 58.1 15 113417\r## 4 2110 3378 1.9 70.7 10.1 39.9 65 51945\r## 5 21198 5114 1.1 71.7 10.3 62.6 20 156361\r## 6 2541 4884 0.7 72.1 6.8 63.9 166 103766\r## 7 3100 5348 1.1 72.5 3.1 56 139 4862\r## 8 579 4809 0.9 70.1 6.2 54.6 103 1982\r## 9 8277 4815 1.3 70.7 10.7 52.6 11 54090\r## 10 4931 4091 2 68.5 13.9 40.6 60 58073\r## # ... with 40 more rows\r  Ela muda a \u0026ldquo;regra da reciclagem\u0026rdquo;: apenas são aceitos vetores unitários ou vetores de tamanho igual aos demais  data.frame(x = 1:10, y = 1:5)\r ## x y\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r # erro\rtibble(x = 1:10, y = 1:5)\r ## Error: Tibble columns must have compatible sizes.\r## * Size 10: Existing data.\r## * Size 5: Column `y`.\r## i Only values of size one are recycled.\r tibble(x = 1:10, y = 1)\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 1\r## 3 3 1\r## 4 4 1\r## 5 5 1\r## 6 6 1\r## 7 7 1\r## 8 8 1\r## 9 9 1\r## 10 10 1\r tibble(x = 1:10, y = c(1:5, 1:5))\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r  Tibbles são estritas com relação as operações de subsetting com [  df1 \u0026lt;- data.frame(x = 1:3, y = 3:1)\rclass(df1[,1:2])\r ## [1] \u0026quot;data.frame\u0026quot;\r class(df1[,1])\r ## [1] \u0026quot;integer\u0026quot;\r df2 \u0026lt;- tibble(x = 1:3, y = 3:1)\rclass(df2[, 1:2])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r class(df2[, 1])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r # Se quiser extrair só uma coluna, utilize '[[' ou '$'\rclass(df2[[1]])\r ## [1] \u0026quot;integer\u0026quot;\r class(df2$x)\r ## [1] \u0026quot;integer\u0026quot;\r Elas também não aceitam \u0026lsquo;partial matching\u0026rsquo; de nomes de variáveis.\ndf \u0026lt;- data.frame(nome_de_cavalo = 1)\rdf$nome\r ## [1] 1\r df2 \u0026lt;- tibble(nome_de_cavalo = 1)\rdf2$nome\r ## Warning: Unknown or uninitialised column: `nome`.\r ## NULL\r tidyr Ok, nossos dados estão no R, mas, muitas vezes, não estão no formato adequado. De maneira geral, analistas de dados vão dar preferência a um formato parecido com este:\nIsto tem uma razão de ser que deve tornar-se óbvia quando tentarmos realizar as operações de transformação de variáveis, visualização, modelos, etc. Porém, muitas vezes outras considerações são feitas na hora registrar os dados, armazená-los, apresentá-los ao público, por isso, frequentemente nossos dados não estão no formato tidy e precisam ser reformatados. Essa é uma das principais tarefas do tidyr e é nela que vamos nos concentrar.\nAtente que reformatação, como muitos outros aspectos da análise de dados, não é receita de bolo. Muitas vezes o formato desejado não é óbvio, muito menos os passos necessários para chegar lá. Porém, vou apresentar as ferramentas e alguns exemplos simples que cobrem muitos dos nossos casos de uso.\nlibrary(tidyr)\rwho\r ## # A tibble: 7,240 x 60\r## country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghani~ AF AFG 1980 NA NA NA NA\r## 2 Afghani~ AF AFG 1981 NA NA NA NA\r## 3 Afghani~ AF AFG 1982 NA NA NA NA\r## 4 Afghani~ AF AFG 1983 NA NA NA NA\r## 5 Afghani~ AF AFG 1984 NA NA NA NA\r## 6 Afghani~ AF AFG 1985 NA NA NA NA\r## 7 Afghani~ AF AFG 1986 NA NA NA NA\r## 8 Afghani~ AF AFG 1987 NA NA NA NA\r## 9 Afghani~ AF AFG 1988 NA NA NA NA\r## 10 Afghani~ AF AFG 1989 NA NA NA NA\r## # ... with 7,230 more rows, and 52 more variables: new_sp_m4554 \u0026lt;int\u0026gt;,\r## # new_sp_m5564 \u0026lt;int\u0026gt;, new_sp_m65 \u0026lt;int\u0026gt;, new_sp_f014 \u0026lt;int\u0026gt;,\r## # new_sp_f1524 \u0026lt;int\u0026gt;, new_sp_f2534 \u0026lt;int\u0026gt;, new_sp_f3544 \u0026lt;int\u0026gt;,\r## # new_sp_f4554 \u0026lt;int\u0026gt;, new_sp_f5564 \u0026lt;int\u0026gt;, new_sp_f65 \u0026lt;int\u0026gt;,\r## # new_sn_m014 \u0026lt;int\u0026gt;, new_sn_m1524 \u0026lt;int\u0026gt;, new_sn_m2534 \u0026lt;int\u0026gt;,\r## # new_sn_m3544 \u0026lt;int\u0026gt;, new_sn_m4554 \u0026lt;int\u0026gt;, new_sn_m5564 \u0026lt;int\u0026gt;,\r## # new_sn_m65 \u0026lt;int\u0026gt;, new_sn_f014 \u0026lt;int\u0026gt;, new_sn_f1524 \u0026lt;int\u0026gt;,\r## # new_sn_f2534 \u0026lt;int\u0026gt;, new_sn_f3544 \u0026lt;int\u0026gt;, new_sn_f4554 \u0026lt;int\u0026gt;,\r## # new_sn_f5564 \u0026lt;int\u0026gt;, new_sn_f65 \u0026lt;int\u0026gt;, new_ep_m014 \u0026lt;int\u0026gt;,\r## # new_ep_m1524 \u0026lt;int\u0026gt;, new_ep_m2534 \u0026lt;int\u0026gt;, new_ep_m3544 \u0026lt;int\u0026gt;,\r## # new_ep_m4554 \u0026lt;int\u0026gt;, new_ep_m5564 \u0026lt;int\u0026gt;, new_ep_m65 \u0026lt;int\u0026gt;,\r## # new_ep_f014 \u0026lt;int\u0026gt;, new_ep_f1524 \u0026lt;int\u0026gt;, new_ep_f2534 \u0026lt;int\u0026gt;,\r## # new_ep_f3544 \u0026lt;int\u0026gt;, new_ep_f4554 \u0026lt;int\u0026gt;, new_ep_f5564 \u0026lt;int\u0026gt;,\r## # new_ep_f65 \u0026lt;int\u0026gt;, newrel_m014 \u0026lt;int\u0026gt;, newrel_m1524 \u0026lt;int\u0026gt;,\r## # newrel_m2534 \u0026lt;int\u0026gt;, newrel_m3544 \u0026lt;int\u0026gt;, newrel_m4554 \u0026lt;int\u0026gt;,\r## # newrel_m5564 \u0026lt;int\u0026gt;, newrel_m65 \u0026lt;int\u0026gt;, newrel_f014 \u0026lt;int\u0026gt;,\r## # newrel_f1524 \u0026lt;int\u0026gt;, newrel_f2534 \u0026lt;int\u0026gt;, newrel_f3544 \u0026lt;int\u0026gt;,\r## # newrel_f4554 \u0026lt;int\u0026gt;, newrel_f5564 \u0026lt;int\u0026gt;, newrel_f65 \u0026lt;int\u0026gt;\r Esse é um banco de dados difícil de analisar, ele tem 60 colunas, indicando o número de casos de tuberculose em diversos estágios da doença, por país e ano. O problema é que ao invés de termos algo como:\ntribble(\r~pais, ~ano, ~tipo, ~idade, ~casos,\r\u0026quot;brasil\u0026quot;, 1980, \u0026quot;extrapulmonar\u0026quot;, \u0026quot;15-24\u0026quot;, 10,\r\u0026quot;brasil\u0026quot;, 1990, \u0026quot;relapso\u0026quot;, \u0026quot;15-24\u0026quot;, 10\r)\r ## # A tibble: 2 x 5\r## pais ano tipo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 brasil 1980 extrapulmonar 15-24 10\r## 2 brasil 1990 relapso 15-24 10\r As informações de tipo de tuberculose e idade dos pacientes estão espalhadas pelas colunas. Pra encurtar a história, precisamos \u0026ldquo;tombar\u0026rdquo; esse banco para que essas colunas se tornem um novo conjunto de variáveis. Vamos passo a passo.\n# Primeiro, vamos excluir as colunas iso2 e iso3, porque elas são a mesma informação redundante\rwho$iso2 \u0026lt;- NULL\rwho$iso3 \u0026lt;- NULL\rwho1 \u0026lt;- pivot_longer(who,\rcols = c(new_sp_m014:newrel_f65),\rnames_to = \u0026quot;tipo_tb\u0026quot;,\rvalues_to = \u0026quot;casos\u0026quot;,\rvalues_drop_na = TRUE)\rwho1\r ## # A tibble: 76,046 x 4\r## country year tipo_tb casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 new_sp_m014 0\r## 2 Afghanistan 1997 new_sp_m1524 10\r## 3 Afghanistan 1997 new_sp_m2534 6\r## 4 Afghanistan 1997 new_sp_m3544 3\r## 5 Afghanistan 1997 new_sp_m4554 5\r## 6 Afghanistan 1997 new_sp_m5564 2\r## 7 Afghanistan 1997 new_sp_m65 0\r## 8 Afghanistan 1997 new_sp_f014 5\r## 9 Afghanistan 1997 new_sp_f1524 38\r## 10 Afghanistan 1997 new_sp_f2534 36\r## # ... with 76,036 more rows\r Nosso primeiro passo é transformar todas as colunas de novos casos em um par de colunas:\n cols indica quais colunas serão tombadas e quais serão mantidas. Uma coluna names_to recebe as categorias da variável. Uma coluna values_to recebe os valores das células. values_drop_na é uma opção para eliminar células vazias.  Essa primeira transformação já nos dá um banco de dados um pouco mais amigável, porém, ainda temos variáveis \u0026ldquo;presas\u0026rdquo; na coluna tipo_tb. Vamos tentar soltá-las.\n# primeiro, corrigir uma pequena inconsistencia:\runique(who1$tipo_tb)\r ## [1] \u0026quot;new_sp_m014\u0026quot; \u0026quot;new_sp_m1524\u0026quot; \u0026quot;new_sp_m2534\u0026quot; \u0026quot;new_sp_m3544\u0026quot; \u0026quot;new_sp_m4554\u0026quot;\r## [6] \u0026quot;new_sp_m5564\u0026quot; \u0026quot;new_sp_m65\u0026quot; \u0026quot;new_sp_f014\u0026quot; \u0026quot;new_sp_f1524\u0026quot; \u0026quot;new_sp_f2534\u0026quot;\r## [11] \u0026quot;new_sp_f3544\u0026quot; \u0026quot;new_sp_f4554\u0026quot; \u0026quot;new_sp_f5564\u0026quot; \u0026quot;new_sp_f65\u0026quot; \u0026quot;new_sn_m014\u0026quot; ## [16] \u0026quot;new_sn_m1524\u0026quot; \u0026quot;new_sn_m2534\u0026quot; \u0026quot;new_sn_m3544\u0026quot; \u0026quot;new_sn_m4554\u0026quot; \u0026quot;new_sn_m5564\u0026quot;\r## [21] \u0026quot;new_sn_m65\u0026quot; \u0026quot;new_ep_m014\u0026quot; \u0026quot;new_ep_m1524\u0026quot; \u0026quot;new_ep_m2534\u0026quot; \u0026quot;new_ep_m3544\u0026quot;\r## [26] \u0026quot;new_ep_m4554\u0026quot; \u0026quot;new_ep_m5564\u0026quot; \u0026quot;new_ep_m65\u0026quot; \u0026quot;new_sn_f014\u0026quot; \u0026quot;newrel_m014\u0026quot; ## [31] \u0026quot;newrel_f014\u0026quot; \u0026quot;new_sn_f1524\u0026quot; \u0026quot;new_sn_f2534\u0026quot; \u0026quot;new_sn_f3544\u0026quot; \u0026quot;new_sn_f4554\u0026quot;\r## [36] \u0026quot;new_sn_f5564\u0026quot; \u0026quot;new_sn_f65\u0026quot; \u0026quot;new_ep_f014\u0026quot; \u0026quot;new_ep_f1524\u0026quot; \u0026quot;new_ep_f2534\u0026quot;\r## [41] \u0026quot;new_ep_f3544\u0026quot; \u0026quot;new_ep_f4554\u0026quot; \u0026quot;new_ep_f5564\u0026quot; \u0026quot;new_ep_f65\u0026quot; \u0026quot;newrel_m1524\u0026quot;\r## [46] \u0026quot;newrel_m2534\u0026quot; \u0026quot;newrel_m3544\u0026quot; \u0026quot;newrel_m4554\u0026quot; \u0026quot;newrel_m5564\u0026quot; \u0026quot;newrel_m65\u0026quot; ## [51] \u0026quot;newrel_f1524\u0026quot; \u0026quot;newrel_f2534\u0026quot; \u0026quot;newrel_f3544\u0026quot; \u0026quot;newrel_f4554\u0026quot; \u0026quot;newrel_f5564\u0026quot;\r## [56] \u0026quot;newrel_f65\u0026quot;\r # Notem que newrel deveria ser new_rel\r# Alguns de vocês devem conhecer 'gsub'\rwho1$tipo_tb \u0026lt;- gsub(\u0026quot;newrel\u0026quot;, \u0026quot;new_rel\u0026quot;, who1$tipo_tb)\r# Agora, podemos usar outra função chave do tidyr, 'separate'\rwho2 \u0026lt;- who1 %\u0026gt;% separate(col = tipo_tb,\rinto = c(NA, \u0026quot;tipo_tb\u0026quot;, \u0026quot;sexo_idade\u0026quot;),\rsep = \u0026quot;_\u0026quot;)\rwho2\r ## # A tibble: 76,046 x 5\r## country year tipo_tb sexo_idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m014 0\r## 2 Afghanistan 1997 sp m1524 10\r## 3 Afghanistan 1997 sp m2534 6\r## 4 Afghanistan 1997 sp m3544 3\r## 5 Afghanistan 1997 sp m4554 5\r## 6 Afghanistan 1997 sp m5564 2\r## 7 Afghanistan 1997 sp m65 0\r## 8 Afghanistan 1997 sp f014 5\r## 9 Afghanistan 1997 sp f1524 38\r## 10 Afghanistan 1997 sp f2534 36\r## # ... with 76,036 more rows\r # E outra passagem de separate para separar a idade do sexo\rwho3 \u0026lt;- who2 %\u0026gt;% separate(col = sexo_idade,\rinto = c(\u0026quot;sexo\u0026quot;, \u0026quot;idade\u0026quot;),\rsep = 1)\rwho3\r ## # A tibble: 76,046 x 6\r## country year tipo_tb sexo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m 014 0\r## 2 Afghanistan 1997 sp m 1524 10\r## 3 Afghanistan 1997 sp m 2534 6\r## 4 Afghanistan 1997 sp m 3544 3\r## 5 Afghanistan 1997 sp m 4554 5\r## 6 Afghanistan 1997 sp m 5564 2\r## 7 Afghanistan 1997 sp m 65 0\r## 8 Afghanistan 1997 sp f 014 5\r## 9 Afghanistan 1997 sp f 1524 38\r## 10 Afghanistan 1997 sp f 2534 36\r## # ... with 76,036 more rows\r Bem melhor, não acham? Estamos agora com um banco de dados muito mais adequado para uma análise de dados em R. Cada linha é uma observação, cada coluna é uma informação sobre ela.\nAlguns de vocês podem ter reparado que fizemos um caminho em que nosso banco de dados passou de ter muitas colunas para muitas linhas (ficou mais \u0026ldquo;longo\u0026rdquo;) e depois precisamos separar algumas das colunas que criamos em outras (o que fizemos com separate). Podemos facilmente imaginar situações em que queremos fazer o caminho inverso: transformar um banco do formato longo para o formato com mais colunas e unir colunas separadas em uma nova. Vamos ver um exemplo.\n# Exemplo adaptado de https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population\rpopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Imagine que, por qualquer motivo, você prefira trabalhar com uma variável \u0026ldquo;Data\u0026rdquo; ao invés de dia, mês e ano. Podemos usar unite:\npopulacao2 \u0026lt;- populacao %\u0026gt;% unite(col = Data, Day, Month, Year, sep = \u0026quot; \u0026quot;)\rpopulacao2\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19 May 20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19 May 20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census result[9]\r O outro problema que precisamos resolver frequentemente, é separar um par de variáveis em diversas colunas, fazendo o caminho inverso que fizemos no caso do dataset da OMS.\nus_rent_income\r ## # A tibble: 104 x 5\r## GEOID NAME variable estimate moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama income 24476 136\r## 2 01 Alabama rent 747 3\r## 3 02 Alaska income 32940 508\r## 4 02 Alaska rent 1200 13\r## 5 04 Arizona income 27517 148\r## 6 04 Arizona rent 972 4\r## 7 05 Arkansas income 23789 165\r## 8 05 Arkansas rent 709 5\r## 9 06 California income 29454 109\r## 10 06 California rent 1358 3\r## # ... with 94 more rows\r No exemplo acima, queremos separar em colunas os valores das variáveis de renda e valor do aluguel. Esse tipo de operação tem um certo grau de abstração que me deu bastante dor de cabeça para entender inicialmente, então vamos olhar com carinho para o que queremos ter depois da transformação.\nus_rent_income2 \u0026lt;- tribble(\r~GEOID, ~NAME, ~income_estimate, ~rent_estimate, ~income_moe, ~rent_moe,\r\u0026quot;01\u0026quot;, \u0026quot;Alabama\u0026quot;, 24476, 747, 136, 3,\r\u0026quot;02\u0026quot;, \u0026quot;Alaska\u0026quot;, 32940, 1200, 508, 13\r)\rus_rent_income2\r ## # A tibble: 2 x 6\r## GEOID NAME income_estimate rent_estimate income_moe rent_moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r O banco que queremos tem uma cara assim. Ele tem mais colunas novas e menos linhas, já que eu tinha no formato tidy uma variável chamada \u0026ldquo;variable\u0026rdquo; que guardava os valores renda e aluguel e duas colunas que guardavam os valores da estimativa e do moe. Agora, eu vou ter 4 colunas, duas para as estimativas de renda e aluguel e duas para os moes das mesmas variáveis. Como especificar isso para o banco todo? Usando pivot_wider.\nus_rent_income %\u0026gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe))\r ## # A tibble: 52 x 6\r## GEOID NAME estimate_income estimate_rent moe_income moe_rent\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r## 3 04 Arizona 27517 972 148 4\r## 4 05 Arkansas 23789 709 165 5\r## 5 06 California 29454 1358 109 3\r## 6 08 Colorado 32401 1125 109 5\r## 7 09 Connecticut 35326 1123 195 5\r## 8 10 Delaware 31560 1076 247 10\r## 9 11 District of Columbia 43198 1424 681 17\r## 10 12 Florida 25952 1077 70 3\r## # ... with 42 more rows\r As funções pivot_ tem diversos outros argumentos e cobrem diversos casos de uso. Vejam este exemplo da documentação de pivot_longer:\nanscombe\r ## x1 x2 x3 x4 y1 y2 y3 y4\r## 1 10 10 10 8 8.04 9.14 7.46 6.58\r## 2 8 8 8 8 6.95 8.14 6.77 5.76\r## 3 13 13 13 8 7.58 8.74 12.74 7.71\r## 4 9 9 9 8 8.81 8.77 7.11 8.84\r## 5 11 11 11 8 8.33 9.26 7.81 8.47\r## 6 14 14 14 8 9.96 8.10 8.84 7.04\r## 7 6 6 6 8 7.24 6.13 6.08 5.25\r## 8 4 4 4 19 4.26 3.10 5.39 12.50\r## 9 12 12 12 8 10.84 9.13 8.15 5.56\r## 10 7 7 7 8 4.82 7.26 6.42 7.91\r## 11 5 5 5 8 5.68 4.74 5.73 6.89\r Podemos transformar esse banco de dados rapidamente usando um dos argumentos de pivot_longer, chamado names_pattern.\nanscombe %\u0026gt;% pivot_longer(everything(),\rnames_to = c(\u0026quot;.value\u0026quot;, \u0026quot;set\u0026quot;),\rnames_pattern = \u0026quot;(.)(.)\u0026quot;)\r ## # A tibble: 44 x 3\r## set x y\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10 8.04\r## 2 2 10 9.14\r## 3 3 10 7.46\r## 4 4 8 6.58\r## 5 1 8 6.95\r## 6 2 8 8.14\r## 7 3 8 6.77\r## 8 4 8 5.76\r## 9 1 13 7.58\r## 10 2 13 8.74\r## # ... with 34 more rows\r Esse exemplo é interessante, porque ele se aproveita de uma \u0026ldquo;regular expression\u0026rdquo;, tema da parte do nosso curso em que falaremos sobre manipulação de strings com o stringr. Resumidas as contas, as colunas se chamam \u0026ldquo;x1, x2, x3 \u0026hellip;\u0026rdquo; e a string \u0026ldquo;(.)(.)\u0026rdquo; indica que há dois \u0026ldquo;grupos\u0026rdquo; formados por um caractere cada. A string \u0026ldquo;.value\u0026rdquo; que vai no argumento de cima é um atalho da função para dizer \u0026ldquo;pegue o valor de todas as células das variáveis selecionadas\u0026rdquo;, aqui, todas. Ou seja, ele indica para a função que o primeiro caractere \u0026ldquo;x\u0026rdquo; ou \u0026ldquo;y\u0026rdquo; definirá uma nova variável e armazenará os valores das celulas, enquanto o segundo grupo \u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo; ou \u0026ldquo;4\u0026rdquo; formará uma segunda variável chamada \u0026ldquo;set\u0026rdquo; que contém apenas os nomes das colunas. Deu um nó na cabeça?\nUma última preocupação ao utilizar a reformatação de dados é o que ocorre com os valores NA. Vejamos este exemplo:\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\r Existem dois tipos de valor nulo, explícito se diz de um valor nulo como aquele NA que aparece na variável lucro. Implícito é o valor que ocorre no primeiro quadrimestre de 2016, onde sequer foi adicionada uma linha no banco de dados. Os valores implícitos são muito sacanas, porque eles não são imediatamente visíveis.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro)\r ## # A tibble: 4 x 3\r## qdr `2015` `2016`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1.88 NA ## 2 2 0.59 0.92\r## 3 3 0.35 0.17\r## 4 4 NA 2.66\r Ao transformar o banco, o valor implícito ficou explícito. Caso você não esteja interessado neste valor, você pode passar o values_drop_na durante a transformação de volta ao formato original.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro) %\u0026gt;% pivot_longer(c(`2015`, `2016`),\rnames_to = \u0026quot;ano\u0026quot;,\rvalues_to = \u0026quot;lucro\u0026quot;,\rvalues_drop_na = TRUE)\r ## # A tibble: 6 x 3\r## qdr ano lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2015 1.88\r## 2 2 2015 0.59\r## 3 2 2016 0.92\r## 4 3 2015 0.35\r## 5 3 2016 0.17\r## 6 4 2016 2.66\r Que faz os valores missing desaparecerem do resultado.\ncomplete pode ser usada pra tornar valores implícitos, explícitos! A função toma todas as colunas pedidas e verifica todas as combinações possíveis de valores, preenchendo as lacunas com NA. Cuidado ao utilizar complete com valores numéricos ou conjuntos de colunas com muitas combinações possíveis, pois o número de combinações pode ser infinitamente grande e travar sua sessão!\nacoes %\u0026gt;% complete(ano, qdr)\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Pra encerrar, fill serve para aqueles casos em que um valor missing indica que a última observação deve ser repetida. Pesquisadores brasileiros das antigas podem lembrar-se do Censo de 1991, em que o IBGE registrava os arquivos de domícilio e pessoas com esse sistema. Em inglês, isso se chama LOCF, ou \u0026ldquo;last observation carried forward\u0026rdquo;.\ntreatment \u0026lt;- tribble(\r~ person, ~ treatment, ~response,\r\u0026quot;Derrick Whitmore\u0026quot;, 1, 7,\rNA, 2, 10,\rNA, 3, 9,\r\u0026quot;Katherine Burke\u0026quot;, 1, 4\r)\rtreatment\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 \u0026lt;NA\u0026gt; 2 10\r## 3 \u0026lt;NA\u0026gt; 3 9\r## 4 Katherine Burke 1 4\r treatment %\u0026gt;% fill(person)\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 Derrick Whitmore 2 10\r## 3 Derrick Whitmore 3 9\r## 4 Katherine Burke 1 4\r tidyr tem também outras funcionalidades relevantes para modelagem estatística, mas acho que isso sai um pouco do escopo do curso. Quem sabe a gente não faz um curso posterior só sobre modelagem no tidyverse?\nRevisão readr O pacote readr apresenta uma família de funções para substituir as funções do base relacionadas a importação de arquivos em formato texto, seja delimitado ou largura-fixa. São elas,\n read_delim read_csv read_csv2 read_tsv read_table read_fwf  E assim sucessivamente. Durante o processo de importação, você pode querer especificar o tipo de coluna com cols ou cols_only, usando o argumento col_types. Ou use uma string do tipo \u0026ldquo;ddcdiDT\u0026rdquo; em que cada letra é um tipo de variável.\n col_integer col_double col_factor col_character  Etc. Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nAh, e você sempre pode salvar com write_, inclusive salvando/lendo compactado para bzip, gzip ou xzip.\ntibble Tibbles são uma versão do data.frame com algumas regrinhas novas. Vou apenas repetí-las aqui de forma resumida.\n tibbles tem um método print mais bonito e amigável, especialmente para bancos com muitas observações e variáveis. elas são estritas com operações de subsetting com [ e $. elas não aceita a reciclagem de argumento de tamanho diferente de 1.  tidyr tidyr é um pacote de reformatação de bancos, criando novas linhas e colunas a partir da reorganização das variáveis e valores existentes. Suas principais operações são:\n pivot_longer para converter colunas em linhas pivot_wider para converter linhas em colunas separate para separar uma coluna em várias com base em caracteres unite para unir diversas colunas em uma com base em caracteres  Ufa. Acabou né? Posso ir dormir já? Claro, só fazer uns exercícios!\nExercícios  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  file \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.  # Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\rbillboard  ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r  Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?\n  O que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.\n  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r  Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?\n  Compare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?\n  Agradecimentos Esse material é uma adaptação livre das vinhetas dos pacotes tidyr, readr e tibble e do capítulo Tidy Data do R for Data Science, de Wickham \u0026amp; Grolemund.\n","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"0bad4868b4cebec13d81438fabee26ad","permalink":"https://laddem.github.io/courses/tidyverse/dia1/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia1/","section":"courses","summary":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:","tags":null,"title":"readr, tibble e tidyr","type":"book"},{"authors":null,"categories":null,"content":"\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\nO pacote stringr é uma série de adaptações da biblioteca stringi e serve para a manipulação de variáveis texto, incluindo funções para detecção, modificação, substituição, remoção de texto em variáveis caractere. Para dominar esse assunto, é necessário compreender o conceito de “regex,” ou “expressão regular,” que foge um pouco do escopo do curso, mas que será introduzido brevemente.\nO pacote forcats contém uma série de funções para trabalhar com o tipo factor. São funções que facilitam operações envolvendo esse tipo de variável, como contagens, troca dos nomes das categorias, agrupamento de categorias, recodificação, plotagem, etc.\nO pacote dplyr é um dos pilares do tidyverse e ele tem dois papéis principais: operações de manipulação de banco de dados simples e operações de bancos de dados relacionais. No primeiro tipo são incluídas as operações de criação e modificação de variáveis, medidas resumo globais e por grupos, seleção de variáveis, mudança da ordem das linhas e colunas, etc. No segundo tipo, são as operações de tipo _join, em que uma variável chave é utilizada para combinar registros de dois bancos de dados distintos.\nOs pacotes stringr e forcats são mais diretos, mas o dplyr pode representar um certo nível de abstração que pode incomodar usuários de longa data do R, portanto, vamos nos esforçar para demonstrar as vantagens de mudar seu workflow para incluir as funções desse pacote através de comparações com o R base.\ndplyr dplyr para manipulação de dados Talvez o pacote mais utilizado de todo o tidyverse, dplyr é um pacote de manipulação de bancos de dados inspirado pela linguagem SQL. A ideia é concatenar operações de seleção de variáveis, filtragem de observação, arranjo e ordenamento, derivação de variáveis, computação de medidas resumo para o banco todo ou para grupos. As funções básicas e mais utilizadas são, portanto:\n select filter arrange mutate summarize group_by  Para praticar, vamos usar o dataset flights, que contém informações sobre os vôos saídos de Nova Iorque em 2013.\nlibrary(nycflights13)\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r## The following objects are masked from 'package:stats':\r## ## filter, lag\r## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r flights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r glimpse(flights)\r ## Rows: 336,776\r## Columns: 19\r## $ year \u0026lt;int\u0026gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2~\r## $ month \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ day \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ dep_time \u0026lt;int\u0026gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, ~\r## $ sched_dep_time \u0026lt;int\u0026gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, ~\r## $ dep_delay \u0026lt;dbl\u0026gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1~\r## $ arr_time \u0026lt;int\u0026gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,~\r## $ sched_arr_time \u0026lt;int\u0026gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,~\r## $ arr_delay \u0026lt;dbl\u0026gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1~\r## $ carrier \u0026lt;chr\u0026gt; \u0026quot;UA\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;DL\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;EV\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;~\r## $ flight \u0026lt;int\u0026gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4~\r## $ tailnum \u0026lt;chr\u0026gt; \u0026quot;N14228\u0026quot;, \u0026quot;N24211\u0026quot;, \u0026quot;N619AA\u0026quot;, \u0026quot;N804JB\u0026quot;, \u0026quot;N668DN\u0026quot;, \u0026quot;N394~\r## $ origin \u0026lt;chr\u0026gt; \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;,~\r## $ dest \u0026lt;chr\u0026gt; \u0026quot;IAH\u0026quot;, \u0026quot;IAH\u0026quot;, \u0026quot;MIA\u0026quot;, \u0026quot;BQN\u0026quot;, \u0026quot;ATL\u0026quot;, \u0026quot;ORD\u0026quot;, \u0026quot;FLL\u0026quot;, \u0026quot;IAD\u0026quot;,~\r## $ air_time \u0026lt;dbl\u0026gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1~\r## $ distance \u0026lt;dbl\u0026gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, ~\r## $ hour \u0026lt;dbl\u0026gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6~\r## $ minute \u0026lt;dbl\u0026gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0~\r## $ time_hour \u0026lt;dttm\u0026gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0~\r Podemos filtrar nossas linhas: filter\n# Voos de primeiro de janeiro\rflights %\u0026gt;% filter(month == 1, day == 1)\r ## # A tibble: 842 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 832 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos a partir de junho\rflights %\u0026gt;% filter(month \u0026gt; 6)\r ## # A tibble: 170,618 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 170,608 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saídos do aeroporto JFK\rflights %\u0026gt;% filter(origin == \u0026quot;JFK\u0026quot;)\r ## # A tibble: 111,279 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 111,269 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com destino ao aeroporto de Albuquerque\rflights %\u0026gt;% filter(dest == \u0026quot;ABQ\u0026quot;)\r ## # A tibble: 254 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 1955 2001 -6 2213 2248\r## 2 2013 10 2 2010 2001 9 2230 2248\r## 3 2013 10 3 1955 2001 -6 2232 2248\r## 4 2013 10 4 2017 2001 16 2304 2248\r## 5 2013 10 5 1959 1959 0 2226 2246\r## 6 2013 10 6 1959 2001 -2 2234 2248\r## 7 2013 10 7 2002 2001 1 2233 2248\r## 8 2013 10 8 1957 2001 -4 2216 2248\r## 9 2013 10 9 1957 2001 -4 2220 2248\r## 10 2013 10 10 2011 2001 10 2235 2248\r## # ... with 244 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de até 10 minutos\rflights %\u0026gt;% filter(dep_delay \u0026lt;= 10)\r ## # A tibble: 245,687 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 245,677 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de cerca de 10 minutos\rflights %\u0026gt;% filter(near(dep_delay, 10, tol = 2))\r ## # A tibble: 8,677 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 611 600 11 945 931\r## 2 2013 1 1 709 700 9 852 832\r## 3 2013 1 1 826 817 9 1145 1158\r## 4 2013 1 1 851 840 11 1215 1206\r## 5 2013 1 1 1011 1001 10 1133 1128\r## 6 2013 1 1 1208 1158 10 1540 1502\r## 7 2013 1 1 1240 1229 11 1451 1428\r## 8 2013 1 1 1310 1300 10 1559 1554\r## 9 2013 1 1 1330 1321 9 1613 1536\r## 10 2013 1 1 1511 1500 11 1753 1742\r## # ... with 8,667 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos que ocorreram entre abril e maio\rflights %\u0026gt;% filter(between(month, 4, 5))\r ## # A tibble: 57,126 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 57,116 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Podemos combinar várias condições usando operadores lógicos\n# Voos até 15 de abril ou até 15 de maio\rflights %\u0026gt;% filter(\rbetween(month, 4, 5), # mesmo que usar \u0026amp;\rbetween(day, 1, 15)\r)\r ## # A tibble: 28,176 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 28,166 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos entre 15 de abril e 15 de maio\rflights %\u0026gt;% filter(\rmonth == 4 \u0026amp; between(day, 15, 30) | # OU\rmonth == 5 \u0026amp; between(day, 1, 15)\r)\r ## # A tibble: 29,101 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 15 2 2359 3 341 339\r## 2 2013 4 15 453 500 -7 639 640\r## 3 2013 4 15 511 515 -4 741 802\r## 4 2013 4 15 527 530 -3 806 813\r## 5 2013 4 15 527 529 -2 750 743\r## 6 2013 4 15 537 540 -3 846 840\r## 7 2013 4 15 542 545 -3 931 927\r## 8 2013 4 15 551 600 -9 728 758\r## 9 2013 4 15 552 600 -8 835 850\r## 10 2013 4 15 552 600 -8 648 701\r## # ... with 29,091 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos em todas os primeiros 7 dias de cada mês, exceto em janeiro e dezembro\rflights %\u0026gt;% filter(\rbetween(day, 1, 7),\r!month %in% c(1, 12)\r)\r ## # A tibble: 64,365 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 64,355 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saidos de JFK, excluindo aqueles para os quais não tem informações de horário de saída\rflights %\u0026gt;% filter(\rorigin == \u0026quot;JFK\u0026quot;, !is.na(dep_time)\r)\r ## # A tibble: 109,416 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 109,406 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com mais de 30 minutos de atraso em janeiro ou dezembro\rflights %\u0026gt;% filter(\rdep_delay \u0026gt; 30, xor(month == 1, month == 12)\r)\r ## # A tibble: 8,221 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 732 645 47 1011 941\r## 2 2013 1 1 749 710 39 939 850\r## 3 2013 1 1 811 630 101 1047 830\r## 4 2013 1 1 826 715 71 1136 1045\r## 5 2013 1 1 848 1835 853 1001 1950\r## 6 2013 1 1 903 820 43 1045 955\r## 7 2013 1 1 909 810 59 1331 1315\r## 8 2013 1 1 953 921 32 1320 1241\r## 9 2013 1 1 957 733 144 1056 853\r## 10 2013 1 1 1025 951 34 1258 1302\r## # ... with 8,211 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r E assim sucessivamente.\nDa mesma forma, temos select para selecionar as variáveis do banco. As duas grandes novidades são que você não precisa utilizar aspas na seleção de variáveis e que select introduz várias helper functions para facilitar a seleção de variáveis parecidas.\n# Selecionar as colunas ano, mes, dia, horario de saida e horario de chegada\rflights %\u0026gt;% select(year, month, day, dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Utilizando helpers\rflights %\u0026gt;% select(year:dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Mais helpers\rflights %\u0026gt;% select(year:day, starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 2 830 11\r## 2 2013 1 1 533 4 850 20\r## 3 2013 1 1 542 2 923 33\r## 4 2013 1 1 544 -1 1004 -18\r## 5 2013 1 1 554 -6 812 -25\r## 6 2013 1 1 554 -4 740 12\r## 7 2013 1 1 555 -5 913 19\r## 8 2013 1 1 557 -3 709 -14\r## 9 2013 1 1 557 -3 838 -8\r## 10 2013 1 1 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, ends_with(\u0026quot;time\u0026quot;))\r ## # A tibble: 336,776 x 8\r## year month day dep_time sched_dep_time arr_time sched_arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 515 830 819 227\r## 2 2013 1 1 533 529 850 830 227\r## 3 2013 1 1 542 540 923 850 160\r## 4 2013 1 1 544 545 1004 1022 183\r## 5 2013 1 1 554 600 812 837 116\r## 6 2013 1 1 554 558 740 728 150\r## 7 2013 1 1 555 600 913 854 158\r## 8 2013 1 1 557 600 709 723 53\r## 9 2013 1 1 557 600 838 846 140\r## 10 2013 1 1 558 600 753 745 138\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, c(ends_with(\u0026quot;time\u0026quot;)) \u0026amp; !contains(\u0026quot;sched\u0026quot;))\r ## # A tibble: 336,776 x 6\r## year month day dep_time arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 830 227\r## 2 2013 1 1 533 850 227\r## 3 2013 1 1 542 923 160\r## 4 2013 1 1 544 1004 183\r## 5 2013 1 1 554 812 116\r## 6 2013 1 1 554 740 150\r## 7 2013 1 1 555 913 158\r## 8 2013 1 1 557 709 53\r## 9 2013 1 1 557 838 140\r## 10 2013 1 1 558 753 138\r## # ... with 336,766 more rows\r # Você pode mudar o nome das colunas durante um call para select\rflights %\u0026gt;% select(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 3\r## ano mes dia\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1\r## 2 2013 1 1\r## 3 2013 1 1\r## 4 2013 1 1\r## 5 2013 1 1\r## 6 2013 1 1\r## 7 2013 1 1\r## 8 2013 1 1\r## 9 2013 1 1\r## 10 2013 1 1\r## # ... with 336,766 more rows\r # Ou você pode usar rename para mudar os nomes sem selecionar variáveis\rflights %\u0026gt;% rename(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 19\r## ano mes dia dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r São realmente muitas possibilidades, vejam a documentação e os exemplos em ?select.\nUtilizando arrange podemos facilmente organizar nosso banco a partir de variáveis de interesse:\n# Selecionar algumas variáveis e ver organizar de acordar com os mais adiantados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(dep_delay, arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 12 7 2040 -43 40 48\r## 2 2013 2 3 2022 -33 2240 -58\r## 3 2013 11 10 1408 -32 1549 -10\r## 4 2013 1 11 1900 -30 2233 -10\r## 5 2013 1 29 1703 -27 1947 -10\r## 6 2013 8 9 729 -26 1002 7\r## 7 2013 3 30 2030 -25 2213 -37\r## 8 2013 10 23 1907 -25 2143 0\r## 9 2013 5 5 934 -24 1225 -44\r## 10 2013 9 18 1631 -24 1812 -33\r## # ... with 336,766 more rows\r # Ou os mais atrasados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(-dep_delay, -arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 9 641 1301 1242 1272\r## 2 2013 6 15 1432 1137 1607 1127\r## 3 2013 1 10 1121 1126 1239 1109\r## 4 2013 9 20 1139 1014 1457 1007\r## 5 2013 7 22 845 1005 1044 989\r## 6 2013 4 10 1100 960 1342 931\r## 7 2013 3 17 2321 911 135 915\r## 8 2013 6 27 959 899 1236 850\r## 9 2013 7 22 2257 898 121 895\r## 10 2013 12 5 756 896 1058 878\r## # ... with 336,766 more rows\r É basicamente isso, você pode especificar uma ou muitas colunas para organizar, decidir se a ordem é ascendente ou descendente e pronto.\nUtilizando mutate, você cria variáveis derivadas das originais. Como tibble, essa função avalia seus argumentos de maneira preguiçosa e sequencial, o que permite você criar variáveis derivadas umas das outras muito facilmente.\nflights %\u0026gt;% select(sched_dep_time, dep_time, sched_arr_time, arr_time) %\u0026gt;% mutate(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 8\r## sched_dep_time dep_time sched_arr_time arr_time atraso_decolagem atraso_pouso\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 515 517 819 830 2 11\r## 2 529 533 830 850 4 20\r## 3 540 542 850 923 2 73\r## 4 545 544 1022 1004 -1 -18\r## 5 600 554 837 812 -46 -25\r## 6 558 554 728 740 -4 12\r## 7 600 555 854 913 -45 59\r## 8 600 557 723 709 -43 -14\r## 9 600 557 846 838 -43 -8\r## 10 600 558 745 753 -42 8\r## # ... with 336,766 more rows, and 2 more variables: atraso_dec_horas \u0026lt;dbl\u0026gt;,\r## # atraso_pouso_horas \u0026lt;dbl\u0026gt;\r # Transmute é um atalho para quando você quer apenas as variáveis resultado e não está interessado nas intermediárias.\rflights %\u0026gt;% transmute(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 4\r## atraso_decolagem atraso_pouso atraso_dec_horas atraso_pouso_horas\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 11 0.0333 0.183\r## 2 4 20 0.0667 0.333\r## 3 2 73 0.0333 1.22 ## 4 -1 -18 -0.0167 -0.3 ## 5 -46 -25 -0.767 -0.417\r## 6 -4 12 -0.0667 0.2 ## 7 -45 59 -0.75 0.983\r## 8 -43 -14 -0.717 -0.233\r## 9 -43 -8 -0.717 -0.133\r## 10 -42 8 -0.7 0.133\r## # ... with 336,766 more rows\r Usando o pipe, é fazer diversas operações de transformação de variáveis simultâneamente em um único call sem a necessidade de repetir o nome do objeto e $ a cada referência. mutate é uma função extremamente flexível, você pode chamar qualquer função que retorne um vetor de tamanho 1 ou de tamanho do número de linhas do banco lá dentro para criar uma variável.\ndesabafo \u0026lt;- function(x) {\ry \u0026lt;- floor(x / 60)\rdplyr::case_when(\r# Condições ~ Resultados\ry \u0026lt; 0 ~ \u0026quot;Opa, vou chegar cedo!\u0026quot;,\ry \u0026lt; 1 ~ \u0026quot;Atraso de menos de 1 hora é tolerável\u0026quot;,\ry \u0026gt;= 1 ~ paste0(\u0026quot;Atraso de mais de \u0026quot;, y, \u0026quot; horas é f***.\u0026quot;),\rTRUE ~ \u0026quot;Ahn?\u0026quot; # Condição guarda-chuva\r)\r}\rflights %\u0026gt;% select(dep_delay) %\u0026gt;% mutate(desabafo = desabafo(dep_delay)) %\u0026gt;% sample_n(10)\r ## # A tibble: 10 x 2\r## dep_delay desabafo ## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 -5 Opa, vou chegar cedo! ## 2 23 Atraso de menos de 1 hora é tolerável\r## 3 -4 Opa, vou chegar cedo! ## 4 -3 Opa, vou chegar cedo! ## 5 -8 Opa, vou chegar cedo! ## 6 -3 Opa, vou chegar cedo! ## 7 -5 Opa, vou chegar cedo! ## 8 22 Atraso de menos de 1 hora é tolerável\r## 9 23 Atraso de menos de 1 hora é tolerável\r## 10 -2 Opa, vou chegar cedo!\r Utilizando summarize você tira medidas resumo das suas colunas de interesse:\nflights %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 1 x 5\r## atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~ n_voos\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 12.6 40.2 6.90 44.6 336776\r Parece uma bobagem, mas quando você junta isso com a última função, group_by, é possível obter diversas estatísticas de interesse muito rapidamente e para vários domínios:\n# Por mês\rflights %\u0026gt;% group_by(month) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 12 x 6\r## month atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 36.4 6.13 40.4\r## 2 2 10.8 36.3 5.61 39.5\r## 3 3 13.2 40.1 5.81 44.1\r## 4 4 13.9 43.0 11.2 47.5\r## 5 5 13.0 39.4 3.52 44.2\r## 6 6 20.8 51.5 16.5 56.1\r## 7 7 21.7 51.6 16.7 57.1\r## 8 8 12.6 37.7 6.04 42.6\r## 9 9 6.72 35.6 -4.02 39.7\r## 10 10 6.24 29.7 -0.167 32.6\r## 11 11 5.44 27.6 0.461 31.4\r## 12 12 16.6 41.9 14.9 46.1\r## # ... with 1 more variable: n_voos \u0026lt;int\u0026gt;\r # Por mês e aeroporto de origem\rflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 EWR 14.9 40.8 12.8 ## 2 1 JFK 8.62 36.0 1.37\r## 3 1 LGA 5.64 29.7 3.38\r## 4 2 EWR 13.1 37.2 8.78\r## 5 2 JFK 11.8 37.4 4.39\r## 6 2 LGA 6.96 33.4 3.15\r## 7 3 EWR 18.1 44.1 10.6 ## 8 3 JFK 10.7 35.3 2.58\r## 9 3 LGA 10.2 39.7 3.74\r## 10 4 EWR 17.4 43.9 14.1 ## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r Uma vez que você se familiariza com a gramática do dplyr, o processo de análise exploratória se torna bastante trivial e até certo ponto, prazeiroso. Mas o que eu realmente gosto é que ele também se torna visualmente óbvio para o leitor, com cada chamado podendo ser lido como uma declaração:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo.\n Você também pode rapidamente introduzir ou retirar passos em cada chamado deste utilizando o pipe, por exemplo:\nflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38\r## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r E a leitura fica:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo, então, ordene os resultados pelo maior atraso.\n De quebra, você ainda leva para casa um dado no formato “tabela,” fácil de exportar para outros softwares para embelezamento e publicação. Veja:\nresumo \u0026lt;- flights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r print(resumo, n = Inf)\r ## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38 ## 11 1 EWR 14.9 40.8 12.8 ## 12 12 JFK 14.8 39.1 12.7 ## 13 12 LGA 13.6 39.8 12.0 ## 14 8 EWR 13.5 37.6 6.71 ## 15 2 EWR 13.1 37.2 8.78 ## 16 8 JFK 12.9 36.3 5.91 ## 17 5 JFK 12.5 38.5 2.12 ## 18 4 JFK 12.2 41.2 7.01 ## 19 2 JFK 11.8 37.4 4.39 ## 20 4 LGA 11.5 43.4 12.0 ## 21 8 LGA 11.2 39.2 5.41 ## 22 3 JFK 10.7 35.3 2.58 ## 23 5 LGA 10.6 40.6 2.80 ## 24 3 LGA 10.2 39.7 3.74 ## 25 10 EWR 8.64 32.7 2.60 ## 26 1 JFK 8.62 36.0 1.37 ## 27 9 EWR 7.29 35.0 -4.73 ## 28 2 LGA 6.96 33.4 3.15 ## 29 11 EWR 6.72 28.8 0.672\r## 30 9 JFK 6.64 32.5 -4.46 ## 31 9 LGA 6.21 39.0 -2.83 ## 32 1 LGA 5.64 29.7 3.38 ## 33 10 LGA 5.31 30.1 0.186\r## 34 11 LGA 4.77 26.6 1.55 ## 35 11 JFK 4.68 27.1 -0.873\r## 36 10 JFK 4.59 25.2 -3.59 ## # ... with 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;, n_voos \u0026lt;int\u0026gt;\r Lembrem-se que é necessário atribuir \u0026lt;- os resultados das operações para que elas sejam salvas. Em geral, meu workflow é assim:\n# Começo com o banco\rflights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Seleciono algumas variáveis\rflights %\u0026gt;% select(month, dep_delay, arr_delay)\r ## # A tibble: 336,776 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 336,766 more rows\r # Recorto algumas observações\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6))\r ## # A tibble: 166,158 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 166,148 more rows\r # Escolho os dominios e calculo as medidas resumo\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T))\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 6.13\r## 2 2 10.8 5.61\r## 3 3 13.2 5.81\r## 4 4 13.9 11.2 ## 5 5 13.0 3.52\r## 6 6 20.8 16.5\r # Acho bom organizar pelos atrasos maiores\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r # Estou satisfeito, salvo meu resultado em outro objeto\ratrasos \u0026lt;- flights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\ratrasos\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r Desta forma, consigo construir interativamente meus cálculos, verificando a cada passo se estou obtendo o resultado esperado. Visto de outra perspectiva, se encontro um código programado desta forma que não funciona, posso ir apagando cada %\u0026gt;% para identificar onde o problema ocorreu.\nEspero que tenha ficado claro que o assunto não se encerra por aqui. Existem diversas outras funções úteis no pacote, como count, if_else, case_when, top_n, bind_rows, bind_cols, as novas funções across e c_across e muitas, muitas outras. Nos livros vocês encontram vários outros exemplos e funções para facilitar o processo de análise de dados, mas nossa expectativa é que essa apresentação seja um ponto de partida para vocês se aprofundarem no seu próprio ritmo.\ndplyr para bancos de dados relacionais Nesta seção, o nosso problema não é mais a análise de dados presentes em um banco, mas o problema de relacionar informações sobre uma mesma unidade de análise que estão presentes em vários bancos de dados distintos.\nO banco nycflights13 contém várias tabelas que se relacionam, e elas funcionam como um excelente exemplo de banco de dados relacionais.\nNote que além do banco de dados dos vôos, temos informações sobre clima, aviões e companhias aéreas. Para nós, pode ser relevante reunir informações de diferentes fontes em um mesmo banco de dados, algo que é possível através de joins. Por uma questão de tempo, não vamos entrar muito a fundo no assunto, mas vamos introduzir dois conceitos chave e partir pros exemplos.\n  chaves são as variáveis que identificam cada observação em um banco de dados de forma única. Uma chave é dita “primária” quando identifica uma observação na sua própria tabela e “externa” quando ela identifica uma observação em outra tabela. Assim, qualquer operação de join é uma forma de relacionar uma chave primária e uma chave externa. Essa junção de chaves é uma relação, e as relações podem ser 1 para 1, 1 para muitos ou muitos para 1.\n  joins são tipos de operação no qual se opta por priorizar um grupo de observações em detrimento de outras. Podemos vê-los didaticamente a partir de duas figuras:\n  A primeira figura é interessante porque nos dá uma ideia de quais observações serão mantidas e quais serão descartadas, podemos imaginá-la como uma abstração da nossa escolha.\n Quero todas as informações sobre os vôos e os aeroportos, e as duas são igualmente importantes (inner_join, x = flights, y = airports).\n  Quero todas as observações do banco vôos e as informações disponíveis sobre a aeronave (left_join, x = flights, y = planes).\n  Quero todas as informações tanto sobre os vôos quanto sobre o clima em cada dia (full_join, x = flights, y = weather).\n  Quero as informações dos vôos realizados pelas companhias aéreas - minha prioridade são as cias. áreas (right_join, x = flights, y = carriers).\n A segunda figura é interessante porque elas mostra a mecânica de um join: cada observação tem a sua chave marcada com a observação correspondente no outro banco. Se as chaves são iguais, a operação é realizada, se as chaves não são iguais, a operação não é realizada. Dependendo do tipo de join, uma, as duas ou nenhuma das observações é descartada do banco resultante.\n Antes de começar a trabalhar com bancos relacionais, é uma boa ideia dar uma explorada nas chaves, vendo suas contagens, se há erros de digitação, etc. Por uma questão de tempo, vamos pular essa fase.\n Se as nossas chaves forem perfeitinhas, e inclusive tiverem o mesmo nome nas duas tabelas, basta invocar o tipo de join desejado.\n# Vamos dar uma enxugada no flights para poder ver o efeito dos joins com maior facilidade.\rflights2 \u0026lt;- flights %\u0026gt;% select(year:day, hour, origin, dest, tailnum, carrier)\rflights2\r ## # A tibble: 336,776 x 8\r## year month day hour origin dest tailnum carrier\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA ## 2 2013 1 1 5 LGA IAH N24211 UA ## 3 2013 1 1 5 JFK MIA N619AA AA ## 4 2013 1 1 5 JFK BQN N804JB B6 ## 5 2013 1 1 6 LGA ATL N668DN DL ## 6 2013 1 1 5 EWR ORD N39463 UA ## 7 2013 1 1 6 EWR FLL N516JB B6 ## 8 2013 1 1 6 LGA IAD N829AS EV ## 9 2013 1 1 6 JFK MCO N593JB B6 ## 10 2013 1 1 6 LGA ORD N3ALAA AA ## # ... with 336,766 more rows\r # Chaves perfeitas, mesmo nome nos dois bancos = natural join\rflights2 %\u0026gt;% left_join(weather) # Moleza\r ## Joining, by = c(\u0026quot;year\u0026quot;, \u0026quot;month\u0026quot;, \u0026quot;day\u0026quot;, \u0026quot;hour\u0026quot;, \u0026quot;origin\u0026quot;)\r## # A tibble: 336,776 x 18\r## year month day hour origin dest tailnum carrier temp dewp humid\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 39.0 28.0 64.4\r## 2 2013 1 1 5 LGA IAH N24211 UA 39.9 25.0 54.8\r## 3 2013 1 1 5 JFK MIA N619AA AA 39.0 27.0 61.6\r## 4 2013 1 1 5 JFK BQN N804JB B6 39.0 27.0 61.6\r## 5 2013 1 1 6 LGA ATL N668DN DL 39.9 25.0 54.8\r## 6 2013 1 1 5 EWR ORD N39463 UA 39.0 28.0 64.4\r## 7 2013 1 1 6 EWR FLL N516JB B6 37.9 28.0 67.2\r## 8 2013 1 1 6 LGA IAD N829AS EV 39.9 25.0 54.8\r## 9 2013 1 1 6 JFK MCO N593JB B6 37.9 27.0 64.3\r## 10 2013 1 1 6 LGA ORD N3ALAA AA 39.9 25.0 54.8\r## # ... with 336,766 more rows, and 7 more variables: wind_dir \u0026lt;dbl\u0026gt;,\r## # wind_speed \u0026lt;dbl\u0026gt;, wind_gust \u0026lt;dbl\u0026gt;, precip \u0026lt;dbl\u0026gt;, pressure \u0026lt;dbl\u0026gt;,\r## # visib \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r flights2 %\u0026gt;% left_join(airlines) # Moleza\r ## Joining, by = \u0026quot;carrier\u0026quot;\r## # A tibble: 336,776 x 9\r## year month day hour origin dest tailnum carrier name ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. ## 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways ## 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Airways ## 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet Airlines Inc.\r## 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Airways ## 10 2013 1 1 6 LGA ORD N3ALAA AA American Airlines Inc. ## # ... with 336,766 more rows\r # Chaves perfeitas, mas há variáveis nos dois bancos com o mesmo nome e que não são chaves\r# É necessário especificar qual a chave\rflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;)\r ## # A tibble: 336,776 x 16\r## year.x month day hour origin dest tailnum carrier year.y type ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wing mult~\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wing mult~\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wing mult~\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wing mult~\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wing mult~\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wing mult~\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000 Fixed wing mult~\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998 Fixed wing mult~\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004 Fixed wing mult~\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA \u0026lt;NA\u0026gt; ## # ... with 336,766 more rows, and 6 more variables: manufacturer \u0026lt;chr\u0026gt;,\r## # model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;, engine \u0026lt;chr\u0026gt;\r Veja que tanto flights2 quanto planes tem uma variável chamada year, mas elas significados diferentes. Em flights2 é o ano do vôo, enquanto em planes é o ano em que a aeronave entra em serviço. Na hora que fazemos o join, uma recebe o sufixo “x” e a outra “y” para a indicar a diferença. Você pode especificar o sufixo desejado para evitar confusão:\nflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;, suffix = c(\u0026quot;_flight\u0026quot;, \u0026quot;_entered_service\u0026quot;))\r ## # A tibble: 336,776 x 16\r## year_flight month day hour origin dest tailnum carrier year_entered_serv~\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 1999\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA\r## # ... with 336,766 more rows, and 7 more variables: type \u0026lt;chr\u0026gt;,\r## # manufacturer \u0026lt;chr\u0026gt;, model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;,\r## # engine \u0026lt;chr\u0026gt;\r Um aviso: cuidado com os produtos cartesianos. Não há um bom exemplo aqui no caso do flights porque o banco já está limpinho, mas se você especificar chaves com uma relação “muitos para muitos,” ele vai registrar no banco novo uma linha para cada combinação possível de variáveis. Em bancos maiores, isso geralmente estoura sua memória e trava o R. Veja este pequeno exemplo de brinquedo.\nx \u0026lt;- tribble(\r~key, ~val_x,\r1, \u0026quot;x1\u0026quot;,\r2, \u0026quot;x2\u0026quot;,\r2, \u0026quot;x3\u0026quot;,\r3, \u0026quot;x4\u0026quot;\r)\ry \u0026lt;- tribble(\r~key, ~val_y,\r1, \u0026quot;y1\u0026quot;,\r2, \u0026quot;y2\u0026quot;,\r2, \u0026quot;y3\u0026quot;,\r3, \u0026quot;y4\u0026quot;\r)\rleft_join(x, y, by = \u0026quot;key\u0026quot;)\r ## # A tibble: 6 x 3\r## key val_x val_y\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 x1 y1 ## 2 2 x2 y2 ## 3 2 x2 y3 ## 4 2 x3 y2 ## 5 2 x3 y3 ## 6 3 x4 y4\r Veja que no resultado foi criada uma linha para cada combinação de val_x e val_y que tem a mesma chave repetida. Podem até existir situações em que isso seja o que você quer mesmo, mas na minha experiência até o momento isso é problema com as chaves duplicadas e é sinal de que há algo errado.\nMas peraí, se você falou que tem 4 tipos de join, porque só dá exemplo de left_join?\nNa prática, operações relacionais são feitas de forma intencional: escolhemos bancos de dados de acordo com o valor que atribuímos a informação presente nele e pinçamos informações relacionadas de outros lugares para adicionar aquilo que é nosso foco. Por isso, na maioria dos casos, o left_join é o mais usual, porque preserva todas as informações do meu banco x e adiciona apenas as informações do banco y que combinaram com sucesso. Isso garante que eu não vou perder nenhuma informação do meu banco principal.\nPra encerrar essa parte, mais exemplos de joins.\n# Minhas chaves tem nomes diferentes, então uso um vetor do tipo c(\u0026quot;chave_x\u0026quot; = \u0026quot;chave_y\u0026quot;)\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;dest\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Georg~ 30.0 -95.3 97\r## 2 2013 1 1 5 LGA IAH N24211 UA Georg~ 30.0 -95.3 97\r## 3 2013 1 1 5 JFK MIA N619AA AA Miami~ 25.8 -80.3 8\r## 4 2013 1 1 5 JFK BQN N804JB B6 \u0026lt;NA\u0026gt; NA NA NA\r## 5 2013 1 1 6 LGA ATL N668DN DL Harts~ 33.6 -84.4 1026\r## 6 2013 1 1 5 EWR ORD N39463 UA Chica~ 42.0 -87.9 668\r## 7 2013 1 1 6 EWR FLL N516JB B6 Fort ~ 26.1 -80.2 9\r## 8 2013 1 1 6 LGA IAD N829AS EV Washi~ 38.9 -77.5 313\r## 9 2013 1 1 6 JFK MCO N593JB B6 Orlan~ 28.4 -81.3 96\r## 10 2013 1 1 6 LGA ORD N3ALAA AA Chica~ 42.0 -87.9 668\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r # Mesma coisa, só que agora juntando as informações da origem ao invés do destino\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;origin\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Newar~ 40.7 -74.2 18\r## 2 2013 1 1 5 LGA IAH N24211 UA La Gu~ 40.8 -73.9 22\r## 3 2013 1 1 5 JFK MIA N619AA AA John ~ 40.6 -73.8 13\r## 4 2013 1 1 5 JFK BQN N804JB B6 John ~ 40.6 -73.8 13\r## 5 2013 1 1 6 LGA ATL N668DN DL La Gu~ 40.8 -73.9 22\r## 6 2013 1 1 5 EWR ORD N39463 UA Newar~ 40.7 -74.2 18\r## 7 2013 1 1 6 EWR FLL N516JB B6 Newar~ 40.7 -74.2 18\r## 8 2013 1 1 6 LGA IAD N829AS EV La Gu~ 40.8 -73.9 22\r## 9 2013 1 1 6 JFK MCO N593JB B6 John ~ 40.6 -73.8 13\r## 10 2013 1 1 6 LGA ORD N3ALAA AA La Gu~ 40.8 -73.9 22\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r O assunto, obviamente, não pára por aí. Nos livros vocês encontrarão mais exemplos e funções, como é o caso do semi_join e do anti_join e das operações “set,” intersect, union e setdiff, mas isso fica pra vocês explorarem por conta própria e virem tirar as dúvidas depois!\nstringr stringr contém uma família de funções, todas começadas em str_, cuja principal preocupação é a consistência. As funções do base para strings são muito úteis, porém, seus argumentos estão numa ordem um pouco estranha, algumas funções são vetorizadas e outras não. Quando você se acostuma, até que não é tão ruim, mas voltando para o assunto discutido ontem de tornar o seu código mais legível, é interessante ter a simplicidade oferecida.\nBasicão da string Como este curso já é pra praticantes de R, vou pular algumas coisas muito básicas de string, vamos ao que interessa.\nDeterminados caracteres tem um significado especial dentro das strings. Quem já tentou copiar e colar um caminho de arquivo do Windows pro R sabe disso. Então, nesses casos, é precisar “escapar” caracteres. Por exemplo, se você quiser escrever aspas, você usar a contrabarra \\ para “escapar” um caractere.\naspa_simples \u0026lt;- '\\'' # ou \u0026quot;'\u0026quot;\raspa_dupla \u0026lt;- \u0026quot;\\\u0026quot;\u0026quot; # ou '\u0026quot;'\r A regra do escape é simples, então se você quiser colocar uma contrabarra \\\nx \u0026lt;- c(\u0026quot;\\\\\u0026quot;, \u0026quot;\\\u0026quot;\u0026quot;)\rx\r ## [1] \u0026quot;\\\\\u0026quot; \u0026quot;\\\u0026quot;\u0026quot;\r writeLines(x)\r ## \\\r## \u0026quot;\r Outros caracteres especiais úteis: \u0026quot;\\n\u0026quot; para pular uma linha, \\t para Tab. Você pode ver os outros na ajuda das aspas \u0026quot;, basta digitar no console ?\u0026quot;'\u0026quot; ou ?'\u0026quot;'.\nOutra coisa que dá pra fazer, se você precisar incluir um caractere distinto, é usar unicode:\nx \u0026lt;- \u0026quot;\\u00b5\u0026quot;\rx\r ## [1] \u0026quot;µ\u0026quot;\r Ok, mas e o pacote stringr? Bem, ele tem o intuito de facilitar e dar consistência, então, todas as funções do pacote começam com as iniciais str_ justamente para serem utilizadas com o autocompletar do RStudio, que pode ser acessada com os atalhos Ctrl + Espaço ou Tab. Vamos ver agora alguns exemplos de funções do pacote.\nComprimento da string em caracteres:\nlibrary(stringr)\r# No RStudio, basta digitar 'str_' e apertar Tab ou Ctrl + Espaço\rx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_length(x)\r ## [1] 17\r x \u0026lt;- c(\u0026quot;Ministro Sinistro\u0026quot;, \u0026quot;Abelha Gulosa\u0026quot;, \u0026quot;p\u0026quot;)\rstr_length(x)\r ## [1] 17 13 1\r Concatenação de strings:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;xyz\u0026quot;\r Use o argumento sep para definir caracteres que aparecerão entre as strings originais:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;, sep = \u0026quot; + \u0026quot;)\r ## [1] \u0026quot;x + y + z\u0026quot;\r Você pode trabalhar com strings que contém NAs:\nx \u0026lt;- c(\u0026quot;abc\u0026quot;, NA)\rstr_c(\u0026quot;|-\u0026quot;, x, \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; NA\r str_c(\u0026quot;|-\u0026quot;, str_replace_na(x), \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; \u0026quot;|-NA-|\u0026quot;\r str_c é uma função vetorizada e automaticamente recicla seus argumentos pra ter o tamanho do maior:\n# Eu na graduação\rstr_c(\u0026quot;Profe, me dá mais \u0026quot;, c(\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;), \u0026quot; semanas pra entregar, por favor!\u0026quot;)\r ## [1] \u0026quot;Profe, me dá mais 1 semanas pra entregar, por favor!\u0026quot;\r## [2] \u0026quot;Profe, me dá mais 2 semanas pra entregar, por favor!\u0026quot;\r## [3] \u0026quot;Profe, me dá mais 3 semanas pra entregar, por favor!\u0026quot;\r # Eu de manhã\rstr_c(\u0026quot;Só mais \u0026quot;, c(\u0026quot;5\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;30\u0026quot;), \u0026quot; minutinhos e eu acordo!\u0026quot;)\r ## [1] \u0026quot;Só mais 5 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 10 minutinhos e eu acordo!\u0026quot;\r## [3] \u0026quot;Só mais 20 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 30 minutinhos e eu acordo!\u0026quot;\r Se algum dos objetos passados para str_c tiver tamanho 0, ele é descartado. Útil para usar com testes lógicos.\nnome \u0026lt;- \u0026quot;Vinicius\u0026quot;\rsobrenome \u0026lt;- \u0026quot;Maia\u0026quot;\rtem_nome_do_meio \u0026lt;- FALSE\rstr_c(\r\u0026quot;Meu nome é \u0026quot;, nome, \u0026quot; \u0026quot;,\r# isso aqui retorna um vetor tamanho 0\rif (tem_nome_do_meio) \u0026quot; de Souza\u0026quot;, sobrenome,\r\u0026quot;.\u0026quot;\r)\r ## [1] \u0026quot;Meu nome é Vinicius Maia.\u0026quot;\r Conhecedores de paste reconhecerão o argumento collapse, que serve para transformar vetores de strings em uma única string.\nstr_c(c(\u0026quot;Natália\u0026quot;, \u0026quot;Martins\u0026quot;, \u0026quot;Arruda\u0026quot;), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;Natália Martins Arruda\u0026quot;\r De forma similar, conhecedores de substring deverão imediatamente reconhecer essa:\nx \u0026lt;- c(\u0026quot;Maçã\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Abacaxi\u0026quot;)\rstr_sub(x, 1, 3)\r ## [1] \u0026quot;Maç\u0026quot; \u0026quot;Ban\u0026quot; \u0026quot;Aba\u0026quot;\r str_sub(x, -3, -1)\r ## [1] \u0026quot;açã\u0026quot; \u0026quot;ana\u0026quot; \u0026quot;axi\u0026quot;\r str_sub não vai dar erro se a string for muito curta:\nstr_sub(\u0026quot;a\u0026quot;, 1, 5)\r ## [1] \u0026quot;a\u0026quot;\r Dá pra usar a forma str_sub(x) \u0026lt;- para modificar partes de strings\nstr_sub(x, 1, 1) \u0026lt;- str_to_lower(str_sub(x, 1, 1))\rx\r ## [1] \u0026quot;maçã\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;abacaxi\u0026quot;\r Note o uso de str_to_lower para mudar para minúsculas. O contrário é str_to_upper, também há uma para títulos, str_to_title, e para a primeira letra de uma frase, str_to_sentence.\nx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_to_lower(x)\r ## [1] \u0026quot;ministro sinistro\u0026quot;\r str_to_upper(x)\r ## [1] \u0026quot;MINISTRO SINISTRO\u0026quot;\r str_to_sentence(x)\r ## [1] \u0026quot;Ministro sinistro\u0026quot;\r str_to_title(x)\r ## [1] \u0026quot;Ministro Sinistro\u0026quot;\r Como vimos no readr, algumas questões relacionadas a strings dependem da língua, ou, na linguagem do pacote, são “locale dependent.” Por isso nas funções onde isso é relevante, o argumento se chama locale. Isso não é super relevante para quem trabalha com o inglês ou as línguas do oeste europeu, considerando que a maioria das línguas tem raízes similares, mas pode ser muito importante para outros idiomas. Vejamos este exemplo com a mudança da ordem das strings.\nx \u0026lt;- c(\u0026quot;abacaxi\u0026quot;, \u0026quot;escarola\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_sort(x, locale = \u0026quot;en\u0026quot;) # Inglês\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;escarola\u0026quot;\r str_sort(x, locale = \u0026quot;haw\u0026quot;) # Havaiano\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;escarola\u0026quot; \u0026quot;banana\u0026quot;\r É justamente para esses casos que str_sort e str_order oferecem a alternativa de você especificar o locale.\nTrabalhando com padrões e “expressões regulares” Expressões regulares são quase uma linguagem de programação em si, aqui, vamos dar uma passada muito rápida e ver alguns exemplos simples. São uma ferramenta muito útil, mas talvez não do interesse de todos.\nBasicamente, a ideia é fazer uma pesquisa na string, em busca de um padrão específico. Pode ser uma palavra, um espaço em branco, uma quebra de linha. Pode ficar muito complexo ou ser bem básico. O nosso objetivo aqui é que todos tenham a capacidade de trabalhar com padrões simples para corrigir inconsistências em bancos de dados, como no exemplo da aula anterior das colunas do dataset da OMS.\nPara visualizar padrões, vamos usar duas helper functions, str_view e str_view_all.\nx \u0026lt;- c(\u0026quot;mamão\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;ananas\u0026quot;)\rstr_view(x, \u0026quot;an\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rO resultado sai na aba “Viewer” do seu RStudio.\nO primeiro padrão que podemos usar é o ., que identifica qualquer caractere. As vezes na documentação esse tipo de padrão genérico é chamado de “wildcard.”\nstr_view(x, \u0026quot;.a.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rA forma de ler essa operação é: “Identifique qualquer conjunto de caracteres que tenha uma letra a no meio deles.”\nSe você quiser identificar um . numa string, você precisa usar o escape \\. Porém, a barra também é um escape! Então, ao escrever expressões regulares, precisamos usar \\\\. Veja:\ndot \u0026lt;- \u0026quot;.\u0026quot;\rcat(dot)\r ## .\r # erro\rdot \u0026lt;- \u0026quot;\\.\u0026quot;\r ## Error: '\\.' é uma seqüência de escape não reconhecida na cadeia de caracteres começando com \u0026quot;\u0026quot;\\.\u0026quot;\r # agora sim\rdot \u0026lt;- \u0026quot;\\\\.\u0026quot;\rcat(dot)\r ## \\.\r Agora em um exemplo:\nx \u0026lt;- c(\u0026quot;Praia.\u0026quot;, \u0026quot;Agora.\u0026quot;, \u0026quot;Ou.\u0026quot;, \u0026quot;Me.\u0026quot;, \u0026quot;Rebelo.\u0026quot;)\rstr_view(x, \u0026quot;a\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;u\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;o\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rTá, mas se a contrabarra é utilizada para denotar uma expressão regular tipo o ., como eu faço para pesquisar uma contrabarra?\nx \u0026lt;- \u0026quot;Jake Peralta é o melhor detetive\\\\gênio\u0026quot;\rcat(x)\r ## Jake Peralta é o melhor detetive\\gênio\r A solução é escapar o escape do escape, sacou?\nstr_view(x, \u0026quot;\\\\\\\\\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Jake Peralta é o melhor detetive\\\\gênio\\n\"},\"evals\":[],\"jsHooks\":[]}\rÉ enrolado mesmo…\nPara não estender muito o assunto, vamos ver vários exemplos de caracteres especiais a ser usados em expressões regulares.\n^ encontra o início de uma string\nx \u0026lt;- c(\u0026quot;maçã\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;mamão\u0026quot;)\rstr_view(x, \u0026quot;^m\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\r$ encontra o final\nstr_view(x, \u0026quot;a$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\rPara forçar a expressão a achar apenas a palavra completa, use os dois\nx \u0026lt;- c(\u0026quot;vitamina de banana\u0026quot;, \u0026quot;sundae de banana\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_view(x, \u0026quot;banana\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;^banana$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rUse classes de caracteres para encontrar genéricos\nQualquer digito:\nx \u0026lt;- \u0026quot;15 de Maio de 2021.\u0026quot;\rstr_view(x, \u0026quot;\\\\d\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer espaço em branco:\nstr_view(x, \u0026quot;\\\\s\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere de um grupo: [abc]\nstr_view(x, \u0026quot;[M]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[eM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[deM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere menos esses: [^abc]\nstr_view(x, \u0026quot;[^15]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de Maio de ]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rUsar uma classe pra evitar digitar 5 milhões de contrabarras\nstr_view(x, \u0026quot;[.]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(\u0026quot;a*c\u0026quot;, \u0026quot;[*]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n a*c\\n\"},\"evals\":[],\"jsHooks\":[]}\rVocê pode misturar strings com classes também\nx \u0026lt;- c(\u0026quot;15 de Maio de 2021.\u0026quot;, \u0026quot;16 de Maio de 2021.\u0026quot;)\rstr_view(x, \u0026quot;1[56] de Maio\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n 16 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rInfelizmente, alguns caracteres tem significado especial dentro das classes, e você tem que usar contrabarras para fugir deles: ] \\ ^ e -.\nVocê pode lidar com repetições\nx \u0026lt;- c(\u0026quot;Mariele\u0026quot;, \u0026quot;Marielle\u0026quot;, \u0026quot;Mariellle\u0026quot;, \u0026quot;Marie\u0026quot;)\rstr_view(x, \u0026quot;Mariell?e\u0026quot;) # l aparece 0 ou 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel+e\u0026quot;) # l aparece 1 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel*\u0026quot;) # l aparece 0 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{0}\u0026quot;) # l aparece exatamente 0 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1}\u0026quot;) # l aparece exatamente 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2}\u0026quot;) # l aparece exatamente 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{3}\u0026quot;) # l aparece exatamente 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,}\u0026quot;) # l aparece exatamente 1 vez ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,}\u0026quot;) # l aparece exatamente 2 vezes ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,2}\u0026quot;) # l aparece de 1 a 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,3}\u0026quot;) # l aparece de 2 a 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rEsse assunto é enorme, e ainda estamos só na superfície. Há grupos, lookarounds, e muitos outros detalhes envolvendo expressões regulares, e vocês podem consultar os livros de referência para mergulhar mais fundo. Mas vamos parar por aqui para nos concentrar no que interessa.\nEm geral, temos um banco de dados com strings problemáticas, tipo erros de digitação, inconsistências etc. O primeiro passo, em geral, é detectar os problemas.\nx \u0026lt;- c(\u0026quot;São Paulo\u0026quot;, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;Sao Paulo\u0026quot;, \u0026quot;sp\u0026quot;, \u0026quot;SP\u0026quot;, \u0026quot;Sp\u0026quot;)\rstr_detect(x, \u0026quot;ã\u0026quot;)\r ## [1] TRUE FALSE FALSE FALSE FALSE FALSE\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] FALSE FALSE FALSE TRUE TRUE TRUE\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;)\r ## [1] FALSE TRUE TRUE FALSE FALSE FALSE\r Você pode se utilizar do fato da resposta ser um vetor lógico para descobrir quantos problemas você tem\n# Contagens\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% sum()\r ## [1] 1\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% sum()\r ## [1] 3\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% sum()\r ## [1] 2\r # Proporções\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.1666667\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.5\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.3333333\r Depois de detectar seus problemas, você pode querer extrair uma parte dos seus casos: use str_subset\nstr_subset(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Em geral, no entanto, você vai estar trabalhando num data frame. Então use dplyr::filter e str_detect.\ndf \u0026lt;- tibble::tibble(\rnome = c(\u0026quot;Marcos\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;cebolinha\u0026quot;, \u0026quot;Beiçola\u0026quot;, \u0026quot;nadir\u0026quot;, \u0026quot;Monica\u0026quot;),\ruf = x,\rdtnsc = c(\u0026quot;15 de Maio de 1980\u0026quot;, \u0026quot;1 de Jan de 2001\u0026quot;, \u0026quot;6 de Ago de 1993\u0026quot;, \u0026quot;20 de Abril de 1964\u0026quot;, \u0026quot;24 de Nov de 1975\u0026quot;, \u0026quot;14 de Dezembro de 1997\u0026quot;)\r)\rdf %\u0026gt;% dplyr::filter(str_detect(uf, \u0026quot;[Ss][Pp]\u0026quot;))\r ## # A tibble: 3 x 3\r## nome uf dtnsc ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Beiçola sp 20 de Abril de 1964 ## 2 nadir SP 24 de Nov de 1975 ## 3 Monica Sp 14 de Dezembro de 1997\r Você pode contar quantos matches você tem str_count\nstr_count(x, \u0026quot;o\u0026quot;)\r ## [1] 2 0 2 0 0 0\r str_count(x, \u0026quot;[Oo]\u0026quot;)\r ## [1] 2 2 2 0 0 0\r # e usar num data frame\rdf %\u0026gt;% dplyr::mutate(vogais = str_count(uf, \u0026quot;[aeiou]\u0026quot;),\rconsoantes = str_count(uf, \u0026quot;[^aeiou]\u0026quot;))\r ## # A tibble: 6 x 5\r## nome uf dtnsc vogais consoantes\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 4 5\r## 2 rogério SAO PAULO 1 de Jan de 2001 0 9\r## 3 cebolinha Sao Paulo 6 de Ago de 1993 5 4\r## 4 Beiçola sp 20 de Abril de 1964 0 2\r## 5 nadir SP 24 de Nov de 1975 0 2\r## 6 Monica Sp 14 de Dezembro de 1997 0 2\r Você pode extrair str_extract as informações que você quer\nstr_extract(df$dtnsc, \u0026quot;\\\\d+\u0026quot;)\r ## [1] \u0026quot;15\u0026quot; \u0026quot;1\u0026quot; \u0026quot;6\u0026quot; \u0026quot;20\u0026quot; \u0026quot;24\u0026quot; \u0026quot;14\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\d+$\u0026quot;)\r ## [1] \u0026quot;1980\u0026quot; \u0026quot;2001\u0026quot; \u0026quot;1993\u0026quot; \u0026quot;1964\u0026quot; \u0026quot;1975\u0026quot; \u0026quot;1997\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;)\r ## [1] \u0026quot; de Maio de \u0026quot; \u0026quot; de Jan de \u0026quot; \u0026quot; de Ago de \u0026quot; \u0026quot; de Abril de \u0026quot; ## [5] \u0026quot; de Nov de \u0026quot; \u0026quot; de Dezembro de \u0026quot;\r # Na tibble\rdf %\u0026gt;% dplyr::mutate(\rdia = str_extract(dtnsc, \u0026quot;\\\\d+\u0026quot;),\rmes = str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;),\rano = str_extract(dtnsc, \u0026quot;\\\\d+$\u0026quot;))\r ## # A tibble: 6 x 6\r## nome uf dtnsc dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 15 \u0026quot; de Maio de \u0026quot; 1980 ## 2 rogério SAO PAULO 1 de Jan de 2001 1 \u0026quot; de Jan de \u0026quot; 2001 ## 3 cebolinha Sao Paulo 6 de Ago de 1993 6 \u0026quot; de Ago de \u0026quot; 1993 ## 4 Beiçola sp 20 de Abril de 1964 20 \u0026quot; de Abril de \u0026quot; 1964 ## 5 nadir SP 24 de Nov de 1975 24 \u0026quot; de Nov de \u0026quot; 1975 ## 6 Monica Sp 14 de Dezembro de 1997 14 \u0026quot; de Dezembro de \u0026quot; 1997\r # Melhor ainda\rdf %\u0026gt;% tidyr::extract(\rdtnsc, c(\u0026quot;dia\u0026quot;, \u0026quot;mes\u0026quot;, \u0026quot;ano\u0026quot;), regex = \u0026quot;(\\\\d+) de (\\\\D+) de (\\\\d+$)\u0026quot;\r)\r ## # A tibble: 6 x 5\r## nome uf dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 Maio 1980 ## 2 rogério SAO PAULO 1 Jan 2001 ## 3 cebolinha Sao Paulo 6 Ago 1993 ## 4 Beiçola sp 20 Abril 1964 ## 5 nadir SP 24 Nov 1975 ## 6 Monica Sp 14 Dezembro 1997\r Similar a ideia de extração, podemos substituir com str_replace\nstr_replace(x, \u0026quot;[Ss][Pp]\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot;\r str_replace(x, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r str_replace(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Tanto str_extract quanto str_replace substituem apenas a primeira marca, se você quiser substituir todas, utilize str_..._all\nstr_extract_all(x, \u0026quot;a\u0026quot;, simplify = TRUE)\r ## [,1] [,2]\r## [1,] \u0026quot;a\u0026quot; \u0026quot;\u0026quot; ## [2,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [3,] \u0026quot;a\u0026quot; \u0026quot;a\u0026quot; ## [4,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [5,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [6,] \u0026quot;\u0026quot; \u0026quot;\u0026quot;\r str_replace_all(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Pãulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r O assunto não acaba, mas vamos parar por aqui. Novamente, recomendo consultarem os materiais para quem quiser ir mais a fundo nisso. É bem capaz de no andar da carruagem aparecerem outros exemplos nos quais a manipulação de strings pode ser importante.\nforcats Esse é um pacotinho muito que facilita bastante a vida de quem trabalha com variável categórica, ou, no R, os factors. Ele consiste em uma série de “helper functions” baseadas em funções do base e do stats que trabalham com os componentes de um factor, ou seja, seus levels e seus values.\nImagino que todos aqui estão familiarizados com fatores e com a sua criação, então vamos direto ao que interessa. Educação é um vetor de caracteres que vem com os níveis educacionais de um população.\neducacao \u0026lt;- c(\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;,\r\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;)\rx \u0026lt;- factor(educacao, levels = c(\u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;))\rx\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Fundamental Médio Superior\r levels(x)\r ## [1] \u0026quot;Fundamental\u0026quot; \u0026quot;Médio\u0026quot; \u0026quot;Superior\u0026quot;\r relevel(x, \u0026quot;Superior\u0026quot;)\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Superior Fundamental Médio\r Em geral, diversas tarefas envolvendo fatores no base não são muito simples. Por exemplo, se eu quiser modificar os nomes dos níveis de um fator depois dele já estar criado, modificar a ordem dos níveis, ou agrupar diversos níveis em um só. forcats vem justamente oferecer soluções nesse sentido. Normalmente, estamos trabalhando com bancos de dados, e não com um vetor solitário, por isso, vamos usar o gss_cat, uma amostra do General Social Survey aplicado pelo NORC e pela Universidade de Chicago, que vem no pacote forcats.\nlibrary(forcats)\rgss_cat\r ## # A tibble: 21,483 x 9\r## year marital age race rincome partyid relig denom tvhours\r## \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 2000 Never ma~ 26 White $8000 to ~ Ind,near r~ Protesta~ Souther~ 12\r## 2 2000 Divorced 48 White $8000 to ~ Not str re~ Protesta~ Baptist~ NA\r## 3 2000 Widowed 67 White Not appli~ Independent Protesta~ No deno~ 2\r## 4 2000 Never ma~ 39 White Not appli~ Ind,near r~ Orthodox~ Not app~ 4\r## 5 2000 Divorced 25 White Not appli~ Not str de~ None Not app~ 1\r## 6 2000 Married 25 White $20000 - ~ Strong dem~ Protesta~ Souther~ NA\r## 7 2000 Never ma~ 36 White $25000 or~ Not str re~ Christian Not app~ 3\r## 8 2000 Divorced 44 White $7000 to ~ Ind,near d~ Protesta~ Luthera~ NA\r## 9 2000 Married 44 White $25000 or~ Not str de~ Protesta~ Other 0\r## 10 2000 Married 47 White $25000 or~ Strong rep~ Protesta~ Souther~ 3\r## # ... with 21,473 more rows\r Contagens\nUma das primeiras coisas que interessa ao lidar com fatores, é obter suas contagens, o que é algo muito simples utilizando a gramática do dplyr.\n# Função count\rgss_cat %\u0026gt;% count(race)\r ## # A tibble: 3 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% count(race, .drop = FALSE)\r ## # A tibble: 4 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r## 4 Not applicable 0\r # Visualização com ggplot\rlibrary(ggplot2)\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar()\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar() + scale_x_discrete(drop = FALSE)\r Note o uso do argumento drop nos dois casos, para indicar que casos com 0 observações não devem ser removidos do resultado.\nModificando a ordem A segunda tarefa comum quando trabalhamos com fatores é modificar a ordem em que eles aparecem. Não é tanto o caso quando trabalhamos com fatores ordenados, mas diversos tipos de variáveis categóricas não possuem uma ordem lógica pre-definida e, mesmo assim, nos interessa apresentá-los de acordo com uma determinada hierarquia visual, seja porque eles são os mais frequentes ou porque queremos destacar algum elemento em particular. forcats implementa diversas estratégias de reordenamento de fatores. Vamos vê-las brevemente.\nDigamos que eu queira saber o tempo médio de televisão assistida por membros das diversas religiões. Eu poderia produzir um sumário e depois plotar isso num gráfico.\nrelig_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(relig) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r O display está técnicamente correto, mas a forma desorganizada dos níveis no eixo Y dificulta a nossa capacidade de fazer comparações. Talvez fosse mais interessante ordenar este resultado por ordem decrescente do número de horas de tv. Mas, como fazer isso de forma direta, sem precisar realizar diversas computações?\n# Direto no plot\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, fct_reorder(relig, tvhours))) + geom_point()\r # Antes de passar o data.frame para a plotagem\rrelig_summary %\u0026gt;% mutate(relig = fct_reorder(relig, tvhours)) %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r Note como posso aplicar a transformação diretamente na variável durante o processo de plotagem, ou antes, e uma invocação de mutate. Na minha opinião, o segundo jeito é o mais adequado, por duas razões: é mais fácil de digitar, inserir e retirar do código e é mais fácil para um leitor identificar que uma transformação foi feita na variável plotada.\nOutro exemplo: que tal exarminarmos a relação entre a idade e a renda declarada? Primeiro, é preciso construir um sumário, parecido com o primeiro:\nrincome_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(rincome) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrincome_summary %\u0026gt;% mutate(rincome = fct_reorder(rincome, age)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Aqui, o reordenamento das variáveis de acordo com a idade não faz muito sentido, porque os níveis de renda tem uma ordem própria. Nesse caso, não é recomendado utilizar fct_reorder.\nrincome_summary %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Só que ao plotar, notamos um problema: a categoria “Not applicable” ficou primeiro e isso desorganiza visualmente nosso gráfico. Sem problema! Utilizamos fct_relevel para modificar a ordem de uma variável arbitrariamente. O padrão é colocar pro começo (Parecido com o comportamento de stats::relevel), mas você pode especificar outra posição.\nrincome_summary %\u0026gt;% mutate(rincome = fct_relevel(rincome, \u0026quot;Not applicable\u0026quot;)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Notem como nos exemplos acima, o uso do %\u0026gt;% nos permite alterar partes do nosso código de maneira interativa para chegar no resultado desejado.\nOutro tipo de mudança de ordem interessante ocorre quando temos uma terceira “dimensão” no nosso gráfico. Em geral, utilizamos cores, formas ou linhas quebradas para diferenciar entre categorias e gostaríamos que a nossa legenda acompanhasse a tendência do gráfico. Compare:\nby_age \u0026lt;- gss_cat %\u0026gt;%\rfilter(!is.na(age)) %\u0026gt;%\rcount(age, marital) %\u0026gt;%\rgroup_by(age) %\u0026gt;%\rmutate(prop = n / sum(n))\r# Sem alteração na ordem\rby_age %\u0026gt;% ggplot(aes(age, prop, colour = marital)) +\rgeom_line(na.rm = TRUE)\r # Com alteração na ordem\rggplot(by_age, aes(age, prop, colour = fct_reorder2(marital, age, prop))) +\rgeom_line() +\rlabs(colour = \u0026quot;marital\u0026quot;)\r No caso de fct_reorder2, é melhor fazer a alteração de ordem dentro da função gráfica, pois dentro uma invocação de mutate, ela não funcionou durante meus testes.\nPor último, podemos querer ordenar um gráfico de barras de acordo com a frequência das categorias, o que podemos fazer com fct_infreq e fct_rev (opcional).\ngss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r # OU\rgss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq() %\u0026gt;% fct_rev()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r Notem o uso do pipe na hora de modificar a variável “marital.”\nModificando os níveis O outro tipo de operação bastante comum é a alteração nos níves do fator. Em geral, queremos que os nossos níveis sejam representativos das nossas categorias de análise, sejam de fácil leitura e entendimento e contenham um número significativo de observações. Por essa razão, frequentemente precisamos alterar os rótulos, agrupar categorias, etc.\nVejamos o exemplo da variável partyid, que registra a identificação do entrevistado com os partidos políticos dos EUA.\ngss_cat %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 154\r## 2 Don't know 1\r## 3 Other party 393\r## 4 Strong republican 2314\r## 5 Not str republican 3032\r## 6 Ind,near rep 1791\r## 7 Independent 4119\r## 8 Ind,near dem 2499\r## 9 Not str democrat 3690\r## 10 Strong democrat 3490\r Vamos supor que, por qualquer motivo, essa forma de representação das categorias não nos satisfaz. Vejamos algumas das ferramentas que podemos utilizar para modificar esse fator.\nPodemos, simplesmente, reescrever essas categorias de forma mais completa:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r\u0026quot;Outro partido\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Não sei\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Sem resposta\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Sem resposta 154\r## 2 Não sei 1\r## 3 Outro partido 393\r## 4 Republicano, forte 2314\r## 5 Republicano, fraco 3032\r## 6 Independente, próx. repub. 1791\r## 7 Independente 4119\r## 8 Independente, próx. democ. 2499\r## 9 Democrata, fraco 3690\r## 10 Democrata, forte 3490\r A função utilizada é fct_recode e ela é a mais genérica e flexível de todas, porém, exige que cada nível seja modificado individualmente. Dentro dela, é possível agrupar vários níveis associando vários níveis antigos a um mesmo nível novo. Veja o exemplo:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r# Note o nome\r\u0026quot;Outro\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 8 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano, forte 2314\r## 3 Republicano, fraco 3032\r## 4 Independente, próx. repub. 1791\r## 5 Independente 4119\r## 6 Independente, próx. democ. 2499\r## 7 Democrata, fraco 3690\r## 8 Democrata, forte 3490\r Se você quiser recategorizar um fator que tem muitos níveis para um menor, com poucos níveis, utilize fct_collapse:\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\rOutro = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\rRepublicano = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\rIndependente = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\rDemocrata = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Repare que do lado esquerdo, nos valores novos, não foi necessário usar aspas. É preciso cuidado com essa característica dos verbos do tidyverse. Ela se chama “tidy evaluation” e está um pouco fora do escopo do curso. Basicamente, se rolar dúvida ou der erros, se for usar acentos ou algum caractere diferente, use aspas.\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\r\u0026quot;Outro\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\r\u0026quot;Republicano\u0026quot; = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\r\u0026quot;Independente\u0026quot; = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\r\u0026quot;Democrata\u0026quot; = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Outro tipo de mudança importante no número de níveis é agrupar os níveis menos frequentes, por exemplo, para produzir uma visualização que dê maior destaque aos níveis mais frequentes. Esse é o trabalho de fct_lump.\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Other 913\r Note que usando o argumento n eu indico quantos níveis eu quero. No caso, escolhi os 5 níveis mais frequentes e todos os outros são automáticamente agrupados na categoria “Other.” Posso mudar esse nome também:\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5, other_level = \u0026quot;Outros\u0026quot;)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Outros 913\r Exercícios   Encontre os vôos que:\n Atrasaram mais de duas horas Com destino a Houston (IAH ou HOU) Operados pela United, American ou Delta Decolaram entre julho e setembro Chegaram com mais de duas horas de atraso, mas não decolaram com atraso Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo Decolaram entre a meia-noite e 6 da manhã (inclusive)    Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).\n  Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.\n  As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.\n  O que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?\n  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: “150,” “219,” “312,” “471.” Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;115\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;118\u0026quot; \u0026quot;116\u0026quot; \u0026quot;100\u0026quot; \u0026quot;108\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;103\u0026quot;\r## [13] \u0026quot;116\u0026quot; \u0026quot;111\u0026quot; \u0026quot;111\u0026quot; \u0026quot;115\u0026quot; \u0026quot;114\u0026quot; \u0026quot;102\u0026quot; \u0026quot;116\u0026quot; \u0026quot;103\u0026quot; \u0026quot;120\u0026quot; \u0026quot;115\u0026quot; \u0026quot;123\u0026quot; \u0026quot;103\u0026quot;\r## [25] \u0026quot;119\u0026quot; \u0026quot;230\u0026quot; \u0026quot;228\u0026quot; \u0026quot;225\u0026quot; \u0026quot;214\u0026quot; \u0026quot;225\u0026quot; \u0026quot;206\u0026quot; \u0026quot;207\u0026quot; \u0026quot;208\u0026quot; \u0026quot;202\u0026quot; \u0026quot;210\u0026quot; \u0026quot;229\u0026quot;\r## [37] \u0026quot;204\u0026quot; \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;218\u0026quot; \u0026quot;223\u0026quot; \u0026quot;221\u0026quot; \u0026quot;205\u0026quot; \u0026quot;214\u0026quot; \u0026quot;220\u0026quot; \u0026quot;227\u0026quot; \u0026quot;202\u0026quot; \u0026quot;224\u0026quot;\r## [49] \u0026quot;214\u0026quot; \u0026quot;201\u0026quot; \u0026quot;305\u0026quot; \u0026quot;310\u0026quot; \u0026quot;309\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;303\u0026quot; \u0026quot;312\u0026quot; \u0026quot;310\u0026quot;\r## [61] \u0026quot;303\u0026quot; \u0026quot;302\u0026quot; \u0026quot;305\u0026quot; \u0026quot;303\u0026quot; \u0026quot;304\u0026quot; \u0026quot;306\u0026quot; \u0026quot;309\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;309\u0026quot; \u0026quot;306\u0026quot; \u0026quot;311\u0026quot;\r## [73] \u0026quot;306\u0026quot; \u0026quot;307\u0026quot; \u0026quot;310\u0026quot; \u0026quot;417\u0026quot; \u0026quot;477\u0026quot; \u0026quot;470\u0026quot; \u0026quot;493\u0026quot; \u0026quot;414\u0026quot; \u0026quot;446\u0026quot; \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;476\u0026quot;\r## [85] \u0026quot;432\u0026quot; \u0026quot;490\u0026quot; \u0026quot;499\u0026quot; \u0026quot;429\u0026quot; \u0026quot;414\u0026quot; \u0026quot;455\u0026quot; \u0026quot;409\u0026quot; \u0026quot;462\u0026quot; \u0026quot;447\u0026quot; \u0026quot;483\u0026quot; \u0026quot;458\u0026quot; \u0026quot;471\u0026quot;\r## [97] \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;464\u0026quot; \u0026quot;483\u0026quot;\r  Explore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?\n  Qual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?\n  A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?\n  Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?\n  ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"fa0304036676bc16efc6e61759597fd7","permalink":"https://laddem.github.io/courses/tidyverse/dia2/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia2/","section":"courses","summary":"Operações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.","tags":null,"title":"stringr, forcats e dplyr","type":"book"},{"authors":null,"categories":null,"content":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.frame e o código utilizado para gerar o gráfico. Acho que se o termo sobrecarga infromacional não existisse, eu teria inventado ele na hora.\nAnedotas a parte, não é culpa do autor. O livro pressupõe um certo conhecimento prévio que eu não tinha quando o li pela primeira vez. Imagino que a maioria de vocês já viu gráficos na vida e até construiu um ou dois deles usando esse ou outros softwares estatísticos. O que talvez nem todos tenham claro na mente é que os gráficos são uma codificação num sistema de coordenadas das informações presentes em um banco de dados através de escalas. Vamos destrinchar um pouco melhor isso:\nSuponha que você tenha o banco de dados mpg, presente na biblioteca ggplot2.\nlibrary(ggplot2)\rmpg\r ## # A tibble: 234 x 11\r## manufacturer model displ year cyl trans drv cty hwy fl class\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 audi a4 1.8 1999 4 auto(l~ f 18 29 p comp~\r## 2 audi a4 1.8 1999 4 manual~ f 21 29 p comp~\r## 3 audi a4 2 2008 4 manual~ f 20 31 p comp~\r## 4 audi a4 2 2008 4 auto(a~ f 21 30 p comp~\r## 5 audi a4 2.8 1999 6 auto(l~ f 16 26 p comp~\r## 6 audi a4 2.8 1999 6 manual~ f 18 26 p comp~\r## 7 audi a4 3.1 2008 6 auto(a~ f 18 27 p comp~\r## 8 audi a4 quat~ 1.8 1999 4 manual~ 4 18 26 p comp~\r## 9 audi a4 quat~ 1.8 1999 4 auto(l~ 4 16 25 p comp~\r## 10 audi a4 quat~ 2 2008 4 manual~ 4 20 28 p comp~\r## # ... with 224 more rows\r De posse desse banco, você gostaria de construir um gráfico relacionando a eficiência do combustível de um carro (hwy) com o seu peso (displ). Sábio e malandro no ggplot2, você escreve o código a seguir:\nggplot(mpg, aes(displ,hwy, color = class)) +\rgeom_point()\r Mas fica a dúvida: que escolhas foram feitas no momento de traduzir a minha intenção de produzir um diagrama de dispersão (scatterplot) do peso com o consumo de gasolina para a representação gráfica diante de nós? Que unidades de medidas estão dispostas nos eixos X e Y? Qual o sistema de coordenadas no qual isto foi representado? Quem define os limites de início e fim de cada eixo? Como cada ponto recebeu a sua cor? Essas perguntas podem parecer óbvias ou tontas, dependendo da perspectiva e da experiência do usuário, mas elas são centrais para entender como construir e modificar gráficos no ggplot2.\nO pacote é inspirado pela Gramática dos Gráficos, e procura decompor o processo de produção de gráficos em uma sequência de camadas que vão se sobrepondo até chegar no objeto desejado.\n a camada dos dados e do mapeamento estético (que variáveis vão em quais eixos/escalas) a camada dos objetos geométricos (pontos, linhas, barras, etc.) a camada das escalas (natural? logarítmica? escala de cores?) a camada das facetas (mini gráficos separados por alguma característica) a camada das transformações estatísticas (distribuições de probabilidade, contagens, proporções, etc.) o sistema de coordenadas (cartesiano? polar?)  Obviamente, nem todo gráfico possui essa complexidade, e na verdade, a maioria dos gráficos que fazemos se encaixa num pequeno subgrupo de todas essas especificações, então porque toda essa complexidade?\nPorque não? Em primeiro lugar, se você está produzindo visualizações simples que cumprem seu propósito, você não precisa se preocupar com quase nada disso, os padrões do ggplot2, via de regra, se encaixam perfeitamente na maioria dos problemas e, em segundo lugar, se você sentir a necessidade de ir mais fundo e produzir visualizações mais complexas, as mesmas ferramentas que você já conhece estão a sua disposição.\nTrês gráficos para entender a mecânica do ggplot2 Scatterplots Voltemos para o nosso gráfico original, vamos decompô-lo em suas camadas como se estivéssemos construindo ele passo-a-passo:\n# Primeiro, a camada dos dados e mapeamentos estéticos\rggplot(\r# Dados\rdata = mpg,\r# Que variável vai em que eixo\rmapping = aes(x = displ, y = hwy)\r)\r Examinando a saída, vemos que ggplot desenhou um canvas com nossas variáveis, mas ainda nenhum objeto geométrico. Tudo bem, adicionamos (+) uma camada de objetos geométricos, no caso, pontos.\n# Objetos geométricos começam com \u0026quot;geom_\u0026quot;\rggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + # adicionamos\rgeom_point()\r Agora, nosso gráfico já tem uma cara de diagrama de dispersão. Mas ainda não tem as cores das classes de automóvel. Tudo bem, voltamos para a primeira camada e informamos que queremos um terceiro mapeamento estético.\n# A cor é mapeada a variável class\rggplot(data = mpg, mapping = aes(\rx = displ, y = hwy,\rcolor = class) # novo mapeamento estético\r) + # adicionamos\rgeom_point()\r Ok, chegamos no gráfico original. Mas como podem entender melhor as outras camadas? Vamos pensar, por exemplo, que talvez queiramos trabalhar a variável hwy numa escala logarítmica. Poderíamos transformar a variável original, claro, mas o ggplot2 nos permite especificar as transformações diretamente nas escalas do gráfico!\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() + # adicionando uma nova \u0026quot;camada\u0026quot;\rscale_y_continuous(trans = \u0026quot;log\u0026quot;)\r Mas você, leitor, não ficou satisfeito. Você queria era transformar a variável displ em raíz quadrada. Tudo bem:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;) # especificamos a transformação na escala de x\r Outro leitor não estava interessado nas escalas dos eixos x ou y, que são contínuas nesse caso, mas sim na seleção de cores utilizadas para representar a escala das cores. Por ser um leitor conhecedor das formas de deficiência visual cromática, ele optou pelas paletas de cores do Colorbrewer:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) # transformação da escala de cores\r Um geógrafo entrou na conversa e disse que o sistema cartesiano de coordenadas estava iludindo os leitores a pensar que a relação entre peso e consumo de combustível estava distorcida pelas diferenças entre as unidades de medida das variáveis, produzida pelo sistema cartesiano de coordenadas, então ele sugeriu que usássemos um sistema de coordenadas fixas:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) +\rcoord_fixed()\r Ficou horrível, esse geógrafo não sabe nada. Como recompensa pela sua ignorância, agora ele ocupa um cargo no primeiro escalão do Ministério da Saúde.\nOutro pesquisador estava interessado em visualizar as relações entre consumo, peso e classe, mas levando em consideração o fabricante do veículo, então, ele sugeriu que construíssemos um gráfico para cada. Você, que é preguiçoso, usou a capacidade do ggplot2 de dividir gráficos através da introdução de uma camada de facets.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + # adicionamos mais uma camada\rfacet_wrap(~manufacturer) # de facetas\r Agora, muito satisfeitos com o resultado do nosso trabalho, resolvemos incluir o gráfico numa publicação, mas do jeito que está, não dá. Então adicionamos mais algumas camadas para torná-lo apresentável.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + facet_wrap(~manufacturer) +\r# Colocamos os nomes nos eixos\rlabs(title = \u0026quot;Relação entre peso e economia de combustível de automóveis\u0026quot;,\rsubtitle = \u0026quot;Separado por categoria e fabricante\u0026quot;,\rx = \u0026quot;Peso do veículo em toneladas\u0026quot;,\ry = \u0026quot;Consumo em milhas por galão de 3,5l\u0026quot;,\rcolor = \u0026quot;Categoria\u0026quot;,\rcaption = \u0026quot;Fonte: Agência de Proteção Ambiental Estadunidense.\u0026quot;) +\r# Escolhemos um tema bonito\rtheme_light() +\r# Mudamos a posição da legenda, pra ficar mais jeitozinho\rtheme(legend.position = \u0026quot;bottom\u0026quot;)\r Pronto. Mamãe vai ficar orgulhosa.\nBrincadeiras a parte, entendendo um pouco melhor a gramática do gráfico, podemos construir nossas visualizações passo a passo, até chegar no resultado desejado.\nLineplots O segundo exemplo que quero mostrar pra vocês é a construção de gráficos com linhas. Eles são interessantes porque dão bastante dor de cabeça pra quem está começando. Vamos continuar brincando com o mpg.\nAgora que eu fiz meu diagrama de dispersão, estou interessado em começar um processo de modelagem, mas primeiro quero ter uma noção visual da relação entre as variáveis.\nggplot(mpg, aes(displ, hwy)) +\rgeom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r geom_smooth ajusta um modelo aos dados e desenha a linha com os valores preditos. Agora que temos dois objetos geométricos, talvez seja interessante ver o que acontece se eu colocar as cores das classes.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Veja que ele fez o possível para aplicar as escalas nos dois objetos geométricos. Eu pedi para geom_smooth tirar os intervalos de confiança para melhorar a visibilidade. Mas e seu eu quisesse ver a cor dos pontos, mas manter a linha de tendência geral? Você pode especificar mapeamentos estéticos gerais (na primeira camada) ou mapeamentos estéticos locais (dentro de cada camada geométrica).\nggplot(mpg, aes(displ, hwy)) + # mapeamentos gerais, se aplicam a todos os objetos\rgeom_point(aes(color = class)) + # mapeamento local, só se aplica aqui\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Ok, mas e se eu quisesse um modelo linear ao invés de um \u0026ldquo;Smoother de Loess\u0026rdquo;?\nggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Não vou entrar muito nos argumentos de cada objeto geométrico e função, vocês podem aprender isso na prática olhando a documentação das funções que são do interesse de vocês. ?geom_smooth para ver todas as possibilidades. Uma dica boa é usar geom_smooth para verificar interações entre variáveis numéricas e fatores.\nggplot(mpg, aes(displ, hwy, color = factor(cyl))) + geom_point() +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Ok, mas e se temos um gráfico de linhas mais tradicional, tipo uma série histórica?\neconomics\r ## # A tibble: 574 x 6\r## date pce pop psavert uempmed unemploy\r## \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 507. 198712 12.6 4.5 2944\r## 2 1967-08-01 510. 198911 12.6 4.7 2945\r## 3 1967-09-01 516. 199113 11.9 4.6 2958\r## 4 1967-10-01 512. 199311 12.9 4.9 3143\r## 5 1967-11-01 517. 199498 12.8 4.7 3066\r## 6 1967-12-01 525. 199657 11.8 4.8 3018\r## 7 1968-01-01 531. 199808 11.7 5.1 2878\r## 8 1968-02-01 534. 199920 12.3 4.5 3001\r## 9 1968-03-01 544. 200056 11.7 4.1 2877\r## 10 1968-04-01 544 200208 12.3 4.6 2709\r## # ... with 564 more rows\r Podemos criar um gráfico de linhas tendo como base a data (date) e alguma das variáveis registradas, como a taxa de desemprego.\nggplot(economics, aes(x = date, y = uempmed)) +\rgeom_line()\r Ou o consumo em bilhões de dólares\nggplot(economics, aes(x = date, y = pce)) +\rgeom_line()\r Ou a população\nggplot(economics, aes(x = date, y = pop)) +\rgeom_line()\r Ok, mas eu quero comparar visualmente o que ocorre com uma variável quando a outra muda. Podemos recorrer ao que aprendemos sobre mapeamentos estéticos globais e locais.\nggplot(economics, aes(x = date)) +\rgeom_line(aes(y = uempmed)) +\rgeom_line(aes(y = pce)) +\rgeom_line(aes(y = pop))\r Ficou meio ruim, porque as variável tem grandezas distintas. Podemos tentar resolver esse problema aplicando transformações na variável idade, mas meio que pra qualquer lugar onde caminhos, batemos numa parede ou noutra. Esse tipo de solução é muito frequente entre pessoas que vem do base pro ggplot2, porque no base estamos acostumado a ideia de adicionar mais objetos geométricos ao nosso gráfico original adicionando invocações à funções como lines ou text. Porém, a solução preferida no tidyverse é aplicar uma transformação no banco original de tal forma que as nossas variáveis numéricas caiam todas num par que especifica o nome da variável | e o valor dela.\nlibrary(tidyr)\reconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;)\r ## # A tibble: 2,870 x 3\r## date variavel valor\r## \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 pce 507. ## 2 1967-07-01 pop 198712 ## 3 1967-07-01 psavert 12.6\r## 4 1967-07-01 uempmed 4.5\r## 5 1967-07-01 unemploy 2944 ## 6 1967-08-01 pce 510. ## 7 1967-08-01 pop 198911 ## 8 1967-08-01 psavert 12.6\r## 9 1967-08-01 uempmed 4.7\r## 10 1967-08-01 unemploy 2945 ## # ... with 2,860 more rows\r Talvez não fique imediatamente claro para todos porque eu optei por esta solução, mas talvez essa próxima figura fale mais que mil palavras.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line() +\rfacet_wrap(~variavel, scales = \u0026quot;free_y\u0026quot;, ncol = 1)\r A ênfase em usar tidy data no tidyverse decorre do fato de que todos os pacotes são programados para usar a forma de organização do banco como uma alavanca para facilitar a análise de dados. Vejam esta outra pipeline.\n# Como vamos fazer algumas transformações nos dados, vamos carregar o dplyr aqui\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r ## The following objects are masked from 'package:stats':\r## ## filter, lag\r ## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, shape = variavel)) +\rgeom_line()\r E agora vejam um dos erros mais comuns de quem está começando:\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line()\r Ao não especificar uma separação entre grupos, o ggplot2 não interpreta meus dados! Ele simplesmente conecta as observações mais ou menos na ordem em que elas aparecem no eixo x. Para resolver esse problema, precisamos especificar grupos! Seja indiretamente, através de uma escala de cores, formas ou tipos de linha, seja diretamente através da estética groups.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, group = variavel)) +\rgeom_line()\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, linetype = variavel)) +\rgeom_line()\r Legal né?\nBarcharts Para terminar e ilustrar alguns exemplos de transformação estatística, vamos fazer alguns gráficos de barras usando o diamonds, um banco de dados para fazer a alegria das piores pessoas na história da humanidade.\ndiamonds\r ## # A tibble: 53,940 x 10\r## carat cut color clarity depth table price x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43\r## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31\r## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31\r## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63\r## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75\r## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48\r## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47\r## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53\r## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49\r## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39\r## # ... with 53,930 more rows\r Que tal um gráfico básico, do número de diamantes de acordo com a qualidade de seu corte (cut). Olhando a ajuda do ?geom_bar você vai na certeza de que você entendeu a aula e escreve o seguinte código:\nggplot(diamonds, aes(x = cut, color = cut)) +\rgeom_bar()\r E agora, você fica olhando pro seu computador com cara de tacho. O que aconteceu? Bom, no caso de geoms com duas dimensões, podem existir casos em que você quer dar mapeamentos estéticos distintos para as bordas e para o conteúdo deles. Por isso, existem as estéticas color e fill. Você pode pensar nelas como a casca do pão e o recheio.\nggplot(diamonds, aes(x = cut, fill = cut)) +\rgeom_bar()\r Mas, você ainda não está satisfeito. Pela sua ampla experiência com uma das indústrias mais sangrentas e retrógadas do planeta você entende que a qualidade do corte não é o suficiente para determinar o valor de um diamante, então você quer ver a distribuição também pelo nível de transparência do diamante, codificado na variável clarity.\nggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar()\r Esse é um primeiro passo interessante, e se tivessemos apenas duas ou três categorias, a gente poderia parar por aí. Mas no geral, para facilitar comparações, queremos poder controlar o posicionamento das barras. Isso é possível ajustando o argumento position dos geoms onde isso é necessário.\n# O padrão\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;stack\u0026quot;)\r # O certo\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;dodge\u0026quot;)\r # Empilhadas a 100%, para facilitar comparações entre categorias\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;fill\u0026quot;)\r Pode parecer jocoso, mas em 99% dos casos, o correto é você usar barras lado-a-lado, assim você visualmente pode comparar as categorias simplesmente comparando a altura das barras. Da próxima vez que você pensar em construir um gráfico de pizza, desista e faça um gráfico de barras com position = \u0026quot;dodge\u0026quot;. Seus leitores vão agradecer.\nEsse exemplo também é legal para gente olhar um pouco para a parte de transformações estatísticas nas variáveis:\ndiamonds2 \u0026lt;- diamonds %\u0026gt;% count(cut) %\u0026gt;% mutate(prop = n/sum(n))\rdiamonds2 %\u0026gt;% ggplot() +\rgeom_bar(aes(x = cut, y = prop), stat = \u0026quot;identity\u0026quot;)\r Por padrão, geom_bar já faz o primeiro passo e utiliza as contagens (stat_count) para produzir o gráfico de barras, mas eu posso mudar esse comportamento através do argumento stat. Eu também posso querer mostrar proprções ao invés de contagens de outra forma mais sucinta.\nggplot(diamonds, aes(x = cut, # ao fazer isso, eu mudo o padrão de contagens para proporções.\ry = stat(prop), # preciso especificar o grupo, se não todas as barras vão a 100%.\rgroup = 1)) +\rgeom_bar()\r Você pode construir seus gráficos a partir de transformações estatísticas ao invés de objetos geométricos:\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\rfun = median\r)\r As transformações estatísticas começam sempre com stat_ e cada uma tem um objeto geométrico padrão, que você pode mudar com o argumento geom.\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\r# Não dá pra mostrar a mediana com barras de erro, sorry\r#fun = median,\rgeom = \u0026quot;errorbar\u0026quot;\r)\r E era basicamente isso que eu tinha a dizer sobre como construir gráficos no ggplot2! Abaixo, uma seção com alguns detalhes para quem tiver interesse nessa parte de embelezamento dos gráficos.\nPerfumaria Essa seção pretende introduzir um pouco uma parte de customização dos gráficos. Frequentemente, as publicações de regras mais estritas sobre formatos, fontes, temas, etc. As opções padrão do ggplot2 podem não se acomodar, então, cabe a nós ajeitar essa reta final.\nTítulos e rótulos A melhor maneira de ajustar títulos e rótulos é através de labs, porque você resolve tudo em uma só invocação. Mas também há uma função ggtitle. Com ela, é possível setar apenas título e subtítulo.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;)\r A maioria das opções de customização mais fina está na camada theme. Internamente, cada elemento do gráfico é controlado por uma função element_, por exemplo, element_text desenha textos e recebe argumentos relativos a isso, como família da fonte, tamanho, cor, etc.\nAli, você tem um controle mais direto sobre a construção do gráfico. No que diz respeito aos rótulos, podemos mudar a fonte do título.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;))\r Usando uma síntaxe similar e os argumentos da função element_text, você pode mudar qual outro elemento textual do gráfico.\nEixos Continuando o nosso frankenstein, podemos fazer alterações nos eixos, como remover pedaços de um eixo, modificar sua forma, seu ângulo e ajustar sua posição.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;),\r# você pode remover pedaços inteiros do gráfico com \u0026quot;element_blank()\u0026quot;\raxis.ticks.y = element_blank(),\raxis.text.y = element_blank(),\raxis.title.y = element_blank(),\r# você pode mudar a orientação, angulo, posição e até formato de elementos\raxis.title = element_text(angle = 90, hjust = 1),\raxis.text.x = element_text(angle = 45, vjust = 1),\raxis.ticks.x = element_line(\rcolour = \u0026quot;royalblue3\u0026quot;,\rarrow = grid::arrow(angle = 45, length = unit(0.5, \u0026quot;cm\u0026quot;), ends = \u0026quot;first\u0026quot;, type = \u0026quot;closed\u0026quot;))\r)\r Realmente, o céu é o limite e você pode deixar o seu gráfico tão horrível quanto você quiser.\nLegendas Legendas no ggplot2 são controladas em alguns lugares diferentes. Elas são tratadas como guias (guides) no sentido de que são guias para o leitor. Vamos pegar outra variável de cores, para poder brincar com diferentes tipos de legenda.\nggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point()\r Por padrão, ele entende cilindros como numérico e faz uma barra de cores contínua. Mas eu quero uma legenda!\n# Jeito 1 - Simples e rápido\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = \u0026quot;legend\u0026quot;)\r # Jeito 2 - Posso mudar detalhes!\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;))\r # Jeito 3 - Mexendo diretamente nas escalas\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(guide = \u0026quot;legend\u0026quot;, option = \u0026quot;B\u0026quot;)\r # Jeito 3 - de novo, mas agora usando a especificação mais completa do guia\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(\rguide = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;), option = \u0026quot;B\u0026quot;)\r Em qualquer lugar onde você possa especificar guides, você pode passar o valor FALSE para remover a legenda.\n# Na camada \u0026quot;guides()\u0026quot;\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rguides(color = FALSE)\r # Na própria escala\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rscale_size(guide = FALSE)\r # Bônus = no tema, mas aí você remove todas\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rtheme(legend.position = \u0026quot;none\u0026quot;)\r Escalas Já dei uma palhinha de editar escalas, antes, então aqui vai um pouco mais de detalhe:\nggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point()\r # Mudar as cores manualmente\rcores \u0026lt;- c(\u0026quot;red\u0026quot;, \u0026quot;green\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;yellow\u0026quot;, \u0026quot;purple\u0026quot;, \u0026quot;tomato\u0026quot;, \u0026quot;wheat2\u0026quot;)\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores)\r # Mudar os tamanhos\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_radius para fazer proprcional ao raio\rscale_radius(range = c(3,6))\r ggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_size para fazer proprcional a área\rscale_size(range = c(2,4))\r É possível aplicar transformações na variável diretamente na escala, mudar o número de breaks e especificar labels e alterar os limites do gráfico manualmente.\nggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;, name = \u0026quot;Peso\u0026quot;) +\rscale_y_continuous(\rname = \u0026quot;Consumo (rodovia)\u0026quot;,\rlimits = c(0, 50),\rbreaks = c(10, 20, 30, 40, 50), labels = c(\u0026quot;fogo no clima\u0026quot;, \u0026quot;aquecimento global\u0026quot;, \u0026quot;caldeira planetária\u0026quot;, \u0026quot;deixa pra próxima geração\u0026quot;, \u0026quot;desastre em câmera lenta\u0026quot;))\r Cada escala vai ter argumentos específicos que fazem sentido em seu próprio contexto. Escalas contínuas tem argumentos para transformação estatística, escalas discretas não aceitam argumentos contínuos e etc.\nIsto encerra nossa parte de ggplot2, que tal uns exercícios pra esquentar?\nExercícios  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?\n  Utilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.\n  Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.\n  No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?\n  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  ggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r  Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.\n  Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.\n  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Tente recriar o seguinte gráfico  ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"b9e37b7e1055bb09bf3bd731ebee0b86","permalink":"https://laddem.github.io/courses/tidyverse/dia3/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia3/","section":"courses","summary":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.","tags":null,"title":"ggplot2","type":"book"},{"authors":null,"categories":null,"content":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer. Pra não ficar uma coisa solta no começo da aula, aqui uma foto de gatinho pra vocês:\nO assunto da aula de hoje é talvez um pouco mais abstrato do que as aulas anteriores. Vamos falar bastante de funções, loops e programação funcional. São termos que fazem parte do jargão da computação, mas que mesmo usuários veteranos do R como software estatístico para análise de dados podem ter pouca familiaridade. Ao invés de começar definindo o que vamos fazer, vou começar definindo o que não vamos.\n  Não vamos revisar a fundo o assunto de iterações. Os livros fazem um bom serviço, é um assunto espinhoso e não basta compreender os conceitos, tem que botar a mão na massa pra ter um entendimento não apenas da teoria, mas também para conseguir resolver os muitos problemas que aparecem quando você está construindo iterações com maior nível de complexidade.\n  Não vamos cavar fundo em todos os aspectos da programação funcional ou de todas as funções do purrr. São muitas e temos poucas horas.\n  Agora o que SIM vamos fazer é revisar muito brevemente a sintaxe de um for loop, ver em que situações a gente o utilizaria e como você pode substituir seus vários for loops por funções no purrr, com exemplos de aplicação quando possível. Se der tempo, vamos entrar um pouco na ideia de utilizar programação funcional para resolver problemas mais genéricos em que precisamos generalizar alguma tarefa.\n# Primeiro, nossos pacotes!\rlibrary(tidyverse) # o purrr já é carregado automaticamente junto com os outros,\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r # Se quiser carregar apenas o purrr, descomente a linha abaixo\r# library(purrr)\r Iterações Do ponto de vista prático, uma iteração é uma repetição uma linha de código de tal forma que apenas uma pequena parte previsível do código muda entre uma repetição e outra. Por exemplo, digamos que você vai calcular uma soma de x.\nx \u0026lt;- runif(100, 0, 1000)\rx\r ## [1] 225.093967 466.946190 883.812438 87.936952 817.297665 959.868374\r## [7] 238.111861 832.283389 517.254072 102.303256 429.861933 994.676597\r## [13] 80.038906 91.034775 315.595919 669.703517 666.710230 425.227435\r## [19] 497.996177 169.809868 677.356086 627.092270 59.883331 766.776678\r## [25] 149.171108 905.846157 544.019980 536.797568 155.848320 622.688184\r## [31] 967.633909 585.653757 699.380320 189.194041 768.424587 571.151547\r## [37] 794.404194 773.359030 59.930340 432.662018 560.213616 676.552325\r## [43] 865.665243 534.298338 184.087156 378.304177 979.344523 455.709585\r## [49] 385.905114 158.846492 508.830850 522.506361 611.013883 926.345360\r## [55] 476.592277 468.897322 559.445858 927.857062 424.459786 848.563421\r## [61] 690.474162 836.675233 226.751909 965.321906 42.961176 578.897402\r## [67] 278.689574 97.974729 847.269263 351.362806 617.868732 228.979437\r## [73] 217.598302 279.653980 602.528267 902.524905 109.103549 874.569871\r## [79] 3.867538 246.845225 971.238817 460.380726 858.708653 273.029658\r## [85] 79.749562 889.292917 775.435723 623.977954 376.979606 17.145635\r## [91] 648.954440 591.458843 806.026611 252.165876 22.365448 657.280677\r## [97] 999.726557 189.202339 267.494455 940.787127\r Esqueça, por um instante, a função sum. O cálculo da soma se dá pela soma de todos os elementos do vetor x. Então, é necessário repetir a operação de soma através da acumulação dos valores. Veja que é tudo totalmente previsível, cada nova repetição simplesmente adiciona mais um valor ao vetor original e esse valor pode ser encontrado na próxima posição de x. Esse é o típico caso de iteração. No R, a melhor prática é inicializar uma variável antes e salvar os resultados da iteração nela.\n# Inicialização\rresult \u0026lt;- x[[1]]\r# Sequência\rfor (i in 2:length(x)) {\r# Corpo\rresult \u0026lt;- result + x[[i]]\r}\r# Comparando os dois resultados\rresult\r ## [1] 51513.6\r sum(x)\r ## [1] 51513.6\r Outro exemplo de mesmo tipo é repetição de uma mesma operação em vários vetores/colunas/variáveis comuns. Por exemplo, se eu tenho um data.frame com três colunas numéricas e eu gostaria de calcular a soma de cada uma.\n# Data.frame\rdf \u0026lt;- tibble(x = rnorm(100, 50, 25),\ry = rnorm(100, 100, 25),\rz = rnorm(100, 200, 25))\r# Inicialização\rresult \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = length(df))\r# Sequência\rfor (i in seq_along(df)) {\rresult[[i]] \u0026lt;- sum(df[[i]])\r}\r# Resultado\rresult\r ## [1] 5143.487 9739.920 19452.666\r Essa é a minha revisão de 5 minutos de iteração em R usando for loops. Como já é de costume, tem muito mais. Por exemplo, existe um outro tipo de iterador no R básico chamado while, que tem um funcionamento diferente do for. Ao invés de você ter um resultado de tamanho previsível, você pode ter um resultado de tamanho desconhecido. Vou deixar o while para vocês pesquisarem porque o bom e velho for costuma cobrir a maioria dos casos de uso do cientista de dados.\nProgramação funcional Beleza, agora que já dominamos (ou não) o for loop, encontramos várias situações em que a gente gostaria de realizar a mesma operação várias vezes, mas, o for loop é como uma feijoada: é gostoso, mas é pesado. For loops em geral são \u0026ldquo;verbosos\u0026rdquo;, você precisa escrever bastante para chegar em um determinado resultado e, depois de escrever alguns, você cansa de ter que repetir todos os pedaços dele. E se você pudesse abstrair o loop para uma função? Aí você não precisaria escrever toda aquela parafernalha.\nsoma \u0026lt;- function(x) {\rresult \u0026lt;- 0\rfor (i in 1:length(x)) {\rresult \u0026lt;- result + x[[i]]\r}\rresult\r}\rsoma(x)\r ## [1] 51513.6\r Ao fazer isso, eu ganho duas vantagens:\n  Manutenção: sempre que eu precisar repetir a operação, eu consigo simplificar muito meu código. Não preciso escrever um for loop para cada soma que eu precisar fazer. Se meus requerimentos mudarem no futuro, eu só preciso mudar um pedaço de código.\n  Leitura: o humano que lê um for loop vai precisar de um minuto para se familiarizar com a operação e entender o que está sendo iterado, calculado, etc. O humano que lê \u0026ldquo;soma\u0026rdquo; sabe que ocorrerá uma soma. Você alinha a expectativa com a execução.\n  Outro exemplo.\nsoma_xyz \u0026lt;- function(x) {\rsoma_xyz \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = nrow(x))\rfor (i in seq_along(x[[1]])) {\rsoma_xyz[[i]] \u0026lt;- x[[1]][[i]] + x[[2]][[i]] + x[[3]][i]\r}\rsoma_xyz\r}\rdf$soma_xyz2 \u0026lt;- soma_xyz(df)\rdf\r ## # A tibble: 100 x 4\r## x y z soma_xyz2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 31.0 91.0 182. 304.\r## 2 51.9 91.1 188. 331.\r## 3 51.3 85.1 229. 365.\r## 4 80.0 139. 179. 398.\r## 5 80.5 50.1 228. 359.\r## 6 59.8 122. 231. 413.\r## 7 69.4 135. 242. 446.\r## 8 16.5 76.6 234. 327.\r## 9 69.2 107. 189. 365.\r## 10 51.6 75.2 234. 361.\r## # ... with 90 more rows\r Outra vantagem de ter na mão uma função, é que eu posso me apropriar das ferramentas de programação funcional do R. São as funções da família apply, que recebem uma lista de objetos e aplicam uma função em cada um. Basicamente, aquela abstração do for loop que estavamos buscando.\nVejam como eu posso recriar o exemplo das somas das colunas do data.frame usando a função soma.\nsapply(df, soma)\r ## x y z soma_xyz2 ## 5143.487 9739.920 19452.666 34336.074\r Eu sei, o exemplo é muito simples pra ter uma aplicação real. Até porque já vimos como fazer esse tipo de operação com summarize lá atrás. Mas talvez, na hora que você estiver realizando alguma operação de repetição, você se lembre dessa possibilidade e ela lhe seja útil.\no pacote purrr Até o momento, nos limitamos a utilizar funções presentes no base, mas o verdadeiro intuito dessa aula é introduzir as facilidade trazidas pelas funções do tidyverse. No pacote purrr, são importadas funções com diversas funcionalidades que facilitam o trabalho com objetos mais complexos, como listas (pense saída de modelo), iterações envolvendo mais de um argumento (pense escrever diversos objetos em diversos arquivos distintos) e assim sucessivamente. Abaixo, segue uma lista das funções do pacote com uma descrição curta.\n  a família map_(): similar a família apply do R base. Recebe uma lista de objetos de entrada e uma função e devolve uma lista com os resultados.\n  map2_(): mesma coisa, só que você pode passar duas listas de objetos e uma função que requer dois argumentos variáveis. pmap() é a generalização, em que você passa p listas e uma função que pede p argumentos.\n  imap(): aplica uma função tanto ao vetor, como a seu nome/índice. É meio louco, mas é muito útil para alguns casos de uso.\n  modify_(): permite aplicar alterações no objeto estilo o que você faria com uma pipeline de filter %\u0026gt;% mutate\n  safely(): e suas irmãs possibly() e quietly() ajudam a obter resultados mesmo quando há ocorre um erro na iteração.\n  transpose(), flatten_: manipulam e reformatam listas.\n  invoke_map(): aplica uma lista de funções a uma (opcional) segunda lista de parâmetros.\n  reduce() e accumulate(): generalizam as operações de sumarização (pense soma acumulada, média, limite, fatorial)\n  pluck(): pesca elementos de uma lista com uma sintaxe linear e bonitinha.\n  E muito mais coisas\n  No interesse de ir direto ao ponto e não tentar ser exaustivo, vamos ver algumas delas em mais detalhe.\nA função map Essa função é praticamente uma cópia de lapply.\ndf %\u0026gt;% lapply(sum)\r ## $x\r## [1] 5143.487\r## ## $y\r## [1] 9739.92\r## ## $z\r## [1] 19452.67\r## ## $soma_xyz2\r## [1] 34336.07\r df %\u0026gt;% map(sum)\r ## $x\r## [1] 5143.487\r## ## $y\r## [1] 9739.92\r## ## $z\r## [1] 19452.67\r## ## $soma_xyz2\r## [1] 34336.07\r Embora existam pequenas diferenças técnicas entre elas, a principal vantagem de map é a possibilidade de criar funções anônimas com uma síntaxe enxuta. Pense, por exemplo, em elevar ao quadrado.\ndf %\u0026gt;% lapply(function(x) x ^ 2)\r ## $x\r## [1] 963.798425 2689.631568 2636.289299 6407.686421 6483.401508\r## [6] 3576.407300 4821.200204 271.838261 4794.752257 2663.713324\r## [11] 1269.154807 2810.472272 7733.236266 6633.116709 5544.943339\r## [16] 1276.384278 474.645743 530.431720 3967.496532 3503.986006\r## [21] 4195.830138 6536.191280 2123.966230 1896.230863 320.311269\r## [26] 2713.855093 5381.268996 2205.452174 1047.781254 826.682084\r## [31] 2402.199045 5385.394322 2185.874731 5499.186633 8254.465662\r## [36] 3073.557849 5293.252928 2556.876189 3757.490933 1106.909116\r## [41] 1172.640022 7124.351428 875.948131 1428.390668 1426.113597\r## [46] 644.544767 3285.989441 853.645977 1.357369 2407.567674\r## [51] 5042.688807 5971.962098 4296.292935 124.644964 128.512784\r## [56] 7094.788796 6758.841939 3363.246840 881.306860 5323.336414\r## [61] 3396.128177 6276.881787 1185.356939 2587.379920 838.544288\r## [66] 882.065801 3046.336401 2404.123388 1843.174212 5069.910793\r## [71] 1426.091409 911.092383 12730.733608 6053.560724 3040.006719\r## [76] 658.250295 3402.752115 1192.989288 702.982204 959.240469\r## [81] 2427.061850 2819.283784 10924.963453 2645.464063 561.923775\r## [86] 12385.985694 3377.797601 1343.722757 383.297474 176.408849\r## [91] 4730.214023 955.567165 199.646662 6515.078501 1036.390327\r## [96] 1897.596732 2503.095741 236.412280 5393.150328 7001.526245\r## ## $y\r## [1] 8284.074 8303.088 7248.696 19391.930 2513.737 14851.220 18185.189\r## [8] 5865.938 11469.122 5650.669 10981.344 9473.321 9651.519 4452.080\r## [15] 6911.495 5374.510 11412.073 8851.945 10147.838 8415.336 6150.245\r## [22] 10513.858 11171.249 7657.689 3992.072 5309.097 9101.852 5460.790\r## [29] 10432.513 18788.381 4017.091 4116.322 3185.162 17520.537 3186.135\r## [36] 20143.963 10421.231 13894.456 7658.279 13681.015 15217.759 7052.142\r## [43] 12370.005 18450.451 5580.275 27559.470 9870.916 16777.651 14345.106\r## [50] 12084.487 11485.295 8327.790 26203.364 5477.594 8668.665 13172.393\r## [57] 12254.427 8711.024 9961.140 1268.758 7689.774 15604.880 9159.717\r## [64] 2758.645 10634.015 7599.150 14277.682 9006.049 11517.774 14155.260\r## [71] 10073.476 9203.164 4397.964 9118.102 6600.212 22169.380 7813.854\r## [78] 4461.388 10345.651 18106.926 7387.860 4662.773 20930.433 20457.998\r## [85] 9300.546 10149.361 7864.841 7646.981 7404.943 7709.098 7451.508\r## [92] 6907.973 6798.440 2214.701 12265.324 8910.786 8559.719 5810.114\r## [99] 4509.739 24625.748\r## ## $z\r## [1] 33154.90 35301.39 52433.74 32066.30 52077.27 53418.40 58521.86 54728.30\r## [9] 35690.17 54670.05 30497.10 29415.67 43156.04 32921.73 41698.45 55566.30\r## [17] 43630.23 49193.06 54089.95 38195.18 34639.45 30576.09 49807.56 40702.65\r## [25] 20512.02 30184.61 36949.72 58733.16 26796.23 47936.82 51652.77 33534.37\r## [33] 35970.26 23678.10 48648.95 33974.30 52570.99 30830.01 35836.79 36227.24\r## [41] 35372.95 34173.24 33564.92 31669.90 26779.00 31282.84 48986.23 43579.62\r## [49] 35944.99 29879.19 35826.63 26734.84 28090.00 20681.89 27921.49 40456.99\r## [57] 41507.86 24353.79 46273.41 42284.43 40001.73 41300.76 39745.56 27884.99\r## [65] 34581.60 34593.96 51853.12 50778.22 30045.59 37364.14 40176.84 20330.91\r## [73] 20957.48 43953.10 53487.80 33438.31 33781.46 47470.47 32914.79 33808.00\r## [81] 44550.95 32464.52 44696.09 36404.34 41732.33 17360.01 46148.44 55470.45\r## [89] 33890.15 31730.22 36964.04 47231.90 24258.20 36893.01 42387.00 48762.97\r## [97] 37281.18 43244.78 34961.56 34329.15\r## ## $soma_xyz2\r## [1] 92505.32 109474.68 133567.02 158701.52 128781.37 170397.94 199094.67\r## [8] 106940.59 133412.35 130031.19 99257.32 103590.54 155173.98 108643.62\r## [15] 130900.51 118861.27 113900.96 114860.63 157051.32 119969.06 108448.68\r## [22] 128338.79 140592.54 110757.80 50310.62 89218.94 130309.35 131920.52\r## [29] 88926.02 148046.10 115372.46 102827.80 85760.45 129887.12 135324.67\r## [36] 145687.48 163315.25 118353.26 114322.46 115988.37 119495.42 124780.60\r## [43] 104991.71 123613.33 76235.66 135621.24 142887.30 135058.53 96427.49\r## [50] 110126.02 135027.30 110252.64 156041.87 52435.15 73733.57 160112.69\r## [57] 157328.59 94484.55 118752.53 98729.56 119696.62 165952.07 108569.13\r## [64] 73103.77 101149.61 91728.55 161922.28 136362.02 104710.31 147054.80\r## [71] 114630.97 72201.81 104920.71 146645.60 135168.17 127743.12 109247.74\r## [78] 101895.35 95884.19 122082.54 119915.96 90938.77 212162.11 148428.93\r## [85] 105254.30 118194.15 130772.38 129330.50 83939.26 77959.99 120658.28\r## [92] 109796.45 63671.81 102305.42 121677.47 128724.35 112649.55 89732.36\r## [99] 107303.92 181375.75\r df %\u0026gt;% map(~ .x ^ 2)\r ## $x\r## [1] 963.798425 2689.631568 2636.289299 6407.686421 6483.401508\r## [6] 3576.407300 4821.200204 271.838261 4794.752257 2663.713324\r## [11] 1269.154807 2810.472272 7733.236266 6633.116709 5544.943339\r## [16] 1276.384278 474.645743 530.431720 3967.496532 3503.986006\r## [21] 4195.830138 6536.191280 2123.966230 1896.230863 320.311269\r## [26] 2713.855093 5381.268996 2205.452174 1047.781254 826.682084\r## [31] 2402.199045 5385.394322 2185.874731 5499.186633 8254.465662\r## [36] 3073.557849 5293.252928 2556.876189 3757.490933 1106.909116\r## [41] 1172.640022 7124.351428 875.948131 1428.390668 1426.113597\r## [46] 644.544767 3285.989441 853.645977 1.357369 2407.567674\r## [51] 5042.688807 5971.962098 4296.292935 124.644964 128.512784\r## [56] 7094.788796 6758.841939 3363.246840 881.306860 5323.336414\r## [61] 3396.128177 6276.881787 1185.356939 2587.379920 838.544288\r## [66] 882.065801 3046.336401 2404.123388 1843.174212 5069.910793\r## [71] 1426.091409 911.092383 12730.733608 6053.560724 3040.006719\r## [76] 658.250295 3402.752115 1192.989288 702.982204 959.240469\r## [81] 2427.061850 2819.283784 10924.963453 2645.464063 561.923775\r## [86] 12385.985694 3377.797601 1343.722757 383.297474 176.408849\r## [91] 4730.214023 955.567165 199.646662 6515.078501 1036.390327\r## [96] 1897.596732 2503.095741 236.412280 5393.150328 7001.526245\r## ## $y\r## [1] 8284.074 8303.088 7248.696 19391.930 2513.737 14851.220 18185.189\r## [8] 5865.938 11469.122 5650.669 10981.344 9473.321 9651.519 4452.080\r## [15] 6911.495 5374.510 11412.073 8851.945 10147.838 8415.336 6150.245\r## [22] 10513.858 11171.249 7657.689 3992.072 5309.097 9101.852 5460.790\r## [29] 10432.513 18788.381 4017.091 4116.322 3185.162 17520.537 3186.135\r## [36] 20143.963 10421.231 13894.456 7658.279 13681.015 15217.759 7052.142\r## [43] 12370.005 18450.451 5580.275 27559.470 9870.916 16777.651 14345.106\r## [50] 12084.487 11485.295 8327.790 26203.364 5477.594 8668.665 13172.393\r## [57] 12254.427 8711.024 9961.140 1268.758 7689.774 15604.880 9159.717\r## [64] 2758.645 10634.015 7599.150 14277.682 9006.049 11517.774 14155.260\r## [71] 10073.476 9203.164 4397.964 9118.102 6600.212 22169.380 7813.854\r## [78] 4461.388 10345.651 18106.926 7387.860 4662.773 20930.433 20457.998\r## [85] 9300.546 10149.361 7864.841 7646.981 7404.943 7709.098 7451.508\r## [92] 6907.973 6798.440 2214.701 12265.324 8910.786 8559.719 5810.114\r## [99] 4509.739 24625.748\r## ## $z\r## [1] 33154.90 35301.39 52433.74 32066.30 52077.27 53418.40 58521.86 54728.30\r## [9] 35690.17 54670.05 30497.10 29415.67 43156.04 32921.73 41698.45 55566.30\r## [17] 43630.23 49193.06 54089.95 38195.18 34639.45 30576.09 49807.56 40702.65\r## [25] 20512.02 30184.61 36949.72 58733.16 26796.23 47936.82 51652.77 33534.37\r## [33] 35970.26 23678.10 48648.95 33974.30 52570.99 30830.01 35836.79 36227.24\r## [41] 35372.95 34173.24 33564.92 31669.90 26779.00 31282.84 48986.23 43579.62\r## [49] 35944.99 29879.19 35826.63 26734.84 28090.00 20681.89 27921.49 40456.99\r## [57] 41507.86 24353.79 46273.41 42284.43 40001.73 41300.76 39745.56 27884.99\r## [65] 34581.60 34593.96 51853.12 50778.22 30045.59 37364.14 40176.84 20330.91\r## [73] 20957.48 43953.10 53487.80 33438.31 33781.46 47470.47 32914.79 33808.00\r## [81] 44550.95 32464.52 44696.09 36404.34 41732.33 17360.01 46148.44 55470.45\r## [89] 33890.15 31730.22 36964.04 47231.90 24258.20 36893.01 42387.00 48762.97\r## [97] 37281.18 43244.78 34961.56 34329.15\r## ## $soma_xyz2\r## [1] 92505.32 109474.68 133567.02 158701.52 128781.37 170397.94 199094.67\r## [8] 106940.59 133412.35 130031.19 99257.32 103590.54 155173.98 108643.62\r## [15] 130900.51 118861.27 113900.96 114860.63 157051.32 119969.06 108448.68\r## [22] 128338.79 140592.54 110757.80 50310.62 89218.94 130309.35 131920.52\r## [29] 88926.02 148046.10 115372.46 102827.80 85760.45 129887.12 135324.67\r## [36] 145687.48 163315.25 118353.26 114322.46 115988.37 119495.42 124780.60\r## [43] 104991.71 123613.33 76235.66 135621.24 142887.30 135058.53 96427.49\r## [50] 110126.02 135027.30 110252.64 156041.87 52435.15 73733.57 160112.69\r## [57] 157328.59 94484.55 118752.53 98729.56 119696.62 165952.07 108569.13\r## [64] 73103.77 101149.61 91728.55 161922.28 136362.02 104710.31 147054.80\r## [71] 114630.97 72201.81 104920.71 146645.60 135168.17 127743.12 109247.74\r## [78] 101895.35 95884.19 122082.54 119915.96 90938.77 212162.11 148428.93\r## [85] 105254.30 118194.15 130772.38 129330.50 83939.26 77959.99 120658.28\r## [92] 109796.45 63671.81 102305.42 121677.47 128724.35 112649.55 89732.36\r## [99] 107303.92 181375.75\r Através do uso de fórmulas ~ é possível especificar funções anônimas simples economizando caracteres e utilizando o autocompletar.\nQue tal esta pipeline?\nlibrary(nycflights13)\r# Médias de todas as variáveis numéricas usando where()\rflights %\u0026gt;% select(where(is.numeric)) %\u0026gt;% map(mean)\r ## $year\r## [1] 2013\r## ## $month\r## [1] 6.54851\r## ## $day\r## [1] 15.71079\r## ## $dep_time\r## [1] NA\r## ## $sched_dep_time\r## [1] 1344.255\r## ## $dep_delay\r## [1] NA\r## ## $arr_time\r## [1] NA\r## ## $sched_arr_time\r## [1] 1536.38\r## ## $arr_delay\r## [1] NA\r## ## $flight\r## [1] 1971.924\r## ## $air_time\r## [1] NA\r## ## $distance\r## [1] 1039.913\r## ## $hour\r## [1] 13.18025\r## ## $minute\r## [1] 26.2301\r Ou esta\n# Proporção de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(mean)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 0.02451184\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 0.02451184\r## ## $arr_time\r## [1] 0.0258718\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 0.02800081\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 0.007458964\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 0.02800081\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r # Contagem de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(sum)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 8255\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 8255\r## ## $arr_time\r## [1] 8713\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 9430\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 2512\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 9430\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r A outra grande vantagem do map é ter acesso fácil ao controle do tipo de saída.\n# Vetor numérico\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_dbl(mean)\r ## year month day dep_time sched_dep_time ## 0.000000000 0.000000000 0.000000000 0.024511842 0.000000000 ## dep_delay arr_time sched_arr_time arr_delay carrier ## 0.024511842 0.025871796 0.000000000 0.028000808 0.000000000 ## flight tailnum origin dest air_time ## 0.000000000 0.007458964 0.000000000 0.000000000 0.028000808 ## distance hour minute time_hour ## 0.000000000 0.000000000 0.000000000 0.000000000\r # Vetor de caracteres\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_chr(mean)\r ## year month day dep_time sched_dep_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.024512\u0026quot; \u0026quot;0.000000\u0026quot; ## dep_delay arr_time sched_arr_time arr_delay carrier ## \u0026quot;0.024512\u0026quot; \u0026quot;0.025872\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; \u0026quot;0.000000\u0026quot; ## flight tailnum origin dest air_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.007459\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; ## distance hour minute time_hour ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot;\r Um exemplo um pouco mais elaborado: avaliação inicial de variáveis em um modelo. Em geral, é comum rodar um modelo para cada variável numérica para ver como elas se comportam.\nrespvar \u0026lt;- \u0026quot;hwy\u0026quot;\rpredvars \u0026lt;- names(select(mpg, where(is.numeric), -hwy))\rtibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rsummary = map(fit, summary),\rr2 = map_dbl(summary, \u0026quot;r.squared\u0026quot;),\rFStat = map_df(summary, \u0026quot;fstatistic\u0026quot;),\rcoefs = map_df(fit, coef),\r)\r ## # A tibble: 4 x 6\r## names fit summary r2 FStat$value $numdf $dendf coefs$`(Interce~ $displ\r## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.87e-1 329. 1 232 35.7 -3.53\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;smmry~ 4.66e-6 0.00108 1 232 17.7 NA ## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.81e-1 321. 1 232 40.0 NA ## 4 cty \u0026lt;lm\u0026gt; \u0026lt;smmry~ 9.14e-1 2459. 1 232 0.892 NA\r Ok, a saída não está muito bonitinha! Mas com um pouco mais de trabalho, programadores melhores que eu fizeram isso:\nmodels \u0026lt;- tibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rtidied = fit %\u0026gt;% map(broom::tidy),\rglanced = fit %\u0026gt;% map(broom::glance),\raugmented = fit %\u0026gt;% map(broom::augment)\r)\rmodels\r ## # A tibble: 4 x 5\r## names fit tidied glanced augmented ## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; ## 1 displ \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 4 cty \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r Grande coisa, Vinícius, o output é ilegível! Calma! Lembram da primeira aula em que eu comentei que havia mais funções no tidyr?\n# Coeficientes\rmodels %\u0026gt;% select(tidied) %\u0026gt;%\rtidyr::unnest(tidied) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)\r ## # A tibble: 4 x 5\r## term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ -3.53 0.195 -18.2 2.04e- 46\r## 2 year 0.00285 0.0867 0.0329 9.74e- 1\r## 3 cyl -2.82 0.157 -17.9 1.18e- 45\r## 4 cty 1.34 0.0270 49.6 1.87e-125\r # Estatísticas do modelo\rmodels %\u0026gt;% select(names, glanced) %\u0026gt;% unnest(glanced)\r ## # A tibble: 4 x 13\r## names r.squared adj.r.squared sigma statistic p.value df logLik AIC\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 0.587 0.585 3.84 329. 2.04e- 46 1 -646. 1297.\r## 2 year 0.00000466 -0.00431 5.97 0.00108 9.74e- 1 1 -749. 1504.\r## 3 cyl 0.581 0.579 3.87 321. 1.18e- 45 1 -647. 1301.\r## 4 cty 0.914 0.913 1.75 2459. 1.87e-125 1 -462. 931.\r## # ... with 4 more variables: BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;, df.residual \u0026lt;int\u0026gt;,\r## # nobs \u0026lt;int\u0026gt;\r # Bancos \u0026quot;aumentados\u0026quot; com valores ajustados, resíduos, distâncias de cook, etc.\rmodels %\u0026gt;% filter(names == \u0026quot;displ\u0026quot;) %\u0026gt;% select(names, augmented) %\u0026gt;% unnest(augmented)\r ## # A tibble: 234 x 9\r## names hwy displ .fitted .resid .hat .sigma .cooksd .std.resid\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 2 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 3 displ 31 2 28.6 2.36 0.00984 3.84 0.00191 0.619 ## 4 displ 30 2 28.6 1.36 0.00984 3.84 0.000634 0.357 ## 5 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 6 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 7 displ 27 3.1 24.8 2.25 0.00463 3.84 0.000802 0.587 ## 8 displ 26 1.8 29.3 -3.34 0.0115 3.84 0.00445 -0.876 ## 9 displ 25 1.8 29.3 -4.34 0.0115 3.83 0.00751 -1.14 ## 10 displ 28 2 28.6 -0.636 0.00984 3.84 0.000138 -0.167 ## # ... with 224 more rows\r Isso aqui é só uma palhinha de modelagem com o tidyverse, mas acho que é uma demonstração muito convincente da aplicabilidade dos exemplos que vimos usando programação funcional.\nOutro exemplo mais simples com map2: salvar vários arquivos de uma vez só.\ndf1 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf2 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf3 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf4 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdfs \u0026lt;- list(df1, df2, df3, df4)\rdfs\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.142 -0.924 0.762 ## 2 0.405 -1.33 -0.196 ## 3 -0.0639 -0.399 -0.260 ## 4 -0.0699 0.0876 1.57 ## 5 0.827 -0.335 1.01 ## 6 0.187 0.419 -0.442 ## 7 1.14 -0.224 -0.0744\r## 8 -0.514 -1.27 0.896 ## 9 0.645 0.510 1.10 ## 10 -0.810 -0.246 0.589 ## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.54 0.923 -1.32 ## 2 -0.0135 -0.975 -0.0527\r## 3 1.36 -0.369 -0.434 ## 4 2.25 -0.254 0.207 ## 5 1.41 -1.43 -1.19 ## 6 0.357 0.408 -0.183 ## 7 1.32 0.773 0.427 ## 8 0.622 0.379 -1.06 ## 9 1.09 -1.27 -0.699 ## 10 1.66 1.75 -1.14 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.306 1.11 1.28 ## 2 2.70 1.65 0.579\r## 3 0.904 0.558 2.16 ## 4 -0.335 1.92 -0.144\r## 5 0.443 0.521 1.07 ## 6 0.744 0.241 -1.57 ## 7 -1.48 -0.941 0.268\r## 8 -0.00240 0.304 1.13 ## 9 0.368 -0.987 0.577\r## 10 -2.07 0.0147 1.22 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.753 0.894 -1.85 ## 2 0.960 1.53 1.12 ## 3 2.23 2.12 -0.230\r## 4 -1.15 -0.968 0.190\r## 5 1.34 1.73 0.459\r## 6 -1.44 -1.94 0.200\r## 7 0.170 -2.97 0.692\r## 8 -0.627 0.702 -0.512\r## 9 -1.50 -0.0865 -0.407\r## 10 0.633 1.15 -0.273\r## # ... with 90 more rows\r paths \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:4)\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r map2(dfs, paths, ~write_csv(x = .x, file = .y))\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.142 -0.924 0.762 ## 2 0.405 -1.33 -0.196 ## 3 -0.0639 -0.399 -0.260 ## 4 -0.0699 0.0876 1.57 ## 5 0.827 -0.335 1.01 ## 6 0.187 0.419 -0.442 ## 7 1.14 -0.224 -0.0744\r## 8 -0.514 -1.27 0.896 ## 9 0.645 0.510 1.10 ## 10 -0.810 -0.246 0.589 ## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.54 0.923 -1.32 ## 2 -0.0135 -0.975 -0.0527\r## 3 1.36 -0.369 -0.434 ## 4 2.25 -0.254 0.207 ## 5 1.41 -1.43 -1.19 ## 6 0.357 0.408 -0.183 ## 7 1.32 0.773 0.427 ## 8 0.622 0.379 -1.06 ## 9 1.09 -1.27 -0.699 ## 10 1.66 1.75 -1.14 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.306 1.11 1.28 ## 2 2.70 1.65 0.579\r## 3 0.904 0.558 2.16 ## 4 -0.335 1.92 -0.144\r## 5 0.443 0.521 1.07 ## 6 0.744 0.241 -1.57 ## 7 -1.48 -0.941 0.268\r## 8 -0.00240 0.304 1.13 ## 9 0.368 -0.987 0.577\r## 10 -2.07 0.0147 1.22 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.753 0.894 -1.85 ## 2 0.960 1.53 1.12 ## 3 2.23 2.12 -0.230\r## 4 -1.15 -0.968 0.190\r## 5 1.34 1.73 0.459\r## 6 -1.44 -1.94 0.200\r## 7 0.170 -2.97 0.692\r## 8 -0.627 0.702 -0.512\r## 9 -1.50 -0.0865 -0.407\r## 10 0.633 1.15 -0.273\r## # ... with 90 more rows\r E se eu quiser ler um banco de dados que está em vários arquivos diferentes? Vamos usar os que acabamos de criar\n# Bum! Uma linha\rpaths %\u0026gt;% map_dfr(read_csv, .id = \u0026quot;arquivo\u0026quot;)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r ## # A tibble: 400 x 4\r## arquivo x y z\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 -0.142 -0.924 0.762 ## 2 1 0.405 -1.33 -0.196 ## 3 1 -0.0639 -0.399 -0.260 ## 4 1 -0.0699 0.0876 1.57 ## 5 1 0.827 -0.335 1.01 ## 6 1 0.187 0.419 -0.442 ## 7 1 1.14 -0.224 -0.0744\r## 8 1 -0.514 -1.27 0.896 ## 9 1 0.645 0.510 1.10 ## 10 1 -0.810 -0.246 0.589 ## # ... with 390 more rows\r As possibilidades são inúmeras. A regra é a seguinte: viu uma tarefa que precisa ser repetida muitas vezes? Pense com carinho em usar uma função vetorizada através de map_.\nPredicados O objetivo de um função predicado é selecionar elementos de uma lista com base em uma função. Em geral, são funções simples que retornam um valor TRUE ou FALSE com base em alguma característica do objeto, como o tipo.\nl \u0026lt;- list(c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c(1, 2, 3))\rl %\u0026gt;% str()\r ## List of 2\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.numeric) %\u0026gt;% str()\r ## List of 1\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.character) %\u0026gt;% str()\r ## List of 1\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r O uso mais frequente que vejo de keep e discard é como uma espécie de atalho para select. Como data.frames são secretamente listas, você pode rapidamente selecionar todas as variáveis do banco que tenham o mesmo tipo.\nflights %\u0026gt;% keep(is.numeric)\r ## # A tibble: 336,776 x 14\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 6 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;\r flights %\u0026gt;% discard(is.character)\r ## # A tibble: 336,776 x 15\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 7 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;,\r## # time_hour \u0026lt;dttm\u0026gt;\r Como outros aspectos do purrr, a grande vantagem aqui é a generalidade. Essas funções funcionam em qualquer lista de objetos e não apenas em data.frames.\nLidando com a presença de erros A próxima dica forte é utilizar os advérbios (chique) safely() e companhia para lidar com erros.\nx \u0026lt;- list(a = c(1,2,3), b = c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c = c(99, 88, 77))\rx %\u0026gt;% map(sum)\r ## Error in .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm): 'type' inválido (character) do argumento\r Não conseguimos nada! A mensagem de erro nem nos informa onde o problema ocorreu. E agora?\nx %\u0026gt;% map(safely(sum)) %\u0026gt;% str()\r ## List of 3\r## $ a:List of 2\r## ..$ result: num 6\r## ..$ error : NULL\r## $ b:List of 2\r## ..$ result: NULL\r## ..$ error :List of 2\r## .. ..$ message: chr \u0026quot;'type' inválido (character) do argumento\u0026quot;\r## .. ..$ call : language .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm)\r## .. ..- attr(*, \u0026quot;class\u0026quot;)= chr [1:3] \u0026quot;simpleError\u0026quot; \u0026quot;error\u0026quot; \u0026quot;condition\u0026quot;\r## $ c:List of 2\r## ..$ result: num 264\r## ..$ error : NULL\r x %\u0026gt;% map(possibly(sum, otherwise = NA_real_)) %\u0026gt;% str()\r ## List of 3\r## $ a: num 6\r## $ b: num NA\r## $ c: num 264\r Essas funções permitem alterar a saída de uma função quando ocorrer um erro. quietly é parecido, mas ela captura mais a saída do R, o texto em si.\nx \u0026lt;- list(1, -1)\rx %\u0026gt;% map(quietly(log)) %\u0026gt;% str()\r ## List of 2\r## $ :List of 4\r## ..$ result : num 0\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr(0) ## ..$ messages: chr(0) ## $ :List of 4\r## ..$ result : num NaN\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr \u0026quot;NaNs produzidos\u0026quot;\r## ..$ messages: chr(0)\r Chamando listas de funções Vamos supor que você tem um vetor de números e você quer aplicar um monte de funções diferentes nele, mas você não quer ter que ficar copiando e colando tudo.\nnumeros \u0026lt;- rnorm(25, 50, 10)\rnumeros\r ## [1] 42.20048 38.07047 40.98823 66.99693 47.80056 45.23199 58.43128 45.39271\r## [9] 58.51740 57.56044 61.02015 34.67480 57.13596 49.33671 21.79235 48.01163\r## [17] 48.88481 55.32602 33.49729 49.72942 34.46436 56.32152 67.10447 53.74201\r## [25] 48.43169\r Nessas situações, você gostaria de chamar várias funções no mesmo objeto ou grupo de objetos, mas você não sabe bem como fazer isso\u0026hellip; Então, invoke_map vem ao resgate.\nfuncs \u0026lt;- list(\u0026quot;mean\u0026quot;, \u0026quot;sd\u0026quot;, \u0026quot;IQR\u0026quot;, \u0026quot;sum\u0026quot;, \u0026quot;length\u0026quot;, \u0026quot;range\u0026quot;, \u0026quot;min\u0026quot;, \u0026quot;max\u0026quot;)\rargs \u0026lt;- list(list(na.rm = T, trim = 0.05),\rlist(na.rm=T), list(type = 2),\rlist(na.rm = T), list(),\rlist(na.rm = T), list(na.rm = T), list(na.rm = T))\rfuncs %\u0026gt;% str()\r ## List of 8\r## $ : chr \u0026quot;mean\u0026quot;\r## $ : chr \u0026quot;sd\u0026quot;\r## $ : chr \u0026quot;IQR\u0026quot;\r## $ : chr \u0026quot;sum\u0026quot;\r## $ : chr \u0026quot;length\u0026quot;\r## $ : chr \u0026quot;range\u0026quot;\r## $ : chr \u0026quot;min\u0026quot;\r## $ : chr \u0026quot;max\u0026quot;\r args %\u0026gt;% str()\r ## List of 8\r## $ :List of 2\r## ..$ na.rm: logi TRUE\r## ..$ trim : num 0.05\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ type: num 2\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ : list()\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r invoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ : num 49.2\r## $ : num 11\r## $ : num 14.9\r## $ : num 1221\r## $ : int 25\r## $ : num [1:2] 21.8 67.1\r## $ : num 21.8\r## $ : num 67.1\r Fica mais bonito se você nomear os argumentos, ai o output fica melhorzinho.\nnames(funcs) \u0026lt;- unlist(funcs)\rinvoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ mean : num 49.2\r## $ sd : num 11\r## $ IQR : num 14.9\r## $ sum : num 1221\r## $ length: int 25\r## $ range : num [1:2] 21.8 67.1\r## $ min : num 21.8\r## $ max : num 67.1\r Claro que esse exemplo aqui talvez não seja útil para vocês, mas espero que quando vocês encontrarem uma situação em que você gostaria de aplicar uma bateria de funções no mesmo objeto ou grupo de objetos, vocês se lembrem dessa possibilidade.\nreduce e accumulate Essas duas funções são desenhadas para fazer aplicações recursivas de funções que recebem dois argumentos (operadores matemáticos, _joins, etc. Recursividade em linhas gerais, é você repetir uma operação com o resultado da repetição anterior. Pense em somas ou produtos acumulados, em que o próximo valor é determinado pela aplicação de uma regra sobre o anterior.\naccumulate(1:10, `+`)\r ## [1] 1 3 6 10 15 21 28 36 45 55\r accumulate(1:10, `*`)\r ## [1] 1 2 6 24 120 720 5040 40320 362880\r## [10] 3628800\r A principal diferença entre accumulate e reduce é que a primeira guarda os resultados intermediários, enquanto a segunda retorna apenas o último.\nreduce(1:10, `+`)\r ## [1] 55\r reduce(1:10, `*`)\r ## [1] 3628800\r Uma aplicação bastante prática dessas funções é a produção de um único banco de dados a partir de vários arquivos separados.\n# Lembra dos nossos arquivos lá em cima?\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r Vamos fingir que não temos acesso a map_dfr e precisamos importar esses objetos e todos compõem um único banco. Imaginaem que tratam-se de dados por ano.\ndfs \u0026lt;- map(paths, read_csv)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r glimpse(dfs)\r ## List of 4\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.1423 0.405 -0.0639 -0.0699 0.8265 ...\r## ..$ y: num [1:100] -0.9244 -1.3257 -0.3995 0.0876 -0.3349 ...\r## ..$ z: num [1:100] 0.762 -0.196 -0.26 1.568 1.009 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] 1.5431 -0.0135 1.3621 2.2513 1.4092 ...\r## ..$ y: num [1:100] 0.923 -0.975 -0.369 -0.254 -1.433 ...\r## ..$ z: num [1:100] -1.3211 -0.0527 -0.4336 0.2069 -1.1874 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.306 2.702 0.904 -0.335 0.443 ...\r## ..$ y: num [1:100] 1.109 1.646 0.558 1.918 0.521 ...\r## ..$ z: num [1:100] 1.276 0.579 2.159 -0.144 1.069 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.753 0.96 2.231 -1.145 1.338 ...\r## ..$ y: num [1:100] 0.894 1.526 2.123 -0.968 1.732 ...\r## ..$ z: num [1:100] -1.849 1.123 -0.23 0.19 0.459 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r new_df \u0026lt;- reduce(dfs, bind_rows)\rnew_df\r ## # A tibble: 400 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.142 -0.924 0.762 ## 2 0.405 -1.33 -0.196 ## 3 -0.0639 -0.399 -0.260 ## 4 -0.0699 0.0876 1.57 ## 5 0.827 -0.335 1.01 ## 6 0.187 0.419 -0.442 ## 7 1.14 -0.224 -0.0744\r## 8 -0.514 -1.27 0.896 ## 9 0.645 0.510 1.10 ## 10 -0.810 -0.246 0.589 ## # ... with 390 more rows\r O resultado é o mesmo observado em map_dfr, mas essa abordagem é genérica, ou seja, ela se aplica para qualquer grupo de objetos e para qualquer função que recebe dois argumentos e precisa ser repetida de maneira recursiva.\n# Apaga os arquivos pra eles não ficarem ai gastando memória a toa\rfile.remove(paths)\r ## [1] TRUE TRUE TRUE TRUE\r pluck Esta função é um atalho para as tesouras duplas do r [[. Seu objeto é facilitar a leitura de códigos que pescam elementos profundos de uma lista aninhada.\nl \u0026lt;- list(\rlist(-1, x = 1, y = c(2), z = \u0026quot;a\u0026quot;),\rlist(-2, x = 4, y = c(5, 6), z = \u0026quot;b\u0026quot;),\rlist(-3, x = 8, y = c(9, 10, 11))\r)\rglimpse(l)\r ## List of 3\r## $ :List of 4\r## ..$ : num -1\r## ..$ x: num 1\r## ..$ y: num 2\r## ..$ z: chr \u0026quot;a\u0026quot;\r## $ :List of 4\r## ..$ : num -2\r## ..$ x: num 4\r## ..$ y: num [1:2] 5 6\r## ..$ z: chr \u0026quot;b\u0026quot;\r## $ :List of 3\r## ..$ : num -3\r## ..$ x: num 8\r## ..$ y: num [1:3] 9 10 11\r Se você chamar map_ nessa lista, você pode extrair os elementos delas pelo nome.\nmap_dbl(l, \u0026quot;x\u0026quot;)\r ## [1] 1 4 8\r map(l, \u0026quot;y\u0026quot;)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r map(l, \u0026quot;z\u0026quot;)\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r Ou pela posição na lista\nmap_dbl(l, 1)\r ## [1] -1 -2 -3\r map_dbl(l, 2)\r ## [1] 1 4 8\r map(l, 3)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r Ou os dois\nmap_dbl(l, list(\u0026quot;x\u0026quot;, 1))\r ## [1] 1 4 8\r map(l, list(\u0026quot;z\u0026quot;, 1))\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r map(l, list(\u0026quot;y\u0026quot;, 3))\r ## [[1]]\r## NULL\r## ## [[2]]\r## NULL\r## ## [[3]]\r## [1] 11\r Se um componente não existir, você recebe um erro\nmap_chr(l, \u0026quot;z\u0026quot;)\r ## Error: Result 3 must be a single string, not NULL of length 0\r Mas você pode resolver isso passando um valor padrão\nmap_chr(l, \u0026quot;z\u0026quot;, .default = NA_character_)\r ## [1] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; NA\r Tudo isso funciona com base na função pluck\npluck(l, 1)\r ## [[1]]\r## [1] -1\r## ## $x\r## [1] 1\r## ## $y\r## [1] 2\r## ## $z\r## [1] \u0026quot;a\u0026quot;\r pluck(l, 1, 2)\r ## [1] 1\r pluck(l, 2, 3)\r ## [1] 5 6\r pluck(l, 1, \u0026quot;x\u0026quot;)\r ## [1] 1\r pluck(l, 2, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;b\u0026quot;\r pluck(l, 3, \u0026quot;y\u0026quot;)\r ## [1] 9 10 11\r Exercícios   Utilize uma das funções map_ para:\n  Calcular a média de cada coluna em mtcars.\n  Determinar o tipo de cada coluna em flights.\n  Computar o número de valores únicos em cada coluna de iris.\n  Gere 10 distribuições aleatórias (rnorm) com médias -10, 0, 10 e 100.\n  Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?\n  Usando as funções predicado keep e discard:\n  Selecione todas as colunas caractere no banco flights.\n  Descarte os caracteres em mpg.\n  Selecione os fatores ordenados em diamonds.\n  Descarte as variáveis não-numéricas em iris\n  Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.\n  Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.\n  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"8fc2c9a43ba39b58554f36d137f8df4b","permalink":"https://laddem.github.io/courses/tidyverse/dia4/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia4/","section":"courses","summary":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.","tags":null,"title":"purrr","type":"book"},{"authors":null,"categories":null,"content":"Soluções dos exercícios.\nreadr, tibble, tidyr # Não esqueça dos pacotes!\rlibrary(tidyverse)\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Primeiro, é bom verificar como estão dispostas as informações no arquivo texto\nread_lines(file, n_max = 10)\r ## [1] \u0026quot;ALFA ROMEO ALFA ROMEO 78010003\u0026quot;\r## [2] \u0026quot;ALFETTA 03 81 8 74 7 89 9 ALFETTA 78010053\u0026quot;\r## [3] \u0026quot;SPIDER 2000 01 SPIDER 2000 78010103\u0026quot;\r## [4] \u0026quot;AMC AMC 78020002\u0026quot;\r## [5] \u0026quot;GREMLIN 03 79 9 79 9 GREMLIN 78020053\u0026quot;\r## [6] \u0026quot;PACER 04 89 11 89 11 PACER 78020103\u0026quot;\r## [7] \u0026quot;PACER WAGON 07 90 26 91 26 PACER WAGON 78020153\u0026quot;\r## [8] \u0026quot;CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 78020203\u0026quot;\r## [9] \u0026quot;CONCORD WAGON 07 91 30 91 30 CONCORD WAGON 78020253\u0026quot;\r## [10] \u0026quot;MATADOR COUPE 05 97 14 97 14 MATADOR COUPE 78020303\u0026quot;\r Ao identificar que se trata de um arquivo colunado, mas que as colunas são separadas por espaços, escolho o read_fwf com o fwf_empty.\ndic \u0026lt;- fwf_empty(file)\rdf \u0026lt;- read_fwf(file, col_positions = dic)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_double(),\r## X4 = col_double(),\r## X5 = col_double(),\r## X6 = col_double(),\r## X7 = col_double(),\r## X8 = col_double(),\r## X9 = col_double(),\r## X10 = col_double(),\r## X11 = col_character(),\r## X12 = col_double()\r## )\r df\r ## # A tibble: 20 x 12\r## X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 ALFA RO~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ALFA R~ 7.80e7\r## 2 ALFETTA 03 81 8 74 7 89 9 NA NA ALFETTA 7.80e7\r## 3 SPIDER ~ 01 NA NA NA NA NA NA NA NA SPIDER~ 7.80e7\r## 4 AMC \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AMC 7.80e7\r## 5 GREMLIN 03 79 9 NA NA NA NA 79 9 GREMLIN 7.80e7\r## 6 PACER 04 89 11 NA NA NA NA 89 11 PACER 7.80e7\r## 7 PACER W~ 07 90 26 91 26 NA NA NA NA PACER ~ 7.80e7\r## 8 CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 7.80e7\r## 9 CONCORD~ 07 91 30 NA NA 91 30 NA NA CONCOR~ 7.80e7\r## 10 MATADOR~ 05 97 14 97 14 NA NA NA NA MATADO~ 7.80e7\r## 11 MATADOR~ 06 110 20 NA NA 110 20 NA NA MATADO~ 7.80e7\r## 12 MATADOR~ 09 112 50 NA NA 112 50 NA NA MATADO~ 7.80e7\r## 13 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 14 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 15 AUDI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AUDI 7.81e7\r## 16 FOX 03 84 11 84 11 84 11 NA NA FOX 7.81e7\r## 17 FOX WAG~ 07 83 40 NA NA 83 40 NA NA FOX WA~ 7.81e7\r## 18 5000 04 90 15 NA NA 90 15 NA NA 5000 7.81e7\r## 19 AVANTI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AVANTI 7.81e7\r## 20 AVANTI ~ 02 75 8 75 8 NA NA NA NA AVANTI~ 7.81e7\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  Ao verificar as primeiras 10 linhas do banco, podemos notar algo estranho\nfile \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\rread_lines(file, n_max = 10)\r ## [1] \u0026quot;x,y\u0026quot; \u0026quot;404,NA\u0026quot; \u0026quot;4172,NA\u0026quot; \u0026quot;3004,NA\u0026quot; \u0026quot;787,NA\u0026quot; \u0026quot;37,NA\u0026quot; \u0026quot;2332,NA\u0026quot;\r## [8] \u0026quot;2489,NA\u0026quot; \u0026quot;1449,NA\u0026quot; \u0026quot;3665,NA\u0026quot;\r Parece ser um arquivo csv comum, com duas colunas, mas uma delas parece ter apenas NAs. Se a gente proceder com a importação padrão, chegaremos em\ndf \u0026lt;- read_csv(file)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_logical()\r## )\r ## Warning: 1000 parsing failures.\r## row col expected actual file\r## 1001 y 1/0/T/F/TRUE/FALSE 2015-01-16 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1002 y 1/0/T/F/TRUE/FALSE 2018-05-18 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1003 y 1/0/T/F/TRUE/FALSE 2015-09-05 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1004 y 1/0/T/F/TRUE/FALSE 2012-11-28 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1005 y 1/0/T/F/TRUE/FALSE 2020-01-13 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## .... ... .................. .......... ........................................................................\r## See problems(...) for more details.\r df\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;lgl\u0026gt;\r## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r No console de vocês, deve aparecer que foram importadas as colunas x como double e y como logical. Mas uma chuva de \u0026ldquo;parsing failures\u0026rdquo;, indicando que expected = 1/0/T/F/TRUE/FALSE, actual = 2015-01-16.\nNa verdade, ao tentar adivinhar o tipo de colunas, o readr lê as primeiras 1000 observações em busca de um padrão. Você pode resolver esse problema:\n# 1. Aumentando o número de observações utilizadas para adivinhar as colunas\rdf \u0026lt;- read_csv(file, guess_max = 1001)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_date(format = \u0026quot;\u0026quot;)\r## )\r # A específicação da coluna Y agora é \u0026lt;date\u0026gt;\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r # 2. escolhendo diretamente o tipo de coluna antes da importação\rtipos \u0026lt;- cols(\ry = col_date()\r)\rdf \u0026lt;- read_csv(file, col_types = tipos)\r# Mesmo resultado\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r É sempre bom começar planejando o banco que queremos construir. Queremos um banco que tenha 3 variáveis: o nome, o tipo de prova aplicada e a nota de cada aluno. Para isso, precisamos colocar os nomes das colunas teste1, teste2 e prova1 numa variável e os valores das células em outra. Vamos chamar essas colunas de \u0026ldquo;avaliação\u0026rdquo; e \u0026ldquo;nota\u0026rdquo;, elas formam um par.\nAgora vamos chamar pivot_wider e especificar esses argumentos.\nsala_aula %\u0026gt;% pivot_longer(\r# Primeiro, identificamos as colunas que serão modificadas\rcols = c(teste1, teste2, prova1),\r# Agora, indicamos os nomes das colunas que receberão\r# os nomes das colunas transformadas\rnames_to = \u0026quot;avaliacao\u0026quot;,\r# os valores das células\rvalues_to = \u0026quot;nota\u0026quot;\r)\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r O banco relig_income parece ter uma organização em que temos 2 variáveis, mas uma delas está numa coluna \u0026ldquo;religion\u0026rdquo; e a outra está em 10 colunas, \u0026ldquo;income\u0026rdquo;. Queremos um banco que tenha 3 colunas: a religião, o nível de renda, e o número de pessoas em cada combinação das duas primeiras.\nComo no exerício anterior, vamos chamar pivot_longer e especificar\nrelig_income %\u0026gt;% pivot_longer(\r# As colunas a serem modificadas, notem o uso de ':' para selecionar várias\r# colunas em sequência\rcols = `\u0026lt;$10k`:`Don't know/refused`,\r# Variável recebe os nomes da antiga coluna\rnames_to = \u0026quot;nivel_renda\u0026quot;,\r# Variável recebe os valores das células\rvalues_to = \u0026quot;contagem\u0026quot;\r)\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.   Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\n billboard\r ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r Da mesma forma como fizemos nos anteriores, queremos transformar as várias wk1:wk76 em um par de colunas, uma que me diga a semana e a outra que me diga em que posição no ranking a música estava.\nbillboard %\u0026gt;% pivot_longer(\r# Colunas que serão transformadas\rcols = wk1:wk76,\r# Nome da variável que receberá os nomes das colunas\rnames_to = \u0026quot;semana\u0026quot;,\r# Nome da variável que receberá os valores das células\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\r# Nesse caso, uso o argumento opcional para eliminar os NAs\rvalues_drop_na = TRUE\r# Experimente mudar este argumento para FALSE e veja o resultado\r# Quando uma música não está mais nas paradas, ela recebe NA. Acho\r# justificado excluir os NAs nesse caso.\r)\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?  Vou começar enxugando os códigos anteriores para criar os resultados que produzimos e salvá-los em objetos.\nsala_aula_long \u0026lt;- sala_aula %\u0026gt;% pivot_longer(\rcols = c(teste1, teste2, prova1),\rnames_to = \u0026quot;avaliacao\u0026quot;,\rvalues_to = \u0026quot;nota\u0026quot;\r)\rrelig_income_long \u0026lt;- relig_income %\u0026gt;% pivot_longer(\rcols = `\u0026lt;$10k`:`Don't know/refused`,\rnames_to = \u0026quot;nivel_renda\u0026quot;,\rvalues_to = \u0026quot;contagem\u0026quot;\r)\rbillboard_long \u0026lt;- billboard %\u0026gt;% pivot_longer(\rcols = wk1:wk76,\rnames_to = \u0026quot;semana\u0026quot;,\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\rvalues_drop_na = TRUE\r)\rsala_aula_long\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r relig_income_long\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r billboard_long\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r O caminho inverso desses bancos de dados, é utilizar pivot_wider. Aqui, vamos escolher um par de colunas que contém:\n O nome das colunas que queremos criar O valor que queremos passar para as células dessas novas colunas  Vamos ver exemplos comentados como no anterior\nsala_aula_long %\u0026gt;% pivot_wider(\r# Aqui, identificamos colunas que NÃO SERÃO MODIFICADAS\r# É o contrário de pivot_longer. Por padrão, são todas as que não são\r# mencionadas na transformação, mas para deixar bem claro, # vou deixar explícito.\rid_cols = name,\r# Variável com os nomes para as novas colunas\rnames_from = avaliacao,\r# Variável com os valores para as células\rvalues_from = nota\r)\r ## # A tibble: 4 x 4\r## name teste1 teste2 prova1\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Billy \u0026lt;NA\u0026gt; D C ## 2 Suzy F \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; ## 3 Lionel B C B ## 4 Jenny A A B\r relig_income_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = religion,\r# Variável com os nomes para as novas colunas\rnames_from = nivel_renda,\r# Variável com os valores para as células\rvalues_from = contagem\r)\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r billboard_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = c(artist, track, date.entered),\r# Variável com os nomes para as novas colunas\rnames_from = semana,\r# Variável com os valores para as células\rvalues_from = posicao_rank\r)\r ## # A tibble: 317 x 68\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 57 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;\r Tanto pivot_longer quanto pivot_wider tem mais argumentos para lidar com situações complexas, como quando você precisa aplicar transformações em variáveis antes de reformatar o banco ou precisa utilizar múltiplas colunas, mas eu deixo isso para vocês descobrirem por conta própria quando estiverem confortáveis com a sintaxe básica.\nO que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r Por padrão, separate espera que todas as colunas sendo separadas tenham o mesmo comprimento. Por exemplo, no primeiro caso, indicamos que vamos criar três novas colunas, chamadas de \u0026ldquo;um\u0026rdquo;, \u0026ldquo;dois\u0026rdquo; e \u0026ldquo;tres\u0026rdquo;. Mas os vetores tem tamanhos diferentes. Um deles tem 4 letras ao invés de 3. No segundo exemplo, um deles tem duas letras ao invés de três. Esse tipo de situação é bastante comum quando lidamos com erros de digitação. Então, o que fazer com o elemento que está sobrando ou faltando?\n# Sobrando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;warn\u0026quot;) # avise que ocorreu (padrão)\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;drop\u0026quot;) # descarte o que sobrou\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;merge\u0026quot;) # junte com o último\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f,g ## 3 h i j\r # Note especialmente no último caso o que ocorreu com as colunas.\r# Faltando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;warn\u0026quot;) # avise e preencha a direita\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;left\u0026quot;) # preencha a esquerda\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 \u0026lt;NA\u0026gt; d e ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;right\u0026quot;) # preencha a direta\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r # Note na sua saída do R como ficou a tibble e onde foram colocados NAs\r# em cada caso\r Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?  Acho que a melhor forma de compreender isso é utilizar um banco de dados. Vamos pegar aquele da população retirado da Wikipédia.\npopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Vamos ver dois exemplos, um com unite e outro com separate para exemplificar o que remove faz.\n# Unir as colunas Day, Month, Year, remove = TRUE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = TRUE) # padrão\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19_May_20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19_May_20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31_Dec_20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19_May_20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19_May_20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1_Jan_2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2_Mar_2020 2020 census result[9]\r # Unir as colunas Day, Month, Year, remove = FALSE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = FALSE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Data Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_~ 1 Nov 2020 Seventh Ce~\r## 2 2 India 1377123716 17.5% 19_May~ 19 May 2021 National p~\r## 3 3 United S~ 331695937 4.22% 19_May~ 19 May 2021 National p~\r## 4 4 Indonesia 271350000 3.45% 31_Dec~ 31 Dec 2020 National a~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_~ 1 Jul 2021 UN project~\r## 6 6 Brazil 213154869 2.71% 19_May~ 19 May 2021 National p~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_~ 1 Jul 2021 UN project~\r## 8 8 Banglade~ 170689832 2.17% 19_May~ 19 May 2021 National p~\r## 9 9 Russia 146171015 1.86% 1_Jan_~ 1 Jan 2021 National a~\r## 10 10 Mexico 126014024 1.60% 2_Mar_~ 2 Mar 2020 2020 censu~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Agora com separate: Separar a coluna year em século e ano, apenas como exemplo\n# remove = TRUE, padrão\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = TRUE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Day Month seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 20 20 Seventh Cen~\r## 2 2 India 1377123716 17.5% 19 May 20 21 National po~\r## 3 3 United S~ 331695937 4.22% 19 May 20 21 National po~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20 20 National an~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 20 21 UN projecti~\r## 6 6 Brazil 213154869 2.71% 19 May 20 21 National po~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 20 21 UN projecti~\r## 8 8 Banglade~ 170689832 2.17% 19 May 20 21 National po~\r## 9 9 Russia 146171015 1.86% 1 Jan 20 21 National an~\r## 10 10 Mexico 126014024 1.60% 2 Mar 20 20 2020 census~\r # remove = FALSE\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = FALSE)\r ## # A tibble: 10 x 10\r## Rank Country Population `% of world` Day Month Year seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 20 20 Sevent~\r## 2 2 India 1377123716 17.5% 19 May 2021 20 21 Nation~\r## 3 3 United ~ 331695937 4.22% 19 May 2021 20 21 Nation~\r## 4 4 Indones~ 271350000 3.45% 31 Dec 2020 20 20 Nation~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 20 21 UN pro~\r## 6 6 Brazil 213154869 2.71% 19 May 2021 20 21 Nation~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 20 21 UN pro~\r## 8 8 Banglad~ 170689832 2.17% 19 May 2021 20 21 Nation~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 20 21 Nation~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 20 20 2020 c~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Eu gosto de utilizar esse argumento quando eu tenho dúvida sobre o resultado e quero fazer inspeção visual para detectar eventuais problemas na separação ou junção. Uma vez que estou satisfeito com o resultado, em geral eu uso o remove=TRUE. Vocês tem que decidir se precisam manter as colunas originais ou se a coluna transformada é o suficiente.\nCompare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?  A resposta curta é simples: em pivot_wider, podemos ter aqueles missings \u0026ldquo;implícitos\u0026rdquo; que não apareciam no nosso banco longo e, durante a transformação, eles viram NAs nas colunas. Ó argumento values_fill indica um valor para ser preenchido no lugar de NA.\nEm complete, temos uma situação similar. O que fazer quando for encontrada uma combinação de valores no banco longo que é um \u0026ldquo;missing implícito\u0026rdquo;? Você pode especificar um valor padrão para preenchê-lo.\nSão funções similares, mas uma funciona sem reformatar o banco e a outra durante o processo de reformatação. Veja um exemplo abaixo com aquela tibble das ações.\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\racoes\r ## # A tibble: 7 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 2 0.92\r## 6 2016 3 0.17\r## 7 2016 4 2.66\r # Vamos supor que o NA implícito significa que a empresa teve # lucro = 0 naquele quadrimestre.\r# pivot_wider, values_fill\racoes %\u0026gt;% pivot_wider(\rid_cols = ano,\rnames_from = qdr,\rvalues_from = lucro,\rvalues_fill = 0\r)\r ## # A tibble: 2 x 5\r## ano `1` `2` `3` `4`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1.88 0.59 0.35 NA ## 2 2016 0 0.92 0.17 2.66\r # complete, fill\racoes %\u0026gt;% complete(ano, qdr, fill = list(lucro = 0))\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 0 ## 5 2016 1 0 ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Note o resultado. E note também que values_fill em pivot_wider é um pouco mais criterioso na hora de fazer as transformações.\nstringr, forcats e dplyr library(nycflights13)\r   Encontre os vôos que:\n  Atrasaram mais de duas horas\n  flights %\u0026gt;% filter(dep_delay \u0026gt; 120)\r ## # A tibble: 9,723 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 848 1835 853 1001 1950\r## 2 2013 1 1 957 733 144 1056 853\r## 3 2013 1 1 1114 900 134 1447 1222\r## 4 2013 1 1 1540 1338 122 2020 1825\r## 5 2013 1 1 1815 1325 290 2120 1542\r## 6 2013 1 1 1842 1422 260 1958 1535\r## 7 2013 1 1 1856 1645 131 2212 2005\r## 8 2013 1 1 1934 1725 129 2126 1855\r## 9 2013 1 1 1938 1703 155 2109 1823\r## 10 2013 1 1 1942 1705 157 2124 1830\r## # ... with 9,713 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Com destino a Houston (IAH ou HOU)  flights %\u0026gt;% filter(dest %in% c(\u0026quot;IAH\u0026quot;, \u0026quot;HOU\u0026quot;))\r ## # A tibble: 9,313 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 623 627 -4 933 932\r## 4 2013 1 1 728 732 -4 1041 1038\r## 5 2013 1 1 739 739 0 1104 1038\r## 6 2013 1 1 908 908 0 1228 1219\r## 7 2013 1 1 1028 1026 2 1350 1339\r## 8 2013 1 1 1044 1045 -1 1352 1351\r## 9 2013 1 1 1114 900 134 1447 1222\r## 10 2013 1 1 1205 1200 5 1503 1505\r## # ... with 9,303 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Operados pela United, American ou Delta  unique(flights$carrier)\r ## [1] \u0026quot;UA\u0026quot; \u0026quot;AA\u0026quot; \u0026quot;B6\u0026quot; \u0026quot;DL\u0026quot; \u0026quot;EV\u0026quot; \u0026quot;MQ\u0026quot; \u0026quot;US\u0026quot; \u0026quot;WN\u0026quot; \u0026quot;VX\u0026quot; \u0026quot;FL\u0026quot; \u0026quot;AS\u0026quot; \u0026quot;9E\u0026quot; \u0026quot;F9\u0026quot; \u0026quot;HA\u0026quot; \u0026quot;YV\u0026quot;\r## [16] \u0026quot;OO\u0026quot;\r flights %\u0026gt;% filter(carrier %in% c(\u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;DL\u0026quot;))\r ## # A tibble: 139,504 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 554 600 -6 812 837\r## 5 2013 1 1 554 558 -4 740 728\r## 6 2013 1 1 558 600 -2 753 745\r## 7 2013 1 1 558 600 -2 924 917\r## 8 2013 1 1 558 600 -2 923 937\r## 9 2013 1 1 559 600 -1 941 910\r## 10 2013 1 1 559 600 -1 854 902\r## # ... with 139,494 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre julho e setembro  flights %\u0026gt;% filter(between(month, 7, 9))\r ## # A tibble: 86,326 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 7 1 1 2029 212 236 2359\r## 2 2013 7 1 2 2359 3 344 344\r## 3 2013 7 1 29 2245 104 151 1\r## 4 2013 7 1 43 2130 193 322 14\r## 5 2013 7 1 44 2150 174 300 100\r## 6 2013 7 1 46 2051 235 304 2358\r## 7 2013 7 1 48 2001 287 308 2305\r## 8 2013 7 1 58 2155 183 335 43\r## 9 2013 7 1 100 2146 194 327 30\r## 10 2013 7 1 100 2245 135 337 135\r## # ... with 86,316 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Chegaram com mais de duas horas de atraso, mas não decolaram com atraso  flights %\u0026gt;% filter(arr_delay \u0026gt; 120, dep_delay \u0026lt;= 0)\r ## # A tibble: 29 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 27 1419 1420 -1 1754 1550\r## 2 2013 10 7 1350 1350 0 1736 1526\r## 3 2013 10 7 1357 1359 -2 1858 1654\r## 4 2013 10 16 657 700 -3 1258 1056\r## 5 2013 11 1 658 700 -2 1329 1015\r## 6 2013 3 18 1844 1847 -3 39 2219\r## 7 2013 4 17 1635 1640 -5 2049 1845\r## 8 2013 4 18 558 600 -2 1149 850\r## 9 2013 4 18 655 700 -5 1213 950\r## 10 2013 5 22 1827 1830 -3 2217 2010\r## # ... with 19 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo  flights %\u0026gt;% filter(dep_delay \u0026gt; 60, dep_delay - arr_delay \u0026gt;= 30)\r ## # A tibble: 2,046 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 1716 1545 91 2140 2039\r## 2 2013 1 1 2205 1720 285 46 2040\r## 3 2013 1 1 2326 2130 116 131 18\r## 4 2013 1 3 1503 1221 162 1803 1555\r## 5 2013 1 3 1821 1530 171 2131 1910\r## 6 2013 1 3 1839 1700 99 2056 1950\r## 7 2013 1 3 1850 1745 65 2148 2120\r## 8 2013 1 3 1923 1815 68 2036 1958\r## 9 2013 1 3 1941 1759 102 2246 2139\r## 10 2013 1 3 1950 1845 65 2228 2227\r## # ... with 2,036 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre a meia-noite e 6 da manhã (inclusive)  flights %\u0026gt;% filter(between(hour, 0, 5) | (hour == 6 \u0026amp; minute == 0))\r ## # A tibble: 8,970 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 8,960 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).  flights %\u0026gt;% select(air_time, distance) %\u0026gt;% mutate(speed = distance/air_time) %\u0026gt;% arrange(desc(speed))\r ## # A tibble: 336,776 x 3\r## air_time distance speed\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 65 762 11.7 ## 2 93 1008 10.8 ## 3 55 594 10.8 ## 4 70 748 10.7 ## 5 105 1035 9.86\r## 6 170 1598 9.4 ## 7 172 1598 9.29\r## 8 175 1623 9.27\r## 9 173 1598 9.24\r## 10 173 1598 9.24\r## # ... with 336,766 more rows\r Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.  flights %\u0026gt;% select(dep_time, dep_delay, arr_time, arr_delay)\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(matches(\u0026quot;^arr|^dep\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(!starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;car\u0026quot;)) \u0026amp; contains(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(ends_with(c(\u0026quot;time\u0026quot;, \u0026quot;delay\u0026quot;)) \u0026amp; !starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;air\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time arr_time dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 830 2 11\r## 2 533 850 4 20\r## 3 542 923 2 33\r## 4 544 1004 -1 -18\r## 5 554 812 -6 -25\r## 6 554 740 -4 12\r## 7 555 913 -5 19\r## 8 557 709 -3 -14\r## 9 557 838 -3 -8\r## 10 558 753 -2 8\r## # ... with 336,766 more rows\r As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.  flights %\u0026gt;% mutate(\rdep_hour = dep_time %/% 100,\rdep_minute = dep_time %% 100,\rsched_dep_hour = sched_dep_time %/% 100,\rsched_arr_minute = sched_arr_time %% 100\r)\r ## # A tibble: 336,776 x 23\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 15 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;,\r## # dep_hour \u0026lt;dbl\u0026gt;, dep_minute \u0026lt;dbl\u0026gt;, sched_dep_hour \u0026lt;dbl\u0026gt;,\r## # sched_arr_minute \u0026lt;dbl\u0026gt;\r # Há uma outra solução com separate!\rflights %\u0026gt;% separate(\rcol = dep_time,\rinto = c(\u0026quot;dep_hour\u0026quot;, \u0026quot;dep_minute\u0026quot;),\rsep = 1,\r# Esse argumento é importante! Teste com FALSE para ver a diferença\rconvert = TRUE) %\u0026gt;% separate(\rcol = sched_dep_time,\rinto = c(\u0026quot;sched_dep_hour\u0026quot;, \u0026quot;sched_dep_minute\u0026quot;),\rsep = 1,\rconvert = TRUE)\r ## # A tibble: 336,776 x 21\r## year month day dep_hour dep_minute sched_dep_hour sched_dep_minute\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 17 5 15\r## 2 2013 1 1 5 33 5 29\r## 3 2013 1 1 5 42 5 40\r## 4 2013 1 1 5 44 5 45\r## 5 2013 1 1 5 54 6 0\r## 6 2013 1 1 5 54 5 58\r## 7 2013 1 1 5 55 6 0\r## 8 2013 1 1 5 57 6 0\r## 9 2013 1 1 5 57 6 0\r## 10 2013 1 1 5 58 6 0\r## # ... with 336,766 more rows, and 14 more variables: dep_delay \u0026lt;dbl\u0026gt;,\r## # arr_time \u0026lt;int\u0026gt;, sched_arr_time \u0026lt;int\u0026gt;, arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Existe uma outra solução possível para essa questão usando manipulação de strings, com str_sub também. Fica como desafio!\nPensando na legibilidade do código e na flexibilidade da abordagem, qual das duas soluções acima você implementaria? mutate ou duas separate? Reflita.\nO que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Essa tem uma resposta mais qualitativa. A primeira parte é parecida com a questão anterior, mas estamos manualmente tentando calcular os tempos de viagem. Acontece que os valores não batem com os tempos de vôo identificados no banco. Isso se deve a pelo menos três questões distintas.\n Uma delas diz respeito ao registro dos tempos, a definição de air_time pode não estar considerando tempos em que o avião está manobrando ou em solo ou mesmo podem existir erros de preenchimento. A segunda diz respeito ao fuso horário distinto entre aeroportos de saída e chegada, que complica o cálculo dos tempos reais, então nosso cálculo está muito cru para identificar isso. A última questão são os vôos longos, que começam em um dia e terminam no dia seguinte, que podem prejudicar nosso método de cálculo. Para corrigir alguns desses problemas, você precisaria escrever um código que minimamente levasse essas questões em consideração. Como esse não é o objetivo do curso, eu deixo para quem quiser tentar. Há uma solução postada aqui.  Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\rstr_c(z, w, y, sep = \u0026quot; \u0026quot;) %\u0026gt;% str_c(x, sep = \u0026quot;\u0026quot;) %\u0026gt;% str_to_sentence()\r ## [1] \u0026quot;Hoje acordei feliz.\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r# Sem dplyr\rdf$pais \u0026lt;- str_to_title(df$pais)\rdf$primeiro_nome \u0026lt;- str_to_title(df$primeiro_nome)\rdf$segundo_nome \u0026lt;- str_to_title(df$segundo_nome)\rdf \u0026lt;- df %\u0026gt;% tidyr::unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;)\rdf[ str_order(df$nomes), ]\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r # Com dplyr\rdf \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\rdf %\u0026gt;% mutate(pais = str_to_title(pais),\rprimeiro_nome = str_to_title(primeiro_nome),\rsegundo_nome = str_to_title(segundo_nome)) %\u0026gt;% unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;) %\u0026gt;% arrange(str_order(nomes))\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r x \u0026lt;- c(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\rx[1] \u0026lt;- str_sub(x[1], 1, 1) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[2] \u0026lt;- str_sub(x[2], 4, 4) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[3] \u0026lt;- str_to_upper(x[3])\rstr_c(c(x[3], x[1], x[2]), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;MAIA V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: \u0026ldquo;150\u0026rdquo;, \u0026ldquo;219\u0026rdquo;, \u0026ldquo;312\u0026rdquo;, \u0026ldquo;471\u0026rdquo;. Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;118\u0026quot; \u0026quot;114\u0026quot; \u0026quot;118\u0026quot; \u0026quot;120\u0026quot; \u0026quot;109\u0026quot; \u0026quot;104\u0026quot; \u0026quot;114\u0026quot; \u0026quot;117\u0026quot; \u0026quot;122\u0026quot; \u0026quot;109\u0026quot; \u0026quot;110\u0026quot; \u0026quot;113\u0026quot;\r## [13] \u0026quot;106\u0026quot; \u0026quot;100\u0026quot; \u0026quot;122\u0026quot; \u0026quot;121\u0026quot; \u0026quot;124\u0026quot; \u0026quot;124\u0026quot; \u0026quot;110\u0026quot; \u0026quot;100\u0026quot; \u0026quot;117\u0026quot; \u0026quot;119\u0026quot; \u0026quot;105\u0026quot; \u0026quot;118\u0026quot;\r## [25] \u0026quot;122\u0026quot; \u0026quot;201\u0026quot; \u0026quot;205\u0026quot; \u0026quot;212\u0026quot; \u0026quot;216\u0026quot; \u0026quot;228\u0026quot; \u0026quot;213\u0026quot; \u0026quot;227\u0026quot; \u0026quot;221\u0026quot; \u0026quot;214\u0026quot; \u0026quot;227\u0026quot; \u0026quot;206\u0026quot;\r## [37] \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;224\u0026quot; \u0026quot;223\u0026quot; \u0026quot;203\u0026quot; \u0026quot;221\u0026quot; \u0026quot;215\u0026quot; \u0026quot;225\u0026quot; \u0026quot;210\u0026quot; \u0026quot;208\u0026quot; \u0026quot;219\u0026quot; \u0026quot;207\u0026quot;\r## [49] \u0026quot;221\u0026quot; \u0026quot;227\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;301\u0026quot; \u0026quot;304\u0026quot; \u0026quot;310\u0026quot; \u0026quot;307\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;308\u0026quot; \u0026quot;306\u0026quot;\r## [61] \u0026quot;308\u0026quot; \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;306\u0026quot; \u0026quot;302\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;301\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;304\u0026quot;\r## [73] \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;307\u0026quot; \u0026quot;401\u0026quot; \u0026quot;459\u0026quot; \u0026quot;429\u0026quot; \u0026quot;435\u0026quot; \u0026quot;435\u0026quot; \u0026quot;415\u0026quot; \u0026quot;475\u0026quot; \u0026quot;414\u0026quot; \u0026quot;419\u0026quot;\r## [85] \u0026quot;495\u0026quot; \u0026quot;475\u0026quot; \u0026quot;431\u0026quot; \u0026quot;460\u0026quot; \u0026quot;478\u0026quot; \u0026quot;447\u0026quot; \u0026quot;436\u0026quot; \u0026quot;412\u0026quot; \u0026quot;403\u0026quot; \u0026quot;423\u0026quot; \u0026quot;467\u0026quot; \u0026quot;438\u0026quot;\r## [97] \u0026quot;475\u0026quot; \u0026quot;467\u0026quot; \u0026quot;418\u0026quot; \u0026quot;476\u0026quot;\r # Esse exercício é um pouco mais difícil mesmo!\rx %\u0026gt;% str_extract(\u0026quot;\\\\d\u0026quot;)\r ## [1] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot;\r## [19] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot;\r## [37] \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [55] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [73] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r## [91] \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r tibble(\rtipo_idade = str_sub(x, 1, 1),\ridade = str_sub(x, 2, 3),\ridade_anos =\rif_else(\rstr_detect(tipo_idade, \u0026quot;1\u0026quot;),\ras.numeric(idade) / (24 * 30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;2\u0026quot;),\ras.numeric(idade) / (30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;3\u0026quot;),\ras.numeric(idade) / 12,\ras.numeric(idade)\r)\r)\r)\r) %\u0026gt;% print(n = Inf)\r ## # A tibble: 100 x 3\r## tipo_idade idade idade_anos\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 18 0.00208 ## 2 1 14 0.00162 ## 3 1 18 0.00208 ## 4 1 20 0.00231 ## 5 1 09 0.00104 ## 6 1 04 0.000463\r## 7 1 14 0.00162 ## 8 1 17 0.00197 ## 9 1 22 0.00255 ## 10 1 09 0.00104 ## 11 1 10 0.00116 ## 12 1 13 0.00150 ## 13 1 06 0.000694\r## 14 1 00 0 ## 15 1 22 0.00255 ## 16 1 21 0.00243 ## 17 1 24 0.00278 ## 18 1 24 0.00278 ## 19 1 10 0.00116 ## 20 1 00 0 ## 21 1 17 0.00197 ## 22 1 19 0.00220 ## 23 1 05 0.000579\r## 24 1 18 0.00208 ## 25 1 22 0.00255 ## 26 2 01 0.00278 ## 27 2 05 0.0139 ## 28 2 12 0.0333 ## 29 2 16 0.0444 ## 30 2 28 0.0778 ## 31 2 13 0.0361 ## 32 2 27 0.075 ## 33 2 21 0.0583 ## 34 2 14 0.0389 ## 35 2 27 0.075 ## 36 2 06 0.0167 ## 37 2 07 0.0194 ## 38 2 15 0.0417 ## 39 2 24 0.0667 ## 40 2 23 0.0639 ## 41 2 03 0.00833 ## 42 2 21 0.0583 ## 43 2 15 0.0417 ## 44 2 25 0.0694 ## 45 2 10 0.0278 ## 46 2 08 0.0222 ## 47 2 19 0.0528 ## 48 2 07 0.0194 ## 49 2 21 0.0583 ## 50 2 27 0.075 ## 51 3 10 0.833 ## 52 3 05 0.417 ## 53 3 01 0.0833 ## 54 3 04 0.333 ## 55 3 10 0.833 ## 56 3 07 0.583 ## 57 3 05 0.417 ## 58 3 09 0.75 ## 59 3 08 0.667 ## 60 3 06 0.5 ## 61 3 08 0.667 ## 62 3 05 0.417 ## 63 3 04 0.333 ## 64 3 03 0.25 ## 65 3 06 0.5 ## 66 3 02 0.167 ## 67 3 10 0.833 ## 68 3 06 0.5 ## 69 3 01 0.0833 ## 70 3 10 0.833 ## 71 3 06 0.5 ## 72 3 04 0.333 ## 73 3 05 0.417 ## 74 3 04 0.333 ## 75 3 07 0.583 ## 76 4 01 1 ## 77 4 59 59 ## 78 4 29 29 ## 79 4 35 35 ## 80 4 35 35 ## 81 4 15 15 ## 82 4 75 75 ## 83 4 14 14 ## 84 4 19 19 ## 85 4 95 95 ## 86 4 75 75 ## 87 4 31 31 ## 88 4 60 60 ## 89 4 78 78 ## 90 4 47 47 ## 91 4 36 36 ## 92 4 12 12 ## 93 4 03 3 ## 94 4 23 23 ## 95 4 67 67 ## 96 4 38 38 ## 97 4 75 75 ## 98 4 67 67 ## 99 4 18 18 ## 100 4 76 76\r Ao invés de utilizar essas chamadas recursivas de if_else, que são muito ruins de ler, como você poderia reescrever a condição usando case_when?\nExplore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?  gss_cat %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r Em geral, contagens de variáveis ficam bem em gráficos de barras ou visualizações equivalentes, em que é possível comparar visualmente as contagens das diversas categorias. Mais sobre isso na aula do ggplot2.\nQual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?  # Religião\rgss_cat %\u0026gt;% count(relig) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 15 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Protestant 10846\r## 2 Catholic 5124\r## 3 None 3523\r## 4 Christian 689\r## 5 Jewish 388\r## 6 Other 224\r## 7 Buddhism 147\r## 8 Inter-nondenominational 109\r## 9 Moslem/islam 104\r## 10 Orthodox-christian 95\r## 11 No answer 93\r## 12 Hinduism 71\r## 13 Other eastern 32\r## 14 Native american 23\r## 15 Don't know 15\r # Partido\rgss_cat %\u0026gt;% count(partyid) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Independent 4119\r## 2 Not str democrat 3690\r## 3 Strong democrat 3490\r## 4 Not str republican 3032\r## 5 Ind,near dem 2499\r## 6 Strong republican 2314\r## 7 Ind,near rep 1791\r## 8 Other party 393\r## 9 No answer 154\r## 10 Don't know 1\r A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?  Você pode chamar count com várias variáveis para fazer uma tabulação cruzada.\ngss_cat %\u0026gt;% count(relig, denom) %\u0026gt;% print(n = Inf)\r ## # A tibble: 47 x 3\r## relig denom n\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer No answer 93\r## 2 Don't know Not applicable 15\r## 3 Inter-nondenominational Not applicable 109\r## 4 Native american Not applicable 23\r## 5 Christian No answer 2\r## 6 Christian Don't know 11\r## 7 Christian No denomination 452\r## 8 Christian Not applicable 224\r## 9 Orthodox-christian Not applicable 95\r## 10 Moslem/islam Not applicable 104\r## 11 Other eastern Not applicable 32\r## 12 Hinduism Not applicable 71\r## 13 Buddhism Not applicable 147\r## 14 Other No denomination 7\r## 15 Other Not applicable 217\r## 16 None Not applicable 3523\r## 17 Jewish Not applicable 388\r## 18 Catholic Not applicable 5124\r## 19 Protestant No answer 22\r## 20 Protestant Don't know 41\r## 21 Protestant No denomination 1224\r## 22 Protestant Other 2534\r## 23 Protestant Episcopal 397\r## 24 Protestant Presbyterian-dk wh 244\r## 25 Protestant Presbyterian, merged 67\r## 26 Protestant Other presbyterian 47\r## 27 Protestant United pres ch in us 110\r## 28 Protestant Presbyterian c in us 104\r## 29 Protestant Lutheran-dk which 267\r## 30 Protestant Evangelical luth 122\r## 31 Protestant Other lutheran 30\r## 32 Protestant Wi evan luth synod 71\r## 33 Protestant Lutheran-mo synod 212\r## 34 Protestant Luth ch in america 71\r## 35 Protestant Am lutheran 146\r## 36 Protestant Methodist-dk which 239\r## 37 Protestant Other methodist 33\r## 38 Protestant United methodist 1067\r## 39 Protestant Afr meth ep zion 32\r## 40 Protestant Afr meth episcopal 77\r## 41 Protestant Baptist-dk which 1457\r## 42 Protestant Other baptists 213\r## 43 Protestant Southern baptist 1536\r## 44 Protestant Nat bapt conv usa 40\r## 45 Protestant Nat bapt conv of am 76\r## 46 Protestant Am bapt ch in usa 130\r## 47 Protestant Am baptist asso 237\r Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?  A melhor função para redução de fatores é fct_collapse. Veja como ficam a coluna original e a transformada.\ngss_cat2 \u0026lt;- gss_cat %\u0026gt;% # Aqui vou salvar em \u0026quot;rincome2\u0026quot; para a gente poder ver as duas\rmutate(rincome2 = fct_collapse(\rrincome,\r\u0026quot;Non-response\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Refused\u0026quot;, \u0026quot;Not applicable\u0026quot;),\r\u0026quot;Até 5k\u0026quot; = c(\u0026quot;$4000 to 4999\u0026quot;, \u0026quot;$3000 to 3999\u0026quot;, \u0026quot;$1000 to 2999\u0026quot;, \u0026quot;Lt $1000\u0026quot;),\r\u0026quot;5k-10k\u0026quot; = c( \u0026quot;$8000 to 9999\u0026quot;, \u0026quot;$7000 to 7999\u0026quot;, \u0026quot;$6000 to 6999\u0026quot;, \u0026quot;$5000 to 5999\u0026quot;),\r\u0026quot;10k-20k\u0026quot; = c(\u0026quot;$15000 - 19999\u0026quot;, \u0026quot;$10000 - 14999\u0026quot;),\r\u0026quot;20k+\u0026quot; = c(\u0026quot;$25000 or more\u0026quot;, \u0026quot;$20000 - 24999\u0026quot;))) %\u0026gt;% select(rincome, rincome2)\r# E veja as contagens\rgss_cat2 %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r gss_cat2 %\u0026gt;% count(rincome2)\r ## # A tibble: 5 x 2\r## rincome2 n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Non-response 8468\r## 2 20k+ 8646\r## 3 10k-20k 2216\r## 4 5k-10k 970\r## 5 Até 5k 1183\r ggplot2  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r Os pontos não ficam azuis porque você não está especificando cores! Dentro da função aes() você está especificando variáveis para serem mapeadas a uma escala de cores. Portanto, o ggplot interpreta \u0026ldquo;blue\u0026rdquo; como uma variável sem nome que tem o valor \u0026ldquo;blue\u0026rdquo; e mapeia ela para a escala de cores padrão, que é vermelha. Se você quer controlar apenas a \u0026ldquo;aparência\u0026rdquo; dos pontos e não está preocupada em mapear nenhuma variável, você pode passar essa estética fora da função aes().\nggplot(data = mpg) + geom_point(\rmapping = aes(x = displ, y = hwy), # aqui acabam os mapeamentos estéticos\rcolor = \u0026quot;blue\u0026quot;, # alteração apenas na aparência do geom\rsize = 2, # alteração apenas na aparência do geom\rshape = 6 # alteração apenas na aparência do geom\r)  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?  ggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point()\r ## Warning: The shape palette can deal with a maximum of 6 discrete values because\r## more than 6 becomes difficult to discriminate; you have 15. Consider\r## specifying shapes manually if you must have them.\r ## Warning: Removed 112 rows containing missing values (geom_point).\r Ao cumprir as instruções como dadas, logo de cara você recebe um aviso do ggplot2. A paleta de \u0026ldquo;shapes\u0026rdquo; só recebe por padrão 6 shapes diferentes, porque de acordo com o autor, mais de 6 torna difícil de distinguir. Mas eu sou teimoso.\nggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point() +\rscale_shape_manual(values = 1:15, guide = \u0026quot;legend\u0026quot;)\r Esse gráfico é mais um exemplo para vocês verem como diferentes escalas se comportam. A variável cyl é numérica e ordenada, então faz sentido colocá-la num mapeamento como size, já que visualmente é possível indicar que a grandeza aumenta com o tamanho. Classe é uma variável categórica, então ela fica melhor em mapeamentos que ressaltam diferenças entre as categorias, como colors ou shapes. O pacote também impõe algumas restrições sobre o que é possível mapear. Por exemplo, ele retorna erro se você tenta mapear uma variável discreta para uma escala contínua.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rscale_color_continuous()\r ## Error: Discrete value supplied to continuous scale\r Experimentem tentar mapear diferentes variáveis no banco mpg para as diferentes escalas e vejam os resultados. Em alguns casos, é possível, mas o gráfico é pouco informativo, em outros, você verá mensagens de erro.\nUtilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.  Esse exercício não tem uma resposta correta. O objetivo era que vocês explorassem as transformações estatísticas e as escalas de cores diferentes presentes no ggplot, através do argumento trans, ou mesmo fazer outras transformações que interessassem vocês nas variáveis. Abaixo um exemplo de transformação de Yeo-Johnson, um tipo de transformação BoxCox que aceita valores negativos e uma das escalas de cor do pacote viridis.\nggplot(diamonds, aes(carat, price, color = clarity)) +\rgeom_point() +\rscale_x_continuous(trans = scales::yj_trans(p = 2)) +\rscale_color_viridis_d(option = \u0026quot;magma\u0026quot;)\r Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.  Segundo a mesma lógica, o objetivo era explorar as opções de visualização de modelos simples através do argumento method. Abaixo um exemplo de gam. Uma mudança que fiz foi usar a variável cut ao invés de clarity, porque o gráfico não-transformado de clarity estava muito poluído.\nggplot(diamonds, aes(carat, price, color = cut)) +\rgeom_point(alpha = 0.1) + # pontos translúcidos para reduzir a poluição\rgeom_smooth(method = \u0026quot;gam\u0026quot;, se = FALSE) +\rscale_color_viridis_d(option = \u0026quot;plasma\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ s(x, bs = \u0026quot;cs\u0026quot;)'\r No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r Acabei explicando isso na aula, devido a uma pergunta, mas para quem perdeu, trata-se do comportamento padrão quando há proporções: cada barra terá sua própria proporção e todas somarão a 100%. O uso de group = 1 indica à função que as proporções que somam a 100% são o total dos níveis do fator e não cada nível individualmente.\nggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop), group = 1))\r # No caso em que há um \u0026quot;fill\u0026quot;, precisamos normalizar as alturas das barras\rggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(prop),\rfill = clarity\r))\r ggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(count)/sum(stat(count)),\rfill = clarity\r))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  geom_smooth chama stat_smooth quando você utiliza a função para calcular as \u0026ldquo;médias condicionais\u0026rdquo; que correspondem a linha de tendência desenhada no gráfico. É assim com todos os geoms no pacote. Há uma conexão entre o objeto geométrico e uma transformação estatística. Mesmo que seja a transformação _identity, que mantém a variável exatamente como ela estava no dado. A grande vantagem de construir um gráfico com stat_smooth ao invés de geom_smooth é que você pode especificar outro objeto geométrico que não seja o padrão (geom_line + geom_ribbon). É isso que os gráficos abaixo demonstram.\nggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.  Esse aqui é para demonstrar o uso de facet_grid, que permite especificar fatores de classificação diferentes nas linhas e colunas, diferente de facet_wrap mostrado na aula, que só permite especificar uma dimensão.\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rfacet_grid(cyl ~ drv)\r Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Mesmo antes de rodar o código, o observador astuto notará que os mapeamentos locais no segundo gráfico são idênticos entre si e aos mapeamentos globais, então os dois gráficos são iguais.\nTente recriar o seguinte gráfico  O objetivo dessa era fazer vocês fuçarem um pouco na ajuda para tentar recriar o mais fielmente possível o gráfico final. Não precisava ter acertado, o objetivo era chegar o mais próximo possível.\nggplot(mpg, aes(displ, hwy, color = drv)) +\rgeom_point() +\rgeom_smooth(method = lm, se = FALSE) +\rlabs(x = \u0026quot;Rodovia\u0026quot;, y = \u0026quot;Toneladas\u0026quot;, color = \u0026quot;Tração\u0026quot;) +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r Depois de simplesmente especificar coord_polar, em geral o gráfico fica meio estranho, não tem aquela cara bonita de pizza. É preciso corrigir os seguintes problemas:\n A largura das barras deve ser igual a proporção das contagens, mas a altura deve ser igual a 1! Portanto, eu inverto as coisas e passo as contagens/proporções para \u0026ldquo;x\u0026rdquo; e \u0026ldquo;y\u0026rdquo; fica com o valor fixo = 1.  ggplot(diamonds, aes(\r# calculando as proporções do total,\r# também funciona com o padrão stat(count)\rx = stat(count)/sum(stat(count)),\ry = 1, # altura igual a 1\rfill = cut)) + # cores\rgeom_bar() +\rcoord_polar() + # coordenadas polares\r# opcional: remover aspectos do tema para um visual mais clean\rtheme_void()\r Como desafio, tentem adicionar elementos textuais das proporções no gráfico. O problema a ser resolvido é como posicionar o texto num sistema de coordenadas polares. Boa sorte!\nGráficos de pizza são polêmicos na análise de dados porque nossos olhos não captam bem diferenças entre formatos curvos e complexos, então a comparação entre as categorias fica prejudicada se houverem mais de 2 ou 3. Eu sempre dou preferência para barras. Há um tipo de gráfico de pizza melhorzinho chamado \u0026ldquo;donut plot\u0026rdquo;, em que o meio do círculo é oco, mas eu ainda prefiro as barras.\npurrr  Utilize uma das funções map_ para:  Nos exemplos abaixo, eu utilizo sempre str() no final para facilitar a visualização das listas, mas não é obrigatório utilizar esse comando.\n1. Calcular a média de cada coluna em `mtcars`.\r map(mtcars, mean) %\u0026gt;% str()\r ## List of 11\r## $ mpg : num 20.1\r## $ cyl : num 6.19\r## $ disp: num 231\r## $ hp : num 147\r## $ drat: num 3.6\r## $ wt : num 3.22\r## $ qsec: num 17.8\r## $ vs : num 0.438\r## $ am : num 0.406\r## $ gear: num 3.69\r## $ carb: num 2.81\r 2. Determinar o tipo de cada coluna em `flights`.\r flights %\u0026gt;% map(class) %\u0026gt;% str()\r ## List of 19\r## $ year : chr \u0026quot;integer\u0026quot;\r## $ month : chr \u0026quot;integer\u0026quot;\r## $ day : chr \u0026quot;integer\u0026quot;\r## $ dep_time : chr \u0026quot;integer\u0026quot;\r## $ sched_dep_time: chr \u0026quot;integer\u0026quot;\r## $ dep_delay : chr \u0026quot;numeric\u0026quot;\r## $ arr_time : chr \u0026quot;integer\u0026quot;\r## $ sched_arr_time: chr \u0026quot;integer\u0026quot;\r## $ arr_delay : chr \u0026quot;numeric\u0026quot;\r## $ carrier : chr \u0026quot;character\u0026quot;\r## $ flight : chr \u0026quot;integer\u0026quot;\r## $ tailnum : chr \u0026quot;character\u0026quot;\r## $ origin : chr \u0026quot;character\u0026quot;\r## $ dest : chr \u0026quot;character\u0026quot;\r## $ air_time : chr \u0026quot;numeric\u0026quot;\r## $ distance : chr \u0026quot;numeric\u0026quot;\r## $ hour : chr \u0026quot;numeric\u0026quot;\r## $ minute : chr \u0026quot;numeric\u0026quot;\r## $ time_hour : chr [1:2] \u0026quot;POSIXct\u0026quot; \u0026quot;POSIXt\u0026quot;\r 3. Computar o número de valores únicos em cada coluna de `iris`.\r flights %\u0026gt;% map(unique) %\u0026gt;% map(length) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r # Sugestão do Pedro Gomes\rflights %\u0026gt;% map(n_distinct) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r 4. Gere 10 distribuições aleatórias (`rnorm`) com médias -10, 0, 10 e 100.\r x \u0026lt;- rep(100, 40)\rmedias \u0026lt;- rep(c(-10, 0, 10, 100), each = 10)\rmap2(x, medias, ~rnorm(.x, mean = .y)) %\u0026gt;% str()\r ## List of 40\r## $ : num [1:100] -9.96 -9.53 -9.12 -9.64 -10.36 ...\r## $ : num [1:100] -11.71 -10.76 -9.41 -9.22 -10.53 ...\r## $ : num [1:100] -11.33 -9.51 -8.98 -10.91 -9.52 ...\r## $ : num [1:100] -11.4 -10.9 -10.7 -12.1 -9.8 ...\r## $ : num [1:100] -11.06 -10.66 -10.33 -9.13 -9.13 ...\r## $ : num [1:100] -10.22 -9.59 -9.81 -10.71 -10.24 ...\r## $ : num [1:100] -11 -9.14 -10.91 -9.38 -9.63 ...\r## $ : num [1:100] -9.83 -9.61 -11.23 -9.68 -10.47 ...\r## $ : num [1:100] -9.11 -10.03 -10.62 -9.65 -10.2 ...\r## $ : num [1:100] -9.06 -10.41 -10.84 -9.16 -9.41 ...\r## $ : num [1:100] -0.8378 0.1102 0.7519 -0.2477 0.0342 ...\r## $ : num [1:100] 0.607 -0.902 -2.185 -0.397 -1.019 ...\r## $ : num [1:100] -0.452 2.067 1.45 -1.184 0.893 ...\r## $ : num [1:100] -0.604 -0.783 1.767 -0.632 1.322 ...\r## $ : num [1:100] -2.515 0.43 0.694 1.239 1.091 ...\r## $ : num [1:100] -1.462 1.177 -0.376 0.037 0.387 ...\r## $ : num [1:100] -0.0803 -0.0421 2.4765 0.0509 -0.1479 ...\r## $ : num [1:100] 1.118 0.662 -1.439 -1.074 0.493 ...\r## $ : num [1:100] -0.3136 0.4455 -0.947 2.0658 -0.0188 ...\r## $ : num [1:100] 0.193 0.625 2.281 0.297 -0.629 ...\r## $ : num [1:100] 9.29 9.1 9.54 9.99 10.2 ...\r## $ : num [1:100] 7.96 7.32 10.7 9.13 10.3 ...\r## $ : num [1:100] 9.96 10.24 10.31 10.54 11.65 ...\r## $ : num [1:100] 10.88 10.41 8.19 10.37 10.28 ...\r## $ : num [1:100] 11.27 9.74 11.75 11.7 9.31 ...\r## $ : num [1:100] 9.62 11.35 10.78 10.79 9.7 ...\r## $ : num [1:100] 9.04 10.24 11.85 9.82 10.66 ...\r## $ : num [1:100] 10.48 6.97 8.97 9.69 11.03 ...\r## $ : num [1:100] 8.48 10.12 9.09 8.18 10.11 ...\r## $ : num [1:100] 9.97 9.27 10.19 10.93 11.07 ...\r## $ : num [1:100] 100 99.2 99.6 100.3 99.2 ...\r## $ : num [1:100] 99 99.9 100.7 98.7 99.7 ...\r## $ : num [1:100] 99.6 99.2 100.1 100 99.9 ...\r## $ : num [1:100] 100.5 100.4 100.2 98.4 98.9 ...\r## $ : num [1:100] 99.8 99.8 100 99.1 101.1 ...\r## $ : num [1:100] 100.7 100 100.1 98.6 100 ...\r## $ : num [1:100] 99 99.4 100.5 100.1 99.3 ...\r## $ : num [1:100] 99.2 98.6 99.2 100.9 97.4 ...\r## $ : num [1:100] 99.7 99.8 100.9 100.5 99.9 ...\r## $ : num [1:100] 99.5 100.9 98.5 99.7 100 ...\r Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?  # Flights por exemplo\rflights %\u0026gt;% # Lembrem-se que a pergunta pedia para criar um vetor!\rmap_lgl(is.factor)\r ## year month day dep_time sched_dep_time ## FALSE FALSE FALSE FALSE FALSE ## dep_delay arr_time sched_arr_time arr_delay carrier ## FALSE FALSE FALSE FALSE FALSE ## flight tailnum origin dest air_time ## FALSE FALSE FALSE FALSE FALSE ## distance hour minute time_hour ## FALSE FALSE FALSE FALSE\r  Usando as funções predicado keep e discard:\n Selecione todas as colunas caractere no banco flights.    flights %\u0026gt;% keep(is.character)\r ## # A tibble: 336,776 x 4\r## carrier tailnum origin dest ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 UA N14228 EWR IAH ## 2 UA N24211 LGA IAH ## 3 AA N619AA JFK MIA ## 4 B6 N804JB JFK BQN ## 5 DL N668DN LGA ATL ## 6 UA N39463 EWR ORD ## 7 B6 N516JB EWR FLL ## 8 EV N829AS LGA IAD ## 9 B6 N593JB JFK MCO ## 10 AA N3ALAA LGA ORD ## # ... with 336,766 more rows\r 2. Descarte os caracteres em `mpg`.\r mpg %\u0026gt;% discard(is.character)\r ## # A tibble: 234 x 5\r## displ year cyl cty hwy\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1.8 1999 4 18 29\r## 2 1.8 1999 4 21 29\r## 3 2 2008 4 20 31\r## 4 2 2008 4 21 30\r## 5 2.8 1999 6 16 26\r## 6 2.8 1999 6 18 26\r## 7 3.1 2008 6 18 27\r## 8 1.8 1999 4 18 26\r## 9 1.8 1999 4 16 25\r## 10 2 2008 4 20 28\r## # ... with 224 more rows\r 3. Selecione os fatores ordenados em `diamonds`.\r diamonds %\u0026gt;% keep(is.ordered)\r ## # A tibble: 53,940 x 3\r## cut color clarity\r## \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; ## 1 Ideal E SI2 ## 2 Premium E SI1 ## 3 Good E VS1 ## 4 Premium I VS2 ## 5 Good J SI2 ## 6 Very Good J VVS2 ## 7 Very Good I VVS1 ## 8 Very Good H SI1 ## 9 Fair E VS2 ## 10 Very Good H VS1 ## # ... with 53,930 more rows\r 4. Descarte as variáveis não-numéricas em `iris`\r iris %\u0026gt;% discard(negate(is.numeric))\r ## Sepal.Length Sepal.Width Petal.Length Petal.Width\r## 1 5.1 3.5 1.4 0.2\r## 2 4.9 3.0 1.4 0.2\r## 3 4.7 3.2 1.3 0.2\r## 4 4.6 3.1 1.5 0.2\r## 5 5.0 3.6 1.4 0.2\r## 6 5.4 3.9 1.7 0.4\r## 7 4.6 3.4 1.4 0.3\r## 8 5.0 3.4 1.5 0.2\r## 9 4.4 2.9 1.4 0.2\r## 10 4.9 3.1 1.5 0.1\r## 11 5.4 3.7 1.5 0.2\r## 12 4.8 3.4 1.6 0.2\r## 13 4.8 3.0 1.4 0.1\r## 14 4.3 3.0 1.1 0.1\r## 15 5.8 4.0 1.2 0.2\r## 16 5.7 4.4 1.5 0.4\r## 17 5.4 3.9 1.3 0.4\r## 18 5.1 3.5 1.4 0.3\r## 19 5.7 3.8 1.7 0.3\r## 20 5.1 3.8 1.5 0.3\r## 21 5.4 3.4 1.7 0.2\r## 22 5.1 3.7 1.5 0.4\r## 23 4.6 3.6 1.0 0.2\r## 24 5.1 3.3 1.7 0.5\r## 25 4.8 3.4 1.9 0.2\r## 26 5.0 3.0 1.6 0.2\r## 27 5.0 3.4 1.6 0.4\r## 28 5.2 3.5 1.5 0.2\r## 29 5.2 3.4 1.4 0.2\r## 30 4.7 3.2 1.6 0.2\r## 31 4.8 3.1 1.6 0.2\r## 32 5.4 3.4 1.5 0.4\r## 33 5.2 4.1 1.5 0.1\r## 34 5.5 4.2 1.4 0.2\r## 35 4.9 3.1 1.5 0.2\r## 36 5.0 3.2 1.2 0.2\r## 37 5.5 3.5 1.3 0.2\r## 38 4.9 3.6 1.4 0.1\r## 39 4.4 3.0 1.3 0.2\r## 40 5.1 3.4 1.5 0.2\r## 41 5.0 3.5 1.3 0.3\r## 42 4.5 2.3 1.3 0.3\r## 43 4.4 3.2 1.3 0.2\r## 44 5.0 3.5 1.6 0.6\r## 45 5.1 3.8 1.9 0.4\r## 46 4.8 3.0 1.4 0.3\r## 47 5.1 3.8 1.6 0.2\r## 48 4.6 3.2 1.4 0.2\r## 49 5.3 3.7 1.5 0.2\r## 50 5.0 3.3 1.4 0.2\r## 51 7.0 3.2 4.7 1.4\r## 52 6.4 3.2 4.5 1.5\r## 53 6.9 3.1 4.9 1.5\r## 54 5.5 2.3 4.0 1.3\r## 55 6.5 2.8 4.6 1.5\r## 56 5.7 2.8 4.5 1.3\r## 57 6.3 3.3 4.7 1.6\r## 58 4.9 2.4 3.3 1.0\r## 59 6.6 2.9 4.6 1.3\r## 60 5.2 2.7 3.9 1.4\r## 61 5.0 2.0 3.5 1.0\r## 62 5.9 3.0 4.2 1.5\r## 63 6.0 2.2 4.0 1.0\r## 64 6.1 2.9 4.7 1.4\r## 65 5.6 2.9 3.6 1.3\r## 66 6.7 3.1 4.4 1.4\r## 67 5.6 3.0 4.5 1.5\r## 68 5.8 2.7 4.1 1.0\r## 69 6.2 2.2 4.5 1.5\r## 70 5.6 2.5 3.9 1.1\r## 71 5.9 3.2 4.8 1.8\r## 72 6.1 2.8 4.0 1.3\r## 73 6.3 2.5 4.9 1.5\r## 74 6.1 2.8 4.7 1.2\r## 75 6.4 2.9 4.3 1.3\r## 76 6.6 3.0 4.4 1.4\r## 77 6.8 2.8 4.8 1.4\r## 78 6.7 3.0 5.0 1.7\r## 79 6.0 2.9 4.5 1.5\r## 80 5.7 2.6 3.5 1.0\r## 81 5.5 2.4 3.8 1.1\r## 82 5.5 2.4 3.7 1.0\r## 83 5.8 2.7 3.9 1.2\r## 84 6.0 2.7 5.1 1.6\r## 85 5.4 3.0 4.5 1.5\r## 86 6.0 3.4 4.5 1.6\r## 87 6.7 3.1 4.7 1.5\r## 88 6.3 2.3 4.4 1.3\r## 89 5.6 3.0 4.1 1.3\r## 90 5.5 2.5 4.0 1.3\r## 91 5.5 2.6 4.4 1.2\r## 92 6.1 3.0 4.6 1.4\r## 93 5.8 2.6 4.0 1.2\r## 94 5.0 2.3 3.3 1.0\r## 95 5.6 2.7 4.2 1.3\r## 96 5.7 3.0 4.2 1.2\r## 97 5.7 2.9 4.2 1.3\r## 98 6.2 2.9 4.3 1.3\r## 99 5.1 2.5 3.0 1.1\r## 100 5.7 2.8 4.1 1.3\r## 101 6.3 3.3 6.0 2.5\r## 102 5.8 2.7 5.1 1.9\r## 103 7.1 3.0 5.9 2.1\r## 104 6.3 2.9 5.6 1.8\r## 105 6.5 3.0 5.8 2.2\r## 106 7.6 3.0 6.6 2.1\r## 107 4.9 2.5 4.5 1.7\r## 108 7.3 2.9 6.3 1.8\r## 109 6.7 2.5 5.8 1.8\r## 110 7.2 3.6 6.1 2.5\r## 111 6.5 3.2 5.1 2.0\r## 112 6.4 2.7 5.3 1.9\r## 113 6.8 3.0 5.5 2.1\r## 114 5.7 2.5 5.0 2.0\r## 115 5.8 2.8 5.1 2.4\r## 116 6.4 3.2 5.3 2.3\r## 117 6.5 3.0 5.5 1.8\r## 118 7.7 3.8 6.7 2.2\r## 119 7.7 2.6 6.9 2.3\r## 120 6.0 2.2 5.0 1.5\r## 121 6.9 3.2 5.7 2.3\r## 122 5.6 2.8 4.9 2.0\r## 123 7.7 2.8 6.7 2.0\r## 124 6.3 2.7 4.9 1.8\r## 125 6.7 3.3 5.7 2.1\r## 126 7.2 3.2 6.0 1.8\r## 127 6.2 2.8 4.8 1.8\r## 128 6.1 3.0 4.9 1.8\r## 129 6.4 2.8 5.6 2.1\r## 130 7.2 3.0 5.8 1.6\r## 131 7.4 2.8 6.1 1.9\r## 132 7.9 3.8 6.4 2.0\r## 133 6.4 2.8 5.6 2.2\r## 134 6.3 2.8 5.1 1.5\r## 135 6.1 2.6 5.6 1.4\r## 136 7.7 3.0 6.1 2.3\r## 137 6.3 3.4 5.6 2.4\r## 138 6.4 3.1 5.5 1.8\r## 139 6.0 3.0 4.8 1.8\r## 140 6.9 3.1 5.4 2.1\r## 141 6.7 3.1 5.6 2.4\r## 142 6.9 3.1 5.1 2.3\r## 143 5.8 2.7 5.1 1.9\r## 144 6.8 3.2 5.9 2.3\r## 145 6.7 3.3 5.7 2.5\r## 146 6.7 3.0 5.2 2.3\r## 147 6.3 2.5 5.0 1.9\r## 148 6.5 3.0 5.2 2.0\r## 149 6.2 3.4 5.4 2.3\r## 150 5.9 3.0 5.1 1.8\r Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.  # Vamos usar um diretório temporário que vamos preencher com vários tibbles\rpasta \u0026lt;- tempdir()\r# Criamos 100 tibbles e guardamos em 100 arquivos csv.\rx \u0026lt;- rep(10, 100)\rarqs \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:100)\rmap(x, ~tibble(var1 = rnorm(.x), var2 = rnorm(.x))) %\u0026gt;% map2(arqs, ~write_csv(.x, file.path(pasta, .y))) %\u0026gt;% str()\r # Nossos arquivos estão salvos no diretório temporário:\rdir(pasta)\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo10.csv\u0026quot; \u0026quot;arquivo100.csv\u0026quot; \u0026quot;arquivo11.csv\u0026quot; ## [5] \u0026quot;arquivo12.csv\u0026quot; \u0026quot;arquivo13.csv\u0026quot; \u0026quot;arquivo14.csv\u0026quot; \u0026quot;arquivo15.csv\u0026quot; ## [9] \u0026quot;arquivo16.csv\u0026quot; \u0026quot;arquivo17.csv\u0026quot; \u0026quot;arquivo18.csv\u0026quot; \u0026quot;arquivo19.csv\u0026quot; ## [13] \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo20.csv\u0026quot; \u0026quot;arquivo21.csv\u0026quot; \u0026quot;arquivo22.csv\u0026quot; ## [17] \u0026quot;arquivo23.csv\u0026quot; \u0026quot;arquivo24.csv\u0026quot; \u0026quot;arquivo25.csv\u0026quot; \u0026quot;arquivo26.csv\u0026quot; ## [21] \u0026quot;arquivo27.csv\u0026quot; \u0026quot;arquivo28.csv\u0026quot; \u0026quot;arquivo29.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; ## [25] \u0026quot;arquivo30.csv\u0026quot; \u0026quot;arquivo31.csv\u0026quot; \u0026quot;arquivo32.csv\u0026quot; \u0026quot;arquivo33.csv\u0026quot; ## [29] \u0026quot;arquivo34.csv\u0026quot; \u0026quot;arquivo35.csv\u0026quot; \u0026quot;arquivo36.csv\u0026quot; \u0026quot;arquivo37.csv\u0026quot; ## [33] \u0026quot;arquivo38.csv\u0026quot; \u0026quot;arquivo39.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot; \u0026quot;arquivo40.csv\u0026quot; ## [37] \u0026quot;arquivo41.csv\u0026quot; \u0026quot;arquivo42.csv\u0026quot; \u0026quot;arquivo43.csv\u0026quot; \u0026quot;arquivo44.csv\u0026quot; ## [41] \u0026quot;arquivo45.csv\u0026quot; \u0026quot;arquivo46.csv\u0026quot; \u0026quot;arquivo47.csv\u0026quot; \u0026quot;arquivo48.csv\u0026quot; ## [45] \u0026quot;arquivo49.csv\u0026quot; \u0026quot;arquivo5.csv\u0026quot; \u0026quot;arquivo50.csv\u0026quot; \u0026quot;arquivo51.csv\u0026quot; ## [49] \u0026quot;arquivo52.csv\u0026quot; \u0026quot;arquivo53.csv\u0026quot; \u0026quot;arquivo54.csv\u0026quot; \u0026quot;arquivo55.csv\u0026quot; ## [53] \u0026quot;arquivo56.csv\u0026quot; \u0026quot;arquivo57.csv\u0026quot; \u0026quot;arquivo58.csv\u0026quot; \u0026quot;arquivo59.csv\u0026quot; ## [57] \u0026quot;arquivo6.csv\u0026quot; \u0026quot;arquivo60.csv\u0026quot; \u0026quot;arquivo61.csv\u0026quot; \u0026quot;arquivo62.csv\u0026quot; ## [61] \u0026quot;arquivo63.csv\u0026quot; \u0026quot;arquivo64.csv\u0026quot; \u0026quot;arquivo65.csv\u0026quot; \u0026quot;arquivo66.csv\u0026quot; ## [65] \u0026quot;arquivo67.csv\u0026quot; \u0026quot;arquivo68.csv\u0026quot; \u0026quot;arquivo69.csv\u0026quot; \u0026quot;arquivo7.csv\u0026quot; ## [69] \u0026quot;arquivo70.csv\u0026quot; \u0026quot;arquivo71.csv\u0026quot; \u0026quot;arquivo72.csv\u0026quot; \u0026quot;arquivo73.csv\u0026quot; ## [73] \u0026quot;arquivo74.csv\u0026quot; \u0026quot;arquivo75.csv\u0026quot; \u0026quot;arquivo76.csv\u0026quot; \u0026quot;arquivo77.csv\u0026quot; ## [77] \u0026quot;arquivo78.csv\u0026quot; \u0026quot;arquivo79.csv\u0026quot; \u0026quot;arquivo8.csv\u0026quot; \u0026quot;arquivo80.csv\u0026quot; ## [81] \u0026quot;arquivo81.csv\u0026quot; \u0026quot;arquivo82.csv\u0026quot; \u0026quot;arquivo83.csv\u0026quot; \u0026quot;arquivo84.csv\u0026quot; ## [85] \u0026quot;arquivo85.csv\u0026quot; \u0026quot;arquivo86.csv\u0026quot; \u0026quot;arquivo87.csv\u0026quot; \u0026quot;arquivo88.csv\u0026quot; ## [89] \u0026quot;arquivo89.csv\u0026quot; \u0026quot;arquivo9.csv\u0026quot; \u0026quot;arquivo90.csv\u0026quot; \u0026quot;arquivo91.csv\u0026quot; ## [93] \u0026quot;arquivo92.csv\u0026quot; \u0026quot;arquivo93.csv\u0026quot; \u0026quot;arquivo94.csv\u0026quot; \u0026quot;arquivo95.csv\u0026quot; ## [97] \u0026quot;arquivo96.csv\u0026quot; \u0026quot;arquivo97.csv\u0026quot; \u0026quot;arquivo98.csv\u0026quot; \u0026quot;arquivo99.csv\u0026quot; ## [101] \u0026quot;filecf810bd36a5\u0026quot; \u0026quot;filecf81149221d\u0026quot; \u0026quot;filecf81164e23\u0026quot; \u0026quot;filecf8161f65f7\u0026quot;\r## [105] \u0026quot;filecf8171030fd\u0026quot; \u0026quot;filecf819e43f49\u0026quot; \u0026quot;filecf81ad26a9f\u0026quot; \u0026quot;filecf81bed9f1\u0026quot; ## [109] \u0026quot;filecf81e7a7e68\u0026quot; \u0026quot;filecf81ef03542\u0026quot; \u0026quot;filecf81fa64a3e\u0026quot; \u0026quot;filecf8239d75ab\u0026quot;\r## [113] \u0026quot;filecf8261936\u0026quot; \u0026quot;filecf826d55378\u0026quot; \u0026quot;filecf8291061a0\u0026quot; \u0026quot;filecf82b985019\u0026quot;\r## [117] \u0026quot;filecf82c00737b\u0026quot; \u0026quot;filecf8339f5\u0026quot; \u0026quot;filecf8341e67d6\u0026quot; \u0026quot;filecf8344158ac\u0026quot;\r## [121] \u0026quot;filecf837a47cc7\u0026quot; \u0026quot;filecf837f15510\u0026quot; \u0026quot;filecf8387a3d29\u0026quot; \u0026quot;filecf83a71232b\u0026quot;\r## [125] \u0026quot;filecf83ac3253a\u0026quot; \u0026quot;filecf83af94598\u0026quot; \u0026quot;filecf83f794f64\u0026quot; \u0026quot;filecf8402156c1\u0026quot;\r## [129] \u0026quot;filecf840c15566\u0026quot; \u0026quot;filecf84163761c\u0026quot; \u0026quot;filecf841d3b53\u0026quot; \u0026quot;filecf844d5642\u0026quot; ## [133] \u0026quot;filecf845e73bac\u0026quot; \u0026quot;filecf8462819d6\u0026quot; \u0026quot;filecf84b8b3144\u0026quot; \u0026quot;filecf84ddc73a0\u0026quot;\r## [137] \u0026quot;filecf84fe515d4\u0026quot; \u0026quot;filecf8500a5a10\u0026quot; \u0026quot;filecf8512766ea\u0026quot; \u0026quot;filecf852fe119b\u0026quot;\r## [141] \u0026quot;filecf8550a39d\u0026quot; \u0026quot;filecf85b14fec\u0026quot; \u0026quot;filecf85e053c83\u0026quot; \u0026quot;filecf85e6a12f4\u0026quot;\r## [145] \u0026quot;filecf8639c6053\u0026quot; \u0026quot;filecf863dc5f3b\u0026quot; \u0026quot;filecf8646e477f\u0026quot; \u0026quot;filecf865645c5d\u0026quot;\r## [149] \u0026quot;filecf868634c0d\u0026quot; \u0026quot;filecf869137c8a\u0026quot; \u0026quot;filecf86a7852d4\u0026quot; \u0026quot;filecf86b5b250\u0026quot; ## [153] \u0026quot;filecf86b9e3bb7\u0026quot; \u0026quot;filecf86d216ac\u0026quot; \u0026quot;filecf86e894a16\u0026quot; \u0026quot;filecf86ea916d3\u0026quot;\r## [157] \u0026quot;filecf86f22266\u0026quot; \u0026quot;filecf86f975377\u0026quot; \u0026quot;filecf8757a72be\u0026quot; \u0026quot;filecf876956e82\u0026quot;\r## [161] \u0026quot;filecf876967b1\u0026quot; \u0026quot;filecf8787a1370\u0026quot; \u0026quot;filecf879037c39\u0026quot; \u0026quot;filecf87964711\u0026quot; ## [165] \u0026quot;filecf87afe7046\u0026quot; \u0026quot;filecf88456ae0\u0026quot; \u0026quot;filecf898344ab\u0026quot;\r # Agora vamos ler todos de volta para uma tibble só.\rarqs \u0026lt;- dir(pasta, pattern = \u0026quot;.csv\u0026quot;, full.names = T)\r # Juntando linhas\rdf \u0026lt;- map_dfr(arqs, read_csv)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # Juntando colunas\rdf \u0026lt;- map_dfc(arqs, read_csv)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r # Usando reduce\r# linhas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_rows)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # colunas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_cols)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r# Estou usando funções do pacote broom, mas você não era obrigado a apresentar\r# os resultados bonitinho. O objetivo era treinar esse tipo de workflow.\rmodelos_saida \u0026lt;- tibble(\respecificacao = modelos,\rajuste = map(especificacao, lm, data = mtcars),\rcoefs = map(ajuste, broom::tidy),\rstats = map(ajuste, broom::glance),\raums = map(ajuste, broom::augment)\r)\rmodelos_saida %\u0026gt;% select(especificacao, coefs) %\u0026gt;% unnest(coefs) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)  ## # A tibble: 10 x 6\r## especificacao term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt wt -5.34 0.559 -9.56 1.29e-10\r## 2 mpg ~ wt + cyl wt -3.19 0.757 -4.22 2.22e- 4\r## 3 mpg ~ wt + cyl cyl -1.51 0.415 -3.64 1.06e- 3\r## 4 mpg ~ wt + cyl + drat wt -3.19 0.829 -3.85 6.24e- 4\r## 5 mpg ~ wt + cyl + drat cyl -1.51 0.446 -3.38 2.14e- 3\r## 6 mpg ~ wt + cyl + drat drat -0.0162 1.32 -0.0122 9.90e- 1\r## 7 mpg ~ wt + cyl + drat + am wt -3.13 0.932 -3.36 2.32e- 3\r## 8 mpg ~ wt + cyl + drat + am cyl -1.53 0.465 -3.28 2.88e- 3\r## 9 mpg ~ wt + cyl + drat + am drat -0.130 1.53 -0.0851 9.33e- 1\r## 10 mpg ~ wt + cyl + drat + am am 0.237 1.51 0.157 8.76e- 1\r modelos_saida %\u0026gt;% select(especificacao, stats) %\u0026gt;% unnest(stats)\r ## # A tibble: 4 x 13\r## especificacao r.squared adj.r.squared sigma statistic p.value df logLik\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt 0.753 0.745 3.05 91.4 1.29e-10 1 -80.0\r## 2 mpg ~ wt + cyl 0.830 0.819 2.57 70.9 6.81e-12 2 -74.0\r## 3 mpg ~ wt + cyl ~ 0.830 0.812 2.61 45.6 6.57e-11 3 -74.0\r## 4 mpg ~ wt + cyl ~ 0.830 0.805 2.66 33.0 4.84e-10 4 -74.0\r## # ... with 5 more variables: AIC \u0026lt;dbl\u0026gt;, BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;,\r## # df.residual \u0026lt;int\u0026gt;, nobs \u0026lt;int\u0026gt;\r modelos_saida %\u0026gt;% select(especificacao, aums) %\u0026gt;% filter(especificacao == \u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;) %\u0026gt;% unnest(aums)\r ## # A tibble: 32 x 13\r## especificacao .rownames mpg wt cyl drat am .fitted .resid .hat\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt + cyl~ Mazda RX4 21 2.62 6 3.9 1 22.3 -1.35 0.0899\r## 2 mpg ~ wt + cyl~ Mazda RX~ 21 2.88 6 3.9 1 21.6 -0.550 0.0924\r## 3 mpg ~ wt + cyl~ Datsun 7~ 22.8 2.32 4 3.85 1 26.3 -3.55 0.137 ## 4 mpg ~ wt + cyl~ Hornet 4~ 21.4 3.22 6 3.08 0 20.4 1.05 0.113 ## 5 mpg ~ wt + cyl~ Hornet S~ 18.7 3.44 8 3.15 0 16.6 2.11 0.122 ## 6 mpg ~ wt + cyl~ Valiant 18.1 3.46 6 2.76 0 19.6 -1.53 0.207 ## 7 mpg ~ wt + cyl~ Duster 3~ 14.3 3.57 8 3.21 0 16.2 -1.87 0.103 ## 8 mpg ~ wt + cyl~ Merc 240D 24.4 3.19 4 3.69 0 23.4 0.996 0.189 ## 9 mpg ~ wt + cyl~ Merc 230 22.8 3.15 4 3.92 0 23.5 -0.700 0.207 ## 10 mpg ~ wt + cyl~ Merc 280 19.2 3.44 6 3.92 0 19.5 -0.340 0.149 ## # ... with 22 more rows, and 3 more variables: .sigma \u0026lt;dbl\u0026gt;, .cooksd \u0026lt;dbl\u0026gt;,\r## # .std.resid \u0026lt;dbl\u0026gt;\r ","date":1621900800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621900800,"objectID":"c1c74f268683837301969e7167daf1ed","permalink":"https://laddem.github.io/courses/tidyverse/solucoes/","publishdate":"2021-05-25T00:00:00Z","relpermalink":"/courses/tidyverse/solucoes/","section":"courses","summary":"Soluções dos exercícios","tags":null,"title":"Soluções","type":"book"},{"authors":["LADDEM"],"categories":null,"content":"\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://laddem.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot;\rif porridge == \u0026quot;blueberry\u0026quot;:\rprint(\u0026quot;Eating...\u0026quot;)\r  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}}\r{{% fragment %}} **Two** {{% /fragment %}}\r{{% fragment %}} Three {{% /fragment %}}\r Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}}\r- Only the speaker can read these notes\r- Press `S` key to view\r{{% /speaker_note %}}\r Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}}\r{{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}\r  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1,\r.reveal section h2,\r.reveal section h3 {\rcolor: navy;\r}\r  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://laddem.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://laddem.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://laddem.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://laddem.github.io/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]
=======
[{"authors":null,"categories":null,"content":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://laddem.github.io/author/laddem/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/laddem/","section":"authors","summary":"O Laboratório de Análise de Dados em Demografia é parte do Núcleo de Estudos de População Elza Berquó e dedica-se a promoção do conhecimento na área de demografia, ciências sociais quantitativas e ciência de dados, oferecendo cursos, eventos e infraestrutura para alunos, pesquisadores e o público em geral.","tags":null,"title":"LADDEM","type":"authors"},{"authors":null,"categories":null,"content":"\r\r Table of Contents\r O que você vai aprender O curso Programação Instrutores Links úteis  \r\rO que você vai aprender  A filosofia de design por trás de um dos pacotes mais populares no R Importação, Manipulação e Visualização de dados na prática tidyr, dplyr, ggplot2 e vários outros pacotes para simplificar sua rotina de análise de dados  O curso Uma semana, com aulas à noite, no formato workshop, com muitos exercícios para praticar e pegar o jeito.\nProgramação \rreadr, tibble e tidyr\rUm modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\n\r\rstringr, forcats e dplyr\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\n\r\rggplot2\rO pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.\n\r\rpurrr\rO autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.\n\r\rSoluções\rSoluções dos exercícios\n\r\rInstrutores Vinícius de Souza Maia\nNatália Martins Arruda\nLinks úteis Ciência de dados em R\nR for Data Science\n","date":1621728000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1621728000,"objectID":"02eadce3bea228c4a3968729e322add5","permalink":"https://laddem.github.io/courses/tidyverse/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/","section":"courses","summary":"Aprenda a utilizar o tidyverse nas suas análises de dados.","tags":null,"title":"📊 Aprenda a utilizar o tidyverse","type":"book"},{"authors":null,"categories":null,"content":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:\nEla acaba sendo um ponto de partida interessante porque contextualiza a maioria dos pacotes que vamos utilizar. O readr é uma maneira de facilitar e tornar mais rápida a importação de dados em formatos comuns, como o texto delimitado por separadores e o formato colunado com larguras-fixas utilizado pelo IBGE.\nA tibble é uma proposta de modernização para o data.frame, aproveitando a estrutura flexível e poderosa, mas mudando certas convenções, como a conversão de strings para fatores, permitindo a criação de colunas de listas, utilização de nomes mais complexos para colunas, etc.\nO tidyr é uma forma de reformatar (reshape) bancos de dados que vêm em formatos que dificultam seu processamento, permitindo que o analista facilmente reconfigure a informação para o formato mais adequado. Ele é o primeiro pacote que veremos sobre a parte de \u0026ldquo;cozinha\u0026rdquo; dos dados, no qual é preciso processar o dado bruto para torná-lo passível de análise.\nO mesmo pode ser dito para os outros pacotes que veremos nos próximos dias. Cada um deles foi pensado para resolver um problema ou facilitar uma rotina de trabalho relacionada com um dos passos descritos acima.\nProgramação literária Vários dos conceitos que guiam o design do tidyverse são orientados por uma certa filosofia. Esta filosofia dita que a principal preocupação por trás de um programa não é que ele funcione. Eventualmente e com um pouco de persistência, é quase sempre possível chegar a uma solução técnica adequada. A principal questão é que o programa é uma ferramenta de comunicação com outras pessoas que o lerão, seja seus colegas, colaboradores, alunos ou você mesmo, daqui a 2 anos, quando lembrar que você já escreveu um programa para aquela tarefa. Trago aqui alguns trechos de Literate Programming, de Donald Knuth (1984), traduzidos livremente por este que vos fala:\n Creio que chegou a hora de melhorar significativamente a documentação dos programas, e que podemos atingir este objetivo tratando programas como obras literárias. Por isso o título: \u0026ldquo;Programação Literária\u0026rdquo;. Abandonemos os velhos hábitos de construir programas: ao invés de imaginar que nossa tarefa principal é instruir um computador sobre o que deve ser feito, concentremo-nos em explicar aos seres humanos o que queremos que o computador faça. O praticante da programação literária pode ser visto como um ensaísta, cuja principal preocupação é com a clareza da exposição e a excelência no estilo. Tal autor, com um dicionário na mão, escolhe os nomes das variáveis com cuidado e explica claramente seu significado. Ele ou ela esmera por um programa que é compreensível porque seus conceitos foram introduzidos na melhor ordem possível para o entendimento humano, utilizando uma mistura de métodos formais e informais que se complementam.\n Assim, várias das escolhas feitas na construção de tidyverse procuram reforçar essa característica de interpretabilidade dos programas, como a ordem lógica das operações com o pipe (%\u0026gt;%), funções com nomes mais longos e semânticos, a utilização de uma função específica para cada tarefa, ao invés da adaptação de funções genéricas para uma grande variedade de tarefas. O propósito de um código escrito como tidyverse é que, no limite, a própria síntaxe do código funcione como parte da documentação do programa.\nO mistério do pipe: %\u0026gt;% Usuários de longa data do R já podem ter encontrado no mato esse animal estranho e podem ter ficado confusos com seu significado. O pipe é de origem humilde e nasceu nos sistemas Unix há muitas décadas atrás. Seu objetivo é muito simples: e se você tiver uma sequência de computações em que cada uma recebe o resultado daquela feita anteriormente? Claro que você poderia fazer:\nx \u0026lt;- 1:10\ry \u0026lt;- diff(x)\rmean(y)\r ## [1] 1\r Mas não seria interessante pular os objetos intermediários e ir direto ao ponto? O pipe vem do pacote magrittr, mas ele vêm carregado em quase todos os pacotes do tidyverse. Vamos carregar logo o tibble.\n# Para ter acesso ao pipe, basta carregar um pacote do tidyverse, como tibble, dplyr, tidyr, etc.\r# Vamos carregar o tibble agora\rlibrary(tibble)\rx %\u0026gt;% diff() %\u0026gt;% mean()\r ## [1] 1\r Vejamos um exemplo mais real, quantos artistas existem no dataset billboard? Podemos usar unique e length para descobrir.\nx \u0026lt;- unique(tidyr::billboard$artist)\rlength(x)\r ## [1] 228\r Mas com %\u0026gt;% fica bem melhor:\ntidyr::billboard %\u0026gt;% .$artist %\u0026gt;% unique() %\u0026gt;% length()\r ## [1] 228\r Ok, mas como ele funciona? É simples, o pipe carrega o objeto a sua esquerda num ponto . invisível que é automaticamente passado como o primeiro argumento da função à direita.\nx \u0026lt;- 1:10\rmean(x)\r ## [1] 5.5\r x %\u0026gt;% mean()\r ## [1] 5.5\r OK, mas e se meu argumento não for o primeiro, ainda posso usar pipe? Pode! É só usar explicitamente um ponto no lugar onde você quer aproveitar o efeito:\niris %\u0026gt;% boxplot(Sepal.Length ~ Species, data = .)\r O ponto . depois de data indica indica que ali deve ser colocado o iris. O pipe é uma peça chave de muitas funções do tidyverse, não porque ele seja obrigatório, mas sim porque ele permite expressar sequências de operações numa ordem mais lógica, do tipo: \u0026ldquo;Primeiro faça a, então b, então c, \u0026hellip; \u0026ldquo;, ao contrário da forma como isto é geralmente feito usando parênteses para precedência.\n# Compare\rmean(diff(1:10))\r ## [1] 1\r 1:10 %\u0026gt;% diff %\u0026gt;% mean\r ## [1] 1\r E assim fica desmistificado o mistério do pipe! Um último pulo do gato: pelo amor de deus ninguém digita Shift + %, \u0026gt;, Shift + %, basta usar o atalho: Ctrl + Shift + M que ele põe um pipe separado por espaços %\u0026gt;%.\nreadr Usuários do R provavelmente vão estar familiarizados com os nossos leitores de arquivos mais comuns: read.table e read.csv. Talvez muitos de vocês já até memorizaram alguns dos argumentos mais comuns. Não é o caso aqui de revisitar esta função, mas o readr tem muitos paralelos com elas, porque é pensado como uma nova versão da mesma coisa.\n# Comecemos carregando o readr\rlibrary(readr)\r Debaixo do capô O readr, como as funções de leitura do base é uma coleção de parsers, que transformam texto em objetos R com o tipo desejado.\nparse_number(c(\u0026quot;1\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;38\u0026quot;))\r ## [1] 1 20 38\r parse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;ma\u0026lt;e7\u0026gt;\u0026lt;e3\u0026gt;\u0026quot; \u0026quot;p\u0026lt;ea\u0026gt;ra\u0026quot;\r # Note os acentos e caracteres especiais\rparse_character(c(\u0026quot;banana\u0026quot;, \u0026quot;maçã\u0026quot;, \u0026quot;pêra\u0026quot;), locale = locale(encoding = \u0026quot;Windows-1252\u0026quot;))\r ## [1] \u0026quot;banana\u0026quot; \u0026quot;maçã\u0026quot; \u0026quot;pêra\u0026quot;\r parse_logical(c(\u0026quot;true\u0026quot;, \u0026quot;false\u0026quot;, \u0026quot;true\u0026quot;))\r ## [1] TRUE FALSE TRUE\r Em geral, a gente não precisa descer tanto o nível, a gente vai trabalhar mesmo é com os leitores de dados \u0026ldquo;retangulares\u0026rdquo;. Como os do base, eles são read_csv, read_table, etc. Vamos trabalhar com bancos de dados que já vêm no pacote, para facilitar o processo.\n# Lista os datasets que vem no pacote\rreadr_example()\r ## [1] \u0026quot;challenge.csv\u0026quot; \u0026quot;epa78.txt\u0026quot; \u0026quot;example.log\u0026quot; ## [4] \u0026quot;fwf-sample.txt\u0026quot; \u0026quot;massey-rating.txt\u0026quot; \u0026quot;mtcars.csv\u0026quot; ## [7] \u0026quot;mtcars.csv.bz2\u0026quot; \u0026quot;mtcars.csv.zip\u0026quot;\r Uma coisa que gosto de fazer é olhar como o arquivo está organizado antes de tentar abrí-lo. Muitos de vocês podem fazer isso com readLines. Ela ganhou sua versão no pacote com read_lines.\n# Vamos tentar abrir massey-rating.txt\rread_lines(readr_example(\u0026quot;massey-rating.txt\u0026quot;), n_max = 10)\r ## [1] \u0026quot;UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf\u0026quot; ## [2] \u0026quot; 1 1 1 1 1 1 1 1 1 1 1 Ohio St B10 \u0026quot;\r## [3] \u0026quot; 2 2 2 2 2 2 2 2 4 2 2 Oregon P12 \u0026quot;\r## [4] \u0026quot; 3 4 3 4 3 4 3 4 2 3 3 Alabama SEC \u0026quot;\r## [5] \u0026quot; 4 3 4 3 4 3 5 3 3 4 4 TCU B12 \u0026quot;\r## [6] \u0026quot; 6 6 6 5 5 7 6 5 6 11 5 Michigan St B10 \u0026quot;\r## [7] \u0026quot; 7 7 7 6 7 6 11 8 7 8 6 Georgia SEC \u0026quot;\r## [8] \u0026quot; 5 5 5 7 6 8 4 6 5 5 7 Florida St ACC \u0026quot;\r## [9] \u0026quot; 8 8 9 9 10 5 7 7 10 7 8 Baylor B12 \u0026quot;\r## [10] \u0026quot; 9 11 8 13 11 11 12 9 14 9 9 Georgia Tech ACC \u0026quot;\r # Identificando o separador, escolho a função adequada\rread_table(readr_example(\u0026quot;massey-rating.txt\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## UCC = col_double(),\r## PAY = col_double(),\r## LAZ = col_double(),\r## KPK = col_double(),\r## RT = col_double(),\r## COF = col_double(),\r## BIH = col_double(),\r## DII = col_double(),\r## ENG = col_double(),\r## ACU = col_double(),\r## Rank = col_double(),\r## Team = col_character(),\r## Conf = col_character()\r## )\r ## # A tibble: 10 x 13\r## UCC PAY LAZ KPK RT COF BIH DII ENG ACU Rank Team Conf ## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 1 1 1 1 1 1 1 1 1 1 Ohio~ B10 ## 2 2 2 2 2 2 2 2 2 4 2 2 Oreg~ P12 ## 3 3 4 3 4 3 4 3 4 2 3 3 Alab~ SEC ## 4 4 3 4 3 4 3 5 3 3 4 4 TCU B12 ## 5 6 6 6 5 5 7 6 5 6 11 5 Mich~ B10 ## 6 7 7 7 6 7 6 11 8 7 8 6 Geor~ SEC ## 7 5 5 5 7 6 8 4 6 5 5 7 Flor~ ACC ## 8 8 8 9 9 10 5 7 7 10 7 8 Bayl~ B12 ## 9 9 11 8 13 11 11 12 9 14 9 9 Geor~ ACC ## 10 13 10 13 11 8 9 10 11 9 10 10 Miss~ SEC\r Como identifiquei que as colunas estavam separadas por espaços, utilizei read_table cujo delimitador é o espaço \u0026quot; \u0026quot;.\nA segunda feature mais interessante do readr, é uma interface para selecionar os tipos de colunas que serão importadas. Vejamos o seguinte exemplo.\n# Vamos abrir mtcars.csv\rread_lines(readr_example(\u0026quot;mtcars.csv\u0026quot;), n_max = 10)\r ## [1] \u0026quot;\\\u0026quot;mpg\\\u0026quot;,\\\u0026quot;cyl\\\u0026quot;,\\\u0026quot;disp\\\u0026quot;,\\\u0026quot;hp\\\u0026quot;,\\\u0026quot;drat\\\u0026quot;,\\\u0026quot;wt\\\u0026quot;,\\\u0026quot;qsec\\\u0026quot;,\\\u0026quot;vs\\\u0026quot;,\\\u0026quot;am\\\u0026quot;,\\\u0026quot;gear\\\u0026quot;,\\\u0026quot;carb\\\u0026quot;\u0026quot;\r## [2] \u0026quot;21,6,160,110,3.9,2.62,16.46,0,1,4,4\u0026quot; ## [3] \u0026quot;21,6,160,110,3.9,2.875,17.02,0,1,4,4\u0026quot; ## [4] \u0026quot;22.8,4,108,93,3.85,2.32,18.61,1,1,4,1\u0026quot; ## [5] \u0026quot;21.4,6,258,110,3.08,3.215,19.44,1,0,3,1\u0026quot; ## [6] \u0026quot;18.7,8,360,175,3.15,3.44,17.02,0,0,3,2\u0026quot; ## [7] \u0026quot;18.1,6,225,105,2.76,3.46,20.22,1,0,3,1\u0026quot; ## [8] \u0026quot;14.3,8,360,245,3.21,3.57,15.84,0,0,3,4\u0026quot; ## [9] \u0026quot;24.4,4,146.7,62,3.69,3.19,20,1,0,4,2\u0026quot; ## [10] \u0026quot;22.8,4,140.8,95,3.92,3.15,22.9,1,0,4,2\u0026quot;\r # Identificamos o separador de colunas, selecionamos a função adequada\rread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r O console nos mostra que a leitura do banco foi completada, mas também mostra Column Specification. Isto indica qual o tipo de dado que foi identificado automaticamente numa análise feita pela função guess_parser. Em diversos casos, nós podemos querer identificar manualmente as colunas. Vejamos um exemplo:\n# Vamos identificar as colunas com spec\rspec_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;))\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## cols(\r## mpg = col_double(),\r## cyl = col_double(),\r## disp = col_double(),\r## hp = col_double(),\r## drat = col_double(),\r## wt = col_double(),\r## qsec = col_double(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r # Copia e cola, modifica as colunas que queremos alterar\rspec_cols \u0026lt;- cols(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\rdisp = col_double(),\rhp = col_double(),\rdrat = col_double(),\rwt = col_double(),\rqsec = col_double(),\rvs = col_double(),\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols)\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r # Para importar apenas colunas selecionadas, utilize 'cols_only()'\rspec_cols2 \u0026lt;- cols_only(\rmpg = col_double(),\rcyl = col_factor(), # N de cilindros do automóvel\ram = col_factor(c(\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;)), # Transmissão automática ou manual\rgear = col_double(),\rcarb = col_double()\r)\rdf2 \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = spec_cols2)\rdf2\r ## # A tibble: 32 x 5\r## mpg cyl am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 1 4 4\r## 2 21 6 1 4 4\r## 3 22.8 4 1 4 1\r## 4 21.4 6 0 3 1\r## 5 18.7 8 0 3 2\r## 6 18.1 6 0 3 1\r## 7 14.3 8 0 3 4\r## 8 24.4 4 0 4 2\r## 9 22.8 4 0 4 2\r## 10 19.2 6 0 4 4\r## # ... with 22 more rows\r # Para indicar os tipos de colunas de um jeito mais sucinto, utilize uma string:\rdf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = \u0026quot;dfddddddfdd\u0026quot;)\r# Só cuidado pra não perder a conta dos ds!\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nmeu_locale \u0026lt;- locale(encoding = \u0026quot;UTF-8\u0026quot;, decimal_mark = \u0026quot;,\u0026quot;, grouping_mark = \u0026quot;.\u0026quot;)\r Aí é só passar isso pra uma das funções do pacote sob o argumento locale\nread_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), locale = meu_locale)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## mpg = col_number(),\r## cyl = col_double(),\r## disp = col_number(),\r## hp = col_double(),\r## drat = col_number(),\r## wt = col_number(),\r## qsec = col_number(),\r## vs = col_double(),\r## am = col_double(),\r## gear = col_double(),\r## carb = col_double()\r## )\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 39 262 1646 0 1 4 4\r## 2 21 6 160 110 39 2875 1702 0 1 4 4\r## 3 228 4 108 93 385 232 1861 1 1 4 1\r## 4 214 6 258 110 308 3215 1944 1 0 3 1\r## 5 187 8 360 175 315 344 1702 0 0 3 2\r## 6 181 6 225 105 276 346 2022 1 0 3 1\r## 7 143 8 360 245 321 357 1584 0 0 3 4\r## 8 244 4 1467 62 369 319 20 1 0 4 2\r## 9 228 4 1408 95 392 315 229 1 0 4 2\r## 10 192 6 1676 123 392 344 183 1 0 4 4\r## # ... with 22 more rows\r Existe ainda a possibilidade de ler dados colunados com largura-fixa. readr implementa quatro funções diferentes para ajudar na construção do dicionário:\n# Nossos dados\rx \u0026lt;- readr_example(\u0026quot;fwf-sample.txt\u0026quot;)\rread_lines(x, n_max = 10)\r ## [1] \u0026quot;John Smith WA 418-Y11-4111\u0026quot;\r## [2] \u0026quot;Mary Hartford CA 319-Z19-4341\u0026quot;\r## [3] \u0026quot;Evan Nolan IL 219-532-c301\u0026quot;\r # separados por espaço\rdic1 \u0026lt;- fwf_empty(x)\rdic1\r ## $begin\r## [1] 0 5 20 30\r## ## $end\r## [1] 4 13 22 NA\r## ## $skip\r## [1] 0\r## ## $col_names\r## [1] \u0026quot;X1\u0026quot; \u0026quot;X2\u0026quot; \u0026quot;X3\u0026quot; \u0026quot;X4\u0026quot;\r df \u0026lt;- read_fwf(file = x, col_positions = dic1)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character(),\r## X4 = col_character()\r## )\r df\r ## # A tibble: 3 x 4\r## X1 X2 X3 X4 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando a largura da coluna\rlarguras \u0026lt;- c(20, 10, 12)\rdic2 \u0026lt;- fwf_widths(larguras)\rdic2\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 30 X2 ## 3 30 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic2)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando onde cada coluna começa e termina\rcomeca \u0026lt;- c(1, 21, 30)\rtermina \u0026lt;- c(20, 29, 42)\rdic3 \u0026lt;- fwf_positions(comeca, termina)\rdic3\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 X1 ## 2 20 29 X2 ## 3 29 42 X3\r df \u0026lt;- read_fwf(file = x, col_positions = dic3)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## X1 X2 X3 ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r # indicando pares nome-valor\rdic4 \u0026lt;- fwf_cols(\rnome = c(1, 20),\ruf = c(21, 29),\rnumero = c(30, 42))\rdic4\r ## # A tibble: 3 x 3\r## begin end col_names\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 0 20 nome ## 2 20 29 uf ## 3 29 42 numero\r df \u0026lt;- read_fwf(file = x, col_positions = dic4)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## nome = col_character(),\r## uf = col_character(),\r## numero = col_character()\r## )\r df\r ## # A tibble: 3 x 3\r## nome uf numero ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 John Smith WA 418-Y11-4111\r## 2 Mary Hartford CA 319-Z19-4341\r## 3 Evan Nolan IL 219-532-c301\r Especificar dicionários para arquivos colunados é um pé-no-saco, por sorte, existem pacotes que já fizeram parte desse trabalho por nós. O readr não melhora muita o serviço manual de construção de dicionários, o que ele oferece é um ganho de performance tremendo. read_fwf é centenas de vezes mais rápido que o base read.fwf.\nEm termos do que o pacote faz, é basicamente isso. A única coisa que falta mencionar é que ele importa os dados como tibbles ao invés do data.frame padrão, mas isso já é um ótimo gancho pra nossa próxima parte.\ntibbles Tibbles são basicamente data.frames com um método mais bonitinho de print. Elas automaticamente se ajustam a largura da sua tela, omitindo as colunas que estouram, e por padrão imprimem só as 10 primeiras observações. Outras características que pessoalmente gosto, é que elas informam o tipo de variável junto com o nome, arrendondam digitos significativos, destacam números grandes, negativos, NAs e etc.\ndf \u0026lt;- read_csv(readr_example(\u0026quot;mtcars.csv\u0026quot;), col_types = cols()) # omitir a especificação\rdf\r ## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4\r## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4\r## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1\r## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2\r## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1\r## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4\r## # ... with 22 more rows\r Do ponto de vista prático, elas funcionam exatamente igual a data.frames, tudo que você pode fazer com um data.frame, você faz com tibbles. O que elas trazem de novidade é:\n Elas nunca mudam o tipo de dado inputado.  df1 \u0026lt;- data.frame(x = list(1:5, 1:10, 1:20))\rdf1\r ## x.1.5 x.1.10 x.1.20\r## 1 1 1 1\r## 2 2 2 2\r## 3 3 3 3\r## 4 4 4 4\r## 5 5 5 5\r## 6 1 6 6\r## 7 2 7 7\r## 8 3 8 8\r## 9 4 9 9\r## 10 5 10 10\r## 11 1 1 11\r## 12 2 2 12\r## 13 3 3 13\r## 14 4 4 14\r## 15 5 5 15\r## 16 1 6 16\r## 17 2 7 17\r## 18 3 8 18\r## 19 4 9 19\r## 20 5 10 20\r df2 \u0026lt;- tibble(x = list(1:5, 1:10, 1:20))\rdf2\r ## # A tibble: 3 x 1\r## x ## \u0026lt;list\u0026gt; ## 1 \u0026lt;int [5]\u0026gt; ## 2 \u0026lt;int [10]\u0026gt;\r## 3 \u0026lt;int [20]\u0026gt;\r  Elas nunca ajustam os nomes das variáveis  names(data.frame(`nome hipster` = 1))\r ## [1] \u0026quot;nome.hipster\u0026quot;\r names(tibble(`nome hipster` = 1))\r ## [1] \u0026quot;nome hipster\u0026quot;\r  Ela avalia cada argumento de forma \u0026ldquo;preguiçosa\u0026rdquo; e sequencial  # erro\rdata.frame(x = 1:5, y = x ^ 2)\r ## Error in x^2: argumento não-numérico para operador binário\r # funciona\rtibble(x = 1:5, y = x ^ 2)\r ## # A tibble: 5 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 4\r## 3 3 9\r## 4 4 16\r## 5 5 25\r  Ela nunca utiliza row.names  head(data.frame(state.x77))\r ## Population Income Illiteracy Life.Exp Murder HS.Grad Frost Area\r## Alabama 3615 3624 2.1 69.05 15.1 41.3 20 50708\r## Alaska 365 6315 1.5 69.31 11.3 66.7 152 566432\r## Arizona 2212 4530 1.8 70.55 7.8 58.1 15 113417\r## Arkansas 2110 3378 1.9 70.66 10.1 39.9 65 51945\r## California 21198 5114 1.1 71.71 10.3 62.6 20 156361\r## Colorado 2541 4884 0.7 72.06 6.8 63.9 166 103766\r as_tibble(state.x77)\r ## # A tibble: 50 x 8\r## Population Income Illiteracy `Life Exp` Murder `HS Grad` Frost Area\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 3615 3624 2.1 69.0 15.1 41.3 20 50708\r## 2 365 6315 1.5 69.3 11.3 66.7 152 566432\r## 3 2212 4530 1.8 70.6 7.8 58.1 15 113417\r## 4 2110 3378 1.9 70.7 10.1 39.9 65 51945\r## 5 21198 5114 1.1 71.7 10.3 62.6 20 156361\r## 6 2541 4884 0.7 72.1 6.8 63.9 166 103766\r## 7 3100 5348 1.1 72.5 3.1 56 139 4862\r## 8 579 4809 0.9 70.1 6.2 54.6 103 1982\r## 9 8277 4815 1.3 70.7 10.7 52.6 11 54090\r## 10 4931 4091 2 68.5 13.9 40.6 60 58073\r## # ... with 40 more rows\r  Ela muda a \u0026ldquo;regra da reciclagem\u0026rdquo;: apenas são aceitos vetores unitários ou vetores de tamanho igual aos demais  data.frame(x = 1:10, y = 1:5)\r ## x y\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r # erro\rtibble(x = 1:10, y = 1:5)\r ## Error: Tibble columns must have compatible sizes.\r## * Size 10: Existing data.\r## * Size 5: Column `y`.\r## i Only values of size one are recycled.\r tibble(x = 1:10, y = 1)\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1\r## 2 2 1\r## 3 3 1\r## 4 4 1\r## 5 5 1\r## 6 6 1\r## 7 7 1\r## 8 8 1\r## 9 9 1\r## 10 10 1\r tibble(x = 1:10, y = c(1:5, 1:5))\r ## # A tibble: 10 x 2\r## x y\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1 1\r## 2 2 2\r## 3 3 3\r## 4 4 4\r## 5 5 5\r## 6 6 1\r## 7 7 2\r## 8 8 3\r## 9 9 4\r## 10 10 5\r  Tibbles são estritas com relação as operações de subsetting com [  df1 \u0026lt;- data.frame(x = 1:3, y = 3:1)\rclass(df1[,1:2])\r ## [1] \u0026quot;data.frame\u0026quot;\r class(df1[,1])\r ## [1] \u0026quot;integer\u0026quot;\r df2 \u0026lt;- tibble(x = 1:3, y = 3:1)\rclass(df2[, 1:2])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r class(df2[, 1])\r ## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r # Se quiser extrair só uma coluna, utilize '[[' ou '$'\rclass(df2[[1]])\r ## [1] \u0026quot;integer\u0026quot;\r class(df2$x)\r ## [1] \u0026quot;integer\u0026quot;\r Elas também não aceitam \u0026lsquo;partial matching\u0026rsquo; de nomes de variáveis.\ndf \u0026lt;- data.frame(nome_de_cavalo = 1)\rdf$nome\r ## [1] 1\r df2 \u0026lt;- tibble(nome_de_cavalo = 1)\rdf2$nome\r ## Warning: Unknown or uninitialised column: `nome`.\r ## NULL\r tidyr Ok, nossos dados estão no R, mas, muitas vezes, não estão no formato adequado. De maneira geral, analistas de dados vão dar preferência a um formato parecido com este:\nIsto tem uma razão de ser que deve tornar-se óbvia quando tentarmos realizar as operações de transformação de variáveis, visualização, modelos, etc. Porém, muitas vezes outras considerações são feitas na hora registrar os dados, armazená-los, apresentá-los ao público, por isso, frequentemente nossos dados não estão no formato tidy e precisam ser reformatados. Essa é uma das principais tarefas do tidyr e é nela que vamos nos concentrar.\nAtente que reformatação, como muitos outros aspectos da análise de dados, não é receita de bolo. Muitas vezes o formato desejado não é óbvio, muito menos os passos necessários para chegar lá. Porém, vou apresentar as ferramentas e alguns exemplos simples que cobrem muitos dos nossos casos de uso.\nlibrary(tidyr)\rwho\r ## # A tibble: 7,240 x 60\r## country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghani~ AF AFG 1980 NA NA NA NA\r## 2 Afghani~ AF AFG 1981 NA NA NA NA\r## 3 Afghani~ AF AFG 1982 NA NA NA NA\r## 4 Afghani~ AF AFG 1983 NA NA NA NA\r## 5 Afghani~ AF AFG 1984 NA NA NA NA\r## 6 Afghani~ AF AFG 1985 NA NA NA NA\r## 7 Afghani~ AF AFG 1986 NA NA NA NA\r## 8 Afghani~ AF AFG 1987 NA NA NA NA\r## 9 Afghani~ AF AFG 1988 NA NA NA NA\r## 10 Afghani~ AF AFG 1989 NA NA NA NA\r## # ... with 7,230 more rows, and 52 more variables: new_sp_m4554 \u0026lt;int\u0026gt;,\r## # new_sp_m5564 \u0026lt;int\u0026gt;, new_sp_m65 \u0026lt;int\u0026gt;, new_sp_f014 \u0026lt;int\u0026gt;,\r## # new_sp_f1524 \u0026lt;int\u0026gt;, new_sp_f2534 \u0026lt;int\u0026gt;, new_sp_f3544 \u0026lt;int\u0026gt;,\r## # new_sp_f4554 \u0026lt;int\u0026gt;, new_sp_f5564 \u0026lt;int\u0026gt;, new_sp_f65 \u0026lt;int\u0026gt;,\r## # new_sn_m014 \u0026lt;int\u0026gt;, new_sn_m1524 \u0026lt;int\u0026gt;, new_sn_m2534 \u0026lt;int\u0026gt;,\r## # new_sn_m3544 \u0026lt;int\u0026gt;, new_sn_m4554 \u0026lt;int\u0026gt;, new_sn_m5564 \u0026lt;int\u0026gt;,\r## # new_sn_m65 \u0026lt;int\u0026gt;, new_sn_f014 \u0026lt;int\u0026gt;, new_sn_f1524 \u0026lt;int\u0026gt;,\r## # new_sn_f2534 \u0026lt;int\u0026gt;, new_sn_f3544 \u0026lt;int\u0026gt;, new_sn_f4554 \u0026lt;int\u0026gt;,\r## # new_sn_f5564 \u0026lt;int\u0026gt;, new_sn_f65 \u0026lt;int\u0026gt;, new_ep_m014 \u0026lt;int\u0026gt;,\r## # new_ep_m1524 \u0026lt;int\u0026gt;, new_ep_m2534 \u0026lt;int\u0026gt;, new_ep_m3544 \u0026lt;int\u0026gt;,\r## # new_ep_m4554 \u0026lt;int\u0026gt;, new_ep_m5564 \u0026lt;int\u0026gt;, new_ep_m65 \u0026lt;int\u0026gt;,\r## # new_ep_f014 \u0026lt;int\u0026gt;, new_ep_f1524 \u0026lt;int\u0026gt;, new_ep_f2534 \u0026lt;int\u0026gt;,\r## # new_ep_f3544 \u0026lt;int\u0026gt;, new_ep_f4554 \u0026lt;int\u0026gt;, new_ep_f5564 \u0026lt;int\u0026gt;,\r## # new_ep_f65 \u0026lt;int\u0026gt;, newrel_m014 \u0026lt;int\u0026gt;, newrel_m1524 \u0026lt;int\u0026gt;,\r## # newrel_m2534 \u0026lt;int\u0026gt;, newrel_m3544 \u0026lt;int\u0026gt;, newrel_m4554 \u0026lt;int\u0026gt;,\r## # newrel_m5564 \u0026lt;int\u0026gt;, newrel_m65 \u0026lt;int\u0026gt;, newrel_f014 \u0026lt;int\u0026gt;,\r## # newrel_f1524 \u0026lt;int\u0026gt;, newrel_f2534 \u0026lt;int\u0026gt;, newrel_f3544 \u0026lt;int\u0026gt;,\r## # newrel_f4554 \u0026lt;int\u0026gt;, newrel_f5564 \u0026lt;int\u0026gt;, newrel_f65 \u0026lt;int\u0026gt;\r Esse é um banco de dados difícil de analisar, ele tem 60 colunas, indicando o número de casos de tuberculose em diversos estágios da doença, por país e ano. O problema é que ao invés de termos algo como:\ntribble(\r~pais, ~ano, ~tipo, ~idade, ~casos,\r\u0026quot;brasil\u0026quot;, 1980, \u0026quot;extrapulmonar\u0026quot;, \u0026quot;15-24\u0026quot;, 10,\r\u0026quot;brasil\u0026quot;, 1990, \u0026quot;relapso\u0026quot;, \u0026quot;15-24\u0026quot;, 10\r)\r ## # A tibble: 2 x 5\r## pais ano tipo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 brasil 1980 extrapulmonar 15-24 10\r## 2 brasil 1990 relapso 15-24 10\r As informações de tipo de tuberculose e idade dos pacientes estão espalhadas pelas colunas. Pra encurtar a história, precisamos \u0026ldquo;tombar\u0026rdquo; esse banco para que essas colunas se tornem um novo conjunto de variáveis. Vamos passo a passo.\n# Primeiro, vamos excluir as colunas iso2 e iso3, porque elas são a mesma informação redundante\rwho$iso2 \u0026lt;- NULL\rwho$iso3 \u0026lt;- NULL\rwho1 \u0026lt;- pivot_longer(who,\rcols = c(new_sp_m014:newrel_f65),\rnames_to = \u0026quot;tipo_tb\u0026quot;,\rvalues_to = \u0026quot;casos\u0026quot;,\rvalues_drop_na = TRUE)\rwho1\r ## # A tibble: 76,046 x 4\r## country year tipo_tb casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 new_sp_m014 0\r## 2 Afghanistan 1997 new_sp_m1524 10\r## 3 Afghanistan 1997 new_sp_m2534 6\r## 4 Afghanistan 1997 new_sp_m3544 3\r## 5 Afghanistan 1997 new_sp_m4554 5\r## 6 Afghanistan 1997 new_sp_m5564 2\r## 7 Afghanistan 1997 new_sp_m65 0\r## 8 Afghanistan 1997 new_sp_f014 5\r## 9 Afghanistan 1997 new_sp_f1524 38\r## 10 Afghanistan 1997 new_sp_f2534 36\r## # ... with 76,036 more rows\r Nosso primeiro passo é transformar todas as colunas de novos casos em um par de colunas:\n cols indica quais colunas serão tombadas e quais serão mantidas. Uma coluna names_to recebe as categorias da variável. Uma coluna values_to recebe os valores das células. values_drop_na é uma opção para eliminar células vazias.  Essa primeira transformação já nos dá um banco de dados um pouco mais amigável, porém, ainda temos variáveis \u0026ldquo;presas\u0026rdquo; na coluna tipo_tb. Vamos tentar soltá-las.\n# primeiro, corrigir uma pequena inconsistencia:\runique(who1$tipo_tb)\r ## [1] \u0026quot;new_sp_m014\u0026quot; \u0026quot;new_sp_m1524\u0026quot; \u0026quot;new_sp_m2534\u0026quot; \u0026quot;new_sp_m3544\u0026quot; \u0026quot;new_sp_m4554\u0026quot;\r## [6] \u0026quot;new_sp_m5564\u0026quot; \u0026quot;new_sp_m65\u0026quot; \u0026quot;new_sp_f014\u0026quot; \u0026quot;new_sp_f1524\u0026quot; \u0026quot;new_sp_f2534\u0026quot;\r## [11] \u0026quot;new_sp_f3544\u0026quot; \u0026quot;new_sp_f4554\u0026quot; \u0026quot;new_sp_f5564\u0026quot; \u0026quot;new_sp_f65\u0026quot; \u0026quot;new_sn_m014\u0026quot; ## [16] \u0026quot;new_sn_m1524\u0026quot; \u0026quot;new_sn_m2534\u0026quot; \u0026quot;new_sn_m3544\u0026quot; \u0026quot;new_sn_m4554\u0026quot; \u0026quot;new_sn_m5564\u0026quot;\r## [21] \u0026quot;new_sn_m65\u0026quot; \u0026quot;new_ep_m014\u0026quot; \u0026quot;new_ep_m1524\u0026quot; \u0026quot;new_ep_m2534\u0026quot; \u0026quot;new_ep_m3544\u0026quot;\r## [26] \u0026quot;new_ep_m4554\u0026quot; \u0026quot;new_ep_m5564\u0026quot; \u0026quot;new_ep_m65\u0026quot; \u0026quot;new_sn_f014\u0026quot; \u0026quot;newrel_m014\u0026quot; ## [31] \u0026quot;newrel_f014\u0026quot; \u0026quot;new_sn_f1524\u0026quot; \u0026quot;new_sn_f2534\u0026quot; \u0026quot;new_sn_f3544\u0026quot; \u0026quot;new_sn_f4554\u0026quot;\r## [36] \u0026quot;new_sn_f5564\u0026quot; \u0026quot;new_sn_f65\u0026quot; \u0026quot;new_ep_f014\u0026quot; \u0026quot;new_ep_f1524\u0026quot; \u0026quot;new_ep_f2534\u0026quot;\r## [41] \u0026quot;new_ep_f3544\u0026quot; \u0026quot;new_ep_f4554\u0026quot; \u0026quot;new_ep_f5564\u0026quot; \u0026quot;new_ep_f65\u0026quot; \u0026quot;newrel_m1524\u0026quot;\r## [46] \u0026quot;newrel_m2534\u0026quot; \u0026quot;newrel_m3544\u0026quot; \u0026quot;newrel_m4554\u0026quot; \u0026quot;newrel_m5564\u0026quot; \u0026quot;newrel_m65\u0026quot; ## [51] \u0026quot;newrel_f1524\u0026quot; \u0026quot;newrel_f2534\u0026quot; \u0026quot;newrel_f3544\u0026quot; \u0026quot;newrel_f4554\u0026quot; \u0026quot;newrel_f5564\u0026quot;\r## [56] \u0026quot;newrel_f65\u0026quot;\r # Notem que newrel deveria ser new_rel\r# Alguns de vocês devem conhecer 'gsub'\rwho1$tipo_tb \u0026lt;- gsub(\u0026quot;newrel\u0026quot;, \u0026quot;new_rel\u0026quot;, who1$tipo_tb)\r# Agora, podemos usar outra função chave do tidyr, 'separate'\rwho2 \u0026lt;- who1 %\u0026gt;% separate(col = tipo_tb,\rinto = c(NA, \u0026quot;tipo_tb\u0026quot;, \u0026quot;sexo_idade\u0026quot;),\rsep = \u0026quot;_\u0026quot;)\rwho2\r ## # A tibble: 76,046 x 5\r## country year tipo_tb sexo_idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m014 0\r## 2 Afghanistan 1997 sp m1524 10\r## 3 Afghanistan 1997 sp m2534 6\r## 4 Afghanistan 1997 sp m3544 3\r## 5 Afghanistan 1997 sp m4554 5\r## 6 Afghanistan 1997 sp m5564 2\r## 7 Afghanistan 1997 sp m65 0\r## 8 Afghanistan 1997 sp f014 5\r## 9 Afghanistan 1997 sp f1524 38\r## 10 Afghanistan 1997 sp f2534 36\r## # ... with 76,036 more rows\r # E outra passagem de separate para separar a idade do sexo\rwho3 \u0026lt;- who2 %\u0026gt;% separate(col = sexo_idade,\rinto = c(\u0026quot;sexo\u0026quot;, \u0026quot;idade\u0026quot;),\rsep = 1)\rwho3\r ## # A tibble: 76,046 x 6\r## country year tipo_tb sexo idade casos\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 Afghanistan 1997 sp m 014 0\r## 2 Afghanistan 1997 sp m 1524 10\r## 3 Afghanistan 1997 sp m 2534 6\r## 4 Afghanistan 1997 sp m 3544 3\r## 5 Afghanistan 1997 sp m 4554 5\r## 6 Afghanistan 1997 sp m 5564 2\r## 7 Afghanistan 1997 sp m 65 0\r## 8 Afghanistan 1997 sp f 014 5\r## 9 Afghanistan 1997 sp f 1524 38\r## 10 Afghanistan 1997 sp f 2534 36\r## # ... with 76,036 more rows\r Bem melhor, não acham? Estamos agora com um banco de dados muito mais adequado para uma análise de dados em R. Cada linha é uma observação, cada coluna é uma informação sobre ela.\nAlguns de vocês podem ter reparado que fizemos um caminho em que nosso banco de dados passou de ter muitas colunas para muitas linhas (ficou mais \u0026ldquo;longo\u0026rdquo;) e depois precisamos separar algumas das colunas que criamos em outras (o que fizemos com separate). Podemos facilmente imaginar situações em que queremos fazer o caminho inverso: transformar um banco do formato longo para o formato com mais colunas e unir colunas separadas em uma nova. Vamos ver um exemplo.\n# Exemplo adaptado de https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population\rpopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Imagine que, por qualquer motivo, você prefira trabalhar com uma variável \u0026ldquo;Data\u0026rdquo; ao invés de dia, mês e ano. Podemos usar unite:\npopulacao2 \u0026lt;- populacao %\u0026gt;% unite(col = Data, Day, Month, Year, sep = \u0026quot; \u0026quot;)\rpopulacao2\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19 May 20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19 May 20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census result[9]\r O outro problema que precisamos resolver frequentemente, é separar um par de variáveis em diversas colunas, fazendo o caminho inverso que fizemos no caso do dataset da OMS.\nus_rent_income\r ## # A tibble: 104 x 5\r## GEOID NAME variable estimate moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama income 24476 136\r## 2 01 Alabama rent 747 3\r## 3 02 Alaska income 32940 508\r## 4 02 Alaska rent 1200 13\r## 5 04 Arizona income 27517 148\r## 6 04 Arizona rent 972 4\r## 7 05 Arkansas income 23789 165\r## 8 05 Arkansas rent 709 5\r## 9 06 California income 29454 109\r## 10 06 California rent 1358 3\r## # ... with 94 more rows\r No exemplo acima, queremos separar em colunas os valores das variáveis de renda e valor do aluguel. Esse tipo de operação tem um certo grau de abstração que me deu bastante dor de cabeça para entender inicialmente, então vamos olhar com carinho para o que queremos ter depois da transformação.\nus_rent_income2 \u0026lt;- tribble(\r~GEOID, ~NAME, ~income_estimate, ~rent_estimate, ~income_moe, ~rent_moe,\r\u0026quot;01\u0026quot;, \u0026quot;Alabama\u0026quot;, 24476, 747, 136, 3,\r\u0026quot;02\u0026quot;, \u0026quot;Alaska\u0026quot;, 32940, 1200, 508, 13\r)\rus_rent_income2\r ## # A tibble: 2 x 6\r## GEOID NAME income_estimate rent_estimate income_moe rent_moe\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r O banco que queremos tem uma cara assim. Ele tem mais colunas novas e menos linhas, já que eu tinha no formato tidy uma variável chamada \u0026ldquo;variable\u0026rdquo; que guardava os valores renda e aluguel e duas colunas que guardavam os valores da estimativa e do moe. Agora, eu vou ter 4 colunas, duas para as estimativas de renda e aluguel e duas para os moes das mesmas variáveis. Como especificar isso para o banco todo? Usando pivot_wider.\nus_rent_income %\u0026gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe))\r ## # A tibble: 52 x 6\r## GEOID NAME estimate_income estimate_rent moe_income moe_rent\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 01 Alabama 24476 747 136 3\r## 2 02 Alaska 32940 1200 508 13\r## 3 04 Arizona 27517 972 148 4\r## 4 05 Arkansas 23789 709 165 5\r## 5 06 California 29454 1358 109 3\r## 6 08 Colorado 32401 1125 109 5\r## 7 09 Connecticut 35326 1123 195 5\r## 8 10 Delaware 31560 1076 247 10\r## 9 11 District of Columbia 43198 1424 681 17\r## 10 12 Florida 25952 1077 70 3\r## # ... with 42 more rows\r As funções pivot_ tem diversos outros argumentos e cobrem diversos casos de uso. Vejam este exemplo da documentação de pivot_longer:\nanscombe\r ## x1 x2 x3 x4 y1 y2 y3 y4\r## 1 10 10 10 8 8.04 9.14 7.46 6.58\r## 2 8 8 8 8 6.95 8.14 6.77 5.76\r## 3 13 13 13 8 7.58 8.74 12.74 7.71\r## 4 9 9 9 8 8.81 8.77 7.11 8.84\r## 5 11 11 11 8 8.33 9.26 7.81 8.47\r## 6 14 14 14 8 9.96 8.10 8.84 7.04\r## 7 6 6 6 8 7.24 6.13 6.08 5.25\r## 8 4 4 4 19 4.26 3.10 5.39 12.50\r## 9 12 12 12 8 10.84 9.13 8.15 5.56\r## 10 7 7 7 8 4.82 7.26 6.42 7.91\r## 11 5 5 5 8 5.68 4.74 5.73 6.89\r Podemos transformar esse banco de dados rapidamente usando um dos argumentos de pivot_longer, chamado names_pattern.\nanscombe %\u0026gt;% pivot_longer(everything(),\rnames_to = c(\u0026quot;.value\u0026quot;, \u0026quot;set\u0026quot;),\rnames_pattern = \u0026quot;(.)(.)\u0026quot;)\r ## # A tibble: 44 x 3\r## set x y\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10 8.04\r## 2 2 10 9.14\r## 3 3 10 7.46\r## 4 4 8 6.58\r## 5 1 8 6.95\r## 6 2 8 8.14\r## 7 3 8 6.77\r## 8 4 8 5.76\r## 9 1 13 7.58\r## 10 2 13 8.74\r## # ... with 34 more rows\r Esse exemplo é interessante, porque ele se aproveita de uma \u0026ldquo;regular expression\u0026rdquo;, tema da parte do nosso curso em que falaremos sobre manipulação de strings com o stringr. Resumidas as contas, as colunas se chamam \u0026ldquo;x1, x2, x3 \u0026hellip;\u0026rdquo; e a string \u0026ldquo;(.)(.)\u0026rdquo; indica que há dois \u0026ldquo;grupos\u0026rdquo; formados por um caractere cada. A string \u0026ldquo;.value\u0026rdquo; que vai no argumento de cima é um atalho da função para dizer \u0026ldquo;pegue o valor de todas as células das variáveis selecionadas\u0026rdquo;, aqui, todas. Ou seja, ele indica para a função que o primeiro caractere \u0026ldquo;x\u0026rdquo; ou \u0026ldquo;y\u0026rdquo; definirá uma nova variável e armazenará os valores das celulas, enquanto o segundo grupo \u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo; ou \u0026ldquo;4\u0026rdquo; formará uma segunda variável chamada \u0026ldquo;set\u0026rdquo; que contém apenas os nomes das colunas. Deu um nó na cabeça?\nUma última preocupação ao utilizar a reformatação de dados é o que ocorre com os valores NA. Vejamos este exemplo:\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\r Existem dois tipos de valor nulo, explícito se diz de um valor nulo como aquele NA que aparece na variável lucro. Implícito é o valor que ocorre no primeiro quadrimestre de 2016, onde sequer foi adicionada uma linha no banco de dados. Os valores implícitos são muito sacanas, porque eles não são imediatamente visíveis.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro)\r ## # A tibble: 4 x 3\r## qdr `2015` `2016`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1.88 NA ## 2 2 0.59 0.92\r## 3 3 0.35 0.17\r## 4 4 NA 2.66\r Ao transformar o banco, o valor implícito ficou explícito. Caso você não esteja interessado neste valor, você pode passar o values_drop_na durante a transformação de volta ao formato original.\nacoes %\u0026gt;% pivot_wider(names_from = ano, values_from = lucro) %\u0026gt;% pivot_longer(c(`2015`, `2016`),\rnames_to = \u0026quot;ano\u0026quot;,\rvalues_to = \u0026quot;lucro\u0026quot;,\rvalues_drop_na = TRUE)\r ## # A tibble: 6 x 3\r## qdr ano lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2015 1.88\r## 2 2 2015 0.59\r## 3 2 2016 0.92\r## 4 3 2015 0.35\r## 5 3 2016 0.17\r## 6 4 2016 2.66\r Que faz os valores missing desaparecerem do resultado.\ncomplete pode ser usada pra tornar valores implícitos, explícitos! A função toma todas as colunas pedidas e verifica todas as combinações possíveis de valores, preenchendo as lacunas com NA. Cuidado ao utilizar complete com valores numéricos ou conjuntos de colunas com muitas combinações possíveis, pois o número de combinações pode ser infinitamente grande e travar sua sessão!\nacoes %\u0026gt;% complete(ano, qdr)\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Pra encerrar, fill serve para aqueles casos em que um valor missing indica que a última observação deve ser repetida. Pesquisadores brasileiros das antigas podem lembrar-se do Censo de 1991, em que o IBGE registrava os arquivos de domícilio e pessoas com esse sistema. Em inglês, isso se chama LOCF, ou \u0026ldquo;last observation carried forward\u0026rdquo;.\ntreatment \u0026lt;- tribble(\r~ person, ~ treatment, ~response,\r\u0026quot;Derrick Whitmore\u0026quot;, 1, 7,\rNA, 2, 10,\rNA, 3, 9,\r\u0026quot;Katherine Burke\u0026quot;, 1, 4\r)\rtreatment\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 \u0026lt;NA\u0026gt; 2 10\r## 3 \u0026lt;NA\u0026gt; 3 9\r## 4 Katherine Burke 1 4\r treatment %\u0026gt;% fill(person)\r ## # A tibble: 4 x 3\r## person treatment response\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Derrick Whitmore 1 7\r## 2 Derrick Whitmore 2 10\r## 3 Derrick Whitmore 3 9\r## 4 Katherine Burke 1 4\r tidyr tem também outras funcionalidades relevantes para modelagem estatística, mas acho que isso sai um pouco do escopo do curso. Quem sabe a gente não faz um curso posterior só sobre modelagem no tidyverse?\nRevisão readr O pacote readr apresenta uma família de funções para substituir as funções do base relacionadas a importação de arquivos em formato texto, seja delimitado ou largura-fixa. São elas,\n read_delim read_csv read_csv2 read_tsv read_table read_fwf  E assim sucessivamente. Durante o processo de importação, você pode querer especificar o tipo de coluna com cols ou cols_only, usando o argumento col_types. Ou use uma string do tipo \u0026ldquo;ddcdiDT\u0026rdquo; em que cada letra é um tipo de variável.\n col_integer col_double col_factor col_character  Etc. Você também pode querer definir características de localização, como a codificação de caracteres, os separadores de decimal e de milhar e etc. A melhor forma de fazer isso é definir um locale.\nAh, e você sempre pode salvar com write_, inclusive salvando/lendo compactado para bzip, gzip ou xzip.\ntibble Tibbles são uma versão do data.frame com algumas regrinhas novas. Vou apenas repetí-las aqui de forma resumida.\n tibbles tem um método print mais bonito e amigável, especialmente para bancos com muitas observações e variáveis. elas são estritas com operações de subsetting com [ e $. elas não aceita a reciclagem de argumento de tamanho diferente de 1.  tidyr tidyr é um pacote de reformatação de bancos, criando novas linhas e colunas a partir da reorganização das variáveis e valores existentes. Suas principais operações são:\n pivot_longer para converter colunas em linhas pivot_wider para converter linhas em colunas separate para separar uma coluna em várias com base em caracteres unite para unir diversas colunas em uma com base em caracteres  Ufa. Acabou né? Posso ir dormir já? Claro, só fazer uns exercícios!\nExercícios  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  file \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.  # Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\rbillboard  ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r  Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?\n  O que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.\n  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r  Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?\n  Compare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?\n  Agradecimentos Esse material é uma adaptação livre das vinhetas dos pacotes tidyr, readr e tibble e do capítulo Tidy Data do R for Data Science, de Wickham \u0026amp; Grolemund.\n","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"0bad4868b4cebec13d81438fabee26ad","permalink":"https://laddem.github.io/courses/tidyverse/dia1/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia1/","section":"courses","summary":"Um modelo de ciência de dados Uma forma esquemática, mas útil de encarar o processo de análise de dados e de produção de conhecimento a partir de informações secundárias é esta figura:","tags":null,"title":"readr, tibble e tidyr","type":"book"},{"authors":null,"categories":null,"content":"\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\rOperações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.\nO pacote stringr é uma série de adaptações da biblioteca stringi e serve para a manipulação de variáveis texto, incluindo funções para detecção, modificação, substituição, remoção de texto em variáveis caractere. Para dominar esse assunto, é necessário compreender o conceito de “regex,” ou “expressão regular,” que foge um pouco do escopo do curso, mas que será introduzido brevemente.\nO pacote forcats contém uma série de funções para trabalhar com o tipo factor. São funções que facilitam operações envolvendo esse tipo de variável, como contagens, troca dos nomes das categorias, agrupamento de categorias, recodificação, plotagem, etc.\nO pacote dplyr é um dos pilares do tidyverse e ele tem dois papéis principais: operações de manipulação de banco de dados simples e operações de bancos de dados relacionais. No primeiro tipo são incluídas as operações de criação e modificação de variáveis, medidas resumo globais e por grupos, seleção de variáveis, mudança da ordem das linhas e colunas, etc. No segundo tipo, são as operações de tipo _join, em que uma variável chave é utilizada para combinar registros de dois bancos de dados distintos.\nOs pacotes stringr e forcats são mais diretos, mas o dplyr pode representar um certo nível de abstração que pode incomodar usuários de longa data do R, portanto, vamos nos esforçar para demonstrar as vantagens de mudar seu workflow para incluir as funções desse pacote através de comparações com o R base.\ndplyr dplyr para manipulação de dados Talvez o pacote mais utilizado de todo o tidyverse, dplyr é um pacote de manipulação de bancos de dados inspirado pela linguagem SQL. A ideia é concatenar operações de seleção de variáveis, filtragem de observação, arranjo e ordenamento, derivação de variáveis, computação de medidas resumo para o banco todo ou para grupos. As funções básicas e mais utilizadas são, portanto:\n select filter arrange mutate summarize group_by  Para praticar, vamos usar o dataset flights, que contém informações sobre os vôos saídos de Nova Iorque em 2013.\nlibrary(nycflights13)\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r## The following objects are masked from 'package:stats':\r## ## filter, lag\r## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r flights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r glimpse(flights)\r ## Rows: 336,776\r## Columns: 19\r## $ year \u0026lt;int\u0026gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2~\r## $ month \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ day \u0026lt;int\u0026gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\r## $ dep_time \u0026lt;int\u0026gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, ~\r## $ sched_dep_time \u0026lt;int\u0026gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, ~\r## $ dep_delay \u0026lt;dbl\u0026gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1~\r## $ arr_time \u0026lt;int\u0026gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,~\r## $ sched_arr_time \u0026lt;int\u0026gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,~\r## $ arr_delay \u0026lt;dbl\u0026gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1~\r## $ carrier \u0026lt;chr\u0026gt; \u0026quot;UA\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;DL\u0026quot;, \u0026quot;UA\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;EV\u0026quot;, \u0026quot;B6\u0026quot;, \u0026quot;~\r## $ flight \u0026lt;int\u0026gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4~\r## $ tailnum \u0026lt;chr\u0026gt; \u0026quot;N14228\u0026quot;, \u0026quot;N24211\u0026quot;, \u0026quot;N619AA\u0026quot;, \u0026quot;N804JB\u0026quot;, \u0026quot;N668DN\u0026quot;, \u0026quot;N394~\r## $ origin \u0026lt;chr\u0026gt; \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;JFK\u0026quot;, \u0026quot;LGA\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;EWR\u0026quot;, \u0026quot;LGA\u0026quot;,~\r## $ dest \u0026lt;chr\u0026gt; \u0026quot;IAH\u0026quot;, \u0026quot;IAH\u0026quot;, \u0026quot;MIA\u0026quot;, \u0026quot;BQN\u0026quot;, \u0026quot;ATL\u0026quot;, \u0026quot;ORD\u0026quot;, \u0026quot;FLL\u0026quot;, \u0026quot;IAD\u0026quot;,~\r## $ air_time \u0026lt;dbl\u0026gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1~\r## $ distance \u0026lt;dbl\u0026gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, ~\r## $ hour \u0026lt;dbl\u0026gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6~\r## $ minute \u0026lt;dbl\u0026gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0~\r## $ time_hour \u0026lt;dttm\u0026gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0~\r Podemos filtrar nossas linhas: filter\n# Voos de primeiro de janeiro\rflights %\u0026gt;% filter(month == 1, day == 1)\r ## # A tibble: 842 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 832 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos a partir de junho\rflights %\u0026gt;% filter(month \u0026gt; 6)\r ## # A tibble: 170,618 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 170,608 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saídos do aeroporto JFK\rflights %\u0026gt;% filter(origin == \u0026quot;JFK\u0026quot;)\r ## # A tibble: 111,279 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 111,269 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com destino ao aeroporto de Albuquerque\rflights %\u0026gt;% filter(dest == \u0026quot;ABQ\u0026quot;)\r ## # A tibble: 254 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 1955 2001 -6 2213 2248\r## 2 2013 10 2 2010 2001 9 2230 2248\r## 3 2013 10 3 1955 2001 -6 2232 2248\r## 4 2013 10 4 2017 2001 16 2304 2248\r## 5 2013 10 5 1959 1959 0 2226 2246\r## 6 2013 10 6 1959 2001 -2 2234 2248\r## 7 2013 10 7 2002 2001 1 2233 2248\r## 8 2013 10 8 1957 2001 -4 2216 2248\r## 9 2013 10 9 1957 2001 -4 2220 2248\r## 10 2013 10 10 2011 2001 10 2235 2248\r## # ... with 244 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de até 10 minutos\rflights %\u0026gt;% filter(dep_delay \u0026lt;= 10)\r ## # A tibble: 245,687 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 245,677 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com atraso de cerca de 10 minutos\rflights %\u0026gt;% filter(near(dep_delay, 10, tol = 2))\r ## # A tibble: 8,677 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 611 600 11 945 931\r## 2 2013 1 1 709 700 9 852 832\r## 3 2013 1 1 826 817 9 1145 1158\r## 4 2013 1 1 851 840 11 1215 1206\r## 5 2013 1 1 1011 1001 10 1133 1128\r## 6 2013 1 1 1208 1158 10 1540 1502\r## 7 2013 1 1 1240 1229 11 1451 1428\r## 8 2013 1 1 1310 1300 10 1559 1554\r## 9 2013 1 1 1330 1321 9 1613 1536\r## 10 2013 1 1 1511 1500 11 1753 1742\r## # ... with 8,667 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos que ocorreram entre abril e maio\rflights %\u0026gt;% filter(between(month, 4, 5))\r ## # A tibble: 57,126 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 57,116 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Podemos combinar várias condições usando operadores lógicos\n# Voos até 15 de abril ou até 15 de maio\rflights %\u0026gt;% filter(\rbetween(month, 4, 5), # mesmo que usar \u0026amp;\rbetween(day, 1, 15)\r)\r ## # A tibble: 28,176 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 1 454 500 -6 636 640\r## 2 2013 4 1 509 515 -6 743 814\r## 3 2013 4 1 526 530 -4 812 827\r## 4 2013 4 1 534 540 -6 833 850\r## 5 2013 4 1 542 545 -3 914 920\r## 6 2013 4 1 543 545 -2 921 927\r## 7 2013 4 1 551 600 -9 748 659\r## 8 2013 4 1 552 600 -8 641 701\r## 9 2013 4 1 553 600 -7 725 735\r## 10 2013 4 1 554 600 -6 752 805\r## # ... with 28,166 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos entre 15 de abril e 15 de maio\rflights %\u0026gt;% filter(\rmonth == 4 \u0026amp; between(day, 15, 30) | # OU\rmonth == 5 \u0026amp; between(day, 1, 15)\r)\r ## # A tibble: 29,101 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 4 15 2 2359 3 341 339\r## 2 2013 4 15 453 500 -7 639 640\r## 3 2013 4 15 511 515 -4 741 802\r## 4 2013 4 15 527 530 -3 806 813\r## 5 2013 4 15 527 529 -2 750 743\r## 6 2013 4 15 537 540 -3 846 840\r## 7 2013 4 15 542 545 -3 931 927\r## 8 2013 4 15 551 600 -9 728 758\r## 9 2013 4 15 552 600 -8 835 850\r## 10 2013 4 15 552 600 -8 648 701\r## # ... with 29,091 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos em todas os primeiros 7 dias de cada mês, exceto em janeiro e dezembro\rflights %\u0026gt;% filter(\rbetween(day, 1, 7),\r!month %in% c(1, 12)\r)\r ## # A tibble: 64,365 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 10 1 447 500 -13 614 648\r## 2 2013 10 1 522 517 5 735 757\r## 3 2013 10 1 536 545 -9 809 855\r## 4 2013 10 1 539 545 -6 801 827\r## 5 2013 10 1 539 545 -6 917 933\r## 6 2013 10 1 544 550 -6 912 932\r## 7 2013 10 1 549 600 -11 653 716\r## 8 2013 10 1 550 600 -10 648 700\r## 9 2013 10 1 550 600 -10 649 659\r## 10 2013 10 1 551 600 -9 727 730\r## # ... with 64,355 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos saidos de JFK, excluindo aqueles para os quais não tem informações de horário de saída\rflights %\u0026gt;% filter(\rorigin == \u0026quot;JFK\u0026quot;, !is.na(dep_time)\r)\r ## # A tibble: 109,416 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 542 540 2 923 850\r## 2 2013 1 1 544 545 -1 1004 1022\r## 3 2013 1 1 557 600 -3 838 846\r## 4 2013 1 1 558 600 -2 849 851\r## 5 2013 1 1 558 600 -2 853 856\r## 6 2013 1 1 558 600 -2 924 917\r## 7 2013 1 1 559 559 0 702 706\r## 8 2013 1 1 606 610 -4 837 845\r## 9 2013 1 1 611 600 11 945 931\r## 10 2013 1 1 613 610 3 925 921\r## # ... with 109,406 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Voos com mais de 30 minutos de atraso em janeiro ou dezembro\rflights %\u0026gt;% filter(\rdep_delay \u0026gt; 30, xor(month == 1, month == 12)\r)\r ## # A tibble: 8,221 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 732 645 47 1011 941\r## 2 2013 1 1 749 710 39 939 850\r## 3 2013 1 1 811 630 101 1047 830\r## 4 2013 1 1 826 715 71 1136 1045\r## 5 2013 1 1 848 1835 853 1001 1950\r## 6 2013 1 1 903 820 43 1045 955\r## 7 2013 1 1 909 810 59 1331 1315\r## 8 2013 1 1 953 921 32 1320 1241\r## 9 2013 1 1 957 733 144 1056 853\r## 10 2013 1 1 1025 951 34 1258 1302\r## # ... with 8,211 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r E assim sucessivamente.\nDa mesma forma, temos select para selecionar as variáveis do banco. As duas grandes novidades são que você não precisa utilizar aspas na seleção de variáveis e que select introduz várias helper functions para facilitar a seleção de variáveis parecidas.\n# Selecionar as colunas ano, mes, dia, horario de saida e horario de chegada\rflights %\u0026gt;% select(year, month, day, dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Utilizando helpers\rflights %\u0026gt;% select(year:dep_time, arr_time)\r ## # A tibble: 336,776 x 5\r## year month day dep_time arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 830\r## 2 2013 1 1 533 850\r## 3 2013 1 1 542 923\r## 4 2013 1 1 544 1004\r## 5 2013 1 1 554 812\r## 6 2013 1 1 554 740\r## 7 2013 1 1 555 913\r## 8 2013 1 1 557 709\r## 9 2013 1 1 557 838\r## 10 2013 1 1 558 753\r## # ... with 336,766 more rows\r # Mais helpers\rflights %\u0026gt;% select(year:day, starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 2 830 11\r## 2 2013 1 1 533 4 850 20\r## 3 2013 1 1 542 2 923 33\r## 4 2013 1 1 544 -1 1004 -18\r## 5 2013 1 1 554 -6 812 -25\r## 6 2013 1 1 554 -4 740 12\r## 7 2013 1 1 555 -5 913 19\r## 8 2013 1 1 557 -3 709 -14\r## 9 2013 1 1 557 -3 838 -8\r## 10 2013 1 1 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, ends_with(\u0026quot;time\u0026quot;))\r ## # A tibble: 336,776 x 8\r## year month day dep_time sched_dep_time arr_time sched_arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 515 830 819 227\r## 2 2013 1 1 533 529 850 830 227\r## 3 2013 1 1 542 540 923 850 160\r## 4 2013 1 1 544 545 1004 1022 183\r## 5 2013 1 1 554 600 812 837 116\r## 6 2013 1 1 554 558 740 728 150\r## 7 2013 1 1 555 600 913 854 158\r## 8 2013 1 1 557 600 709 723 53\r## 9 2013 1 1 557 600 838 846 140\r## 10 2013 1 1 558 600 753 745 138\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(year:day, c(ends_with(\u0026quot;time\u0026quot;)) \u0026amp; !contains(\u0026quot;sched\u0026quot;))\r ## # A tibble: 336,776 x 6\r## year month day dep_time arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 517 830 227\r## 2 2013 1 1 533 850 227\r## 3 2013 1 1 542 923 160\r## 4 2013 1 1 544 1004 183\r## 5 2013 1 1 554 812 116\r## 6 2013 1 1 554 740 150\r## 7 2013 1 1 555 913 158\r## 8 2013 1 1 557 709 53\r## 9 2013 1 1 557 838 140\r## 10 2013 1 1 558 753 138\r## # ... with 336,766 more rows\r # Você pode mudar o nome das colunas durante um call para select\rflights %\u0026gt;% select(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 3\r## ano mes dia\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1\r## 2 2013 1 1\r## 3 2013 1 1\r## 4 2013 1 1\r## 5 2013 1 1\r## 6 2013 1 1\r## 7 2013 1 1\r## 8 2013 1 1\r## 9 2013 1 1\r## 10 2013 1 1\r## # ... with 336,766 more rows\r # Ou você pode usar rename para mudar os nomes sem selecionar variáveis\rflights %\u0026gt;% rename(ano = year, mes = month, dia = day)\r ## # A tibble: 336,776 x 19\r## ano mes dia dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r São realmente muitas possibilidades, vejam a documentação e os exemplos em ?select.\nUtilizando arrange podemos facilmente organizar nosso banco a partir de variáveis de interesse:\n# Selecionar algumas variáveis e ver organizar de acordar com os mais adiantados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(dep_delay, arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 12 7 2040 -43 40 48\r## 2 2013 2 3 2022 -33 2240 -58\r## 3 2013 11 10 1408 -32 1549 -10\r## 4 2013 1 11 1900 -30 2233 -10\r## 5 2013 1 29 1703 -27 1947 -10\r## 6 2013 8 9 729 -26 1002 7\r## 7 2013 3 30 2030 -25 2213 -37\r## 8 2013 10 23 1907 -25 2143 0\r## 9 2013 5 5 934 -24 1225 -44\r## 10 2013 9 18 1631 -24 1812 -33\r## # ... with 336,766 more rows\r # Ou os mais atrasados\rflights %\u0026gt;% select(year:day,matches(\u0026quot;^dep|^arr\u0026quot;)) %\u0026gt;% arrange(-dep_delay, -arr_delay)\r ## # A tibble: 336,776 x 7\r## year month day dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 9 641 1301 1242 1272\r## 2 2013 6 15 1432 1137 1607 1127\r## 3 2013 1 10 1121 1126 1239 1109\r## 4 2013 9 20 1139 1014 1457 1007\r## 5 2013 7 22 845 1005 1044 989\r## 6 2013 4 10 1100 960 1342 931\r## 7 2013 3 17 2321 911 135 915\r## 8 2013 6 27 959 899 1236 850\r## 9 2013 7 22 2257 898 121 895\r## 10 2013 12 5 756 896 1058 878\r## # ... with 336,766 more rows\r É basicamente isso, você pode especificar uma ou muitas colunas para organizar, decidir se a ordem é ascendente ou descendente e pronto.\nUtilizando mutate, você cria variáveis derivadas das originais. Como tibble, essa função avalia seus argumentos de maneira preguiçosa e sequencial, o que permite você criar variáveis derivadas umas das outras muito facilmente.\nflights %\u0026gt;% select(sched_dep_time, dep_time, sched_arr_time, arr_time) %\u0026gt;% mutate(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 8\r## sched_dep_time dep_time sched_arr_time arr_time atraso_decolagem atraso_pouso\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 515 517 819 830 2 11\r## 2 529 533 830 850 4 20\r## 3 540 542 850 923 2 73\r## 4 545 544 1022 1004 -1 -18\r## 5 600 554 837 812 -46 -25\r## 6 558 554 728 740 -4 12\r## 7 600 555 854 913 -45 59\r## 8 600 557 723 709 -43 -14\r## 9 600 557 846 838 -43 -8\r## 10 600 558 745 753 -42 8\r## # ... with 336,766 more rows, and 2 more variables: atraso_dec_horas \u0026lt;dbl\u0026gt;,\r## # atraso_pouso_horas \u0026lt;dbl\u0026gt;\r # Transmute é um atalho para quando você quer apenas as variáveis resultado e não está interessado nas intermediárias.\rflights %\u0026gt;% transmute(atraso_decolagem = dep_time - sched_dep_time,\ratraso_pouso = arr_time - sched_arr_time,\ratraso_dec_horas = atraso_decolagem / 60,\ratraso_pouso_horas = atraso_pouso / 60)\r ## # A tibble: 336,776 x 4\r## atraso_decolagem atraso_pouso atraso_dec_horas atraso_pouso_horas\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 11 0.0333 0.183\r## 2 4 20 0.0667 0.333\r## 3 2 73 0.0333 1.22 ## 4 -1 -18 -0.0167 -0.3 ## 5 -46 -25 -0.767 -0.417\r## 6 -4 12 -0.0667 0.2 ## 7 -45 59 -0.75 0.983\r## 8 -43 -14 -0.717 -0.233\r## 9 -43 -8 -0.717 -0.133\r## 10 -42 8 -0.7 0.133\r## # ... with 336,766 more rows\r Usando o pipe, é fazer diversas operações de transformação de variáveis simultâneamente em um único call sem a necessidade de repetir o nome do objeto e $ a cada referência. mutate é uma função extremamente flexível, você pode chamar qualquer função que retorne um vetor de tamanho 1 ou de tamanho do número de linhas do banco lá dentro para criar uma variável.\ndesabafo \u0026lt;- function(x) {\ry \u0026lt;- floor(x / 60)\rdplyr::case_when(\r# Condições ~ Resultados\ry \u0026lt; 0 ~ \u0026quot;Opa, vou chegar cedo!\u0026quot;,\ry \u0026lt; 1 ~ \u0026quot;Atraso de menos de 1 hora é tolerável\u0026quot;,\ry \u0026gt;= 1 ~ paste0(\u0026quot;Atraso de mais de \u0026quot;, y, \u0026quot; horas é f***.\u0026quot;),\rTRUE ~ \u0026quot;Ahn?\u0026quot; # Condição guarda-chuva\r)\r}\rflights %\u0026gt;% select(dep_delay) %\u0026gt;% mutate(desabafo = desabafo(dep_delay)) %\u0026gt;% sample_n(10)\r ## # A tibble: 10 x 2\r## dep_delay desabafo ## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 -5 Opa, vou chegar cedo! ## 2 23 Atraso de menos de 1 hora é tolerável\r## 3 -4 Opa, vou chegar cedo! ## 4 -3 Opa, vou chegar cedo! ## 5 -8 Opa, vou chegar cedo! ## 6 -3 Opa, vou chegar cedo! ## 7 -5 Opa, vou chegar cedo! ## 8 22 Atraso de menos de 1 hora é tolerável\r## 9 23 Atraso de menos de 1 hora é tolerável\r## 10 -2 Opa, vou chegar cedo!\r Utilizando summarize você tira medidas resumo das suas colunas de interesse:\nflights %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 1 x 5\r## atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~ n_voos\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 12.6 40.2 6.90 44.6 336776\r Parece uma bobagem, mas quando você junta isso com a última função, group_by, é possível obter diversas estatísticas de interesse muito rapidamente e para vários domínios:\n# Por mês\rflights %\u0026gt;% group_by(month) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## # A tibble: 12 x 6\r## month atraso_decolagem_~ atraso_decolagem_~ atraso_pouso_me~ atraso_pouso_de~\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 36.4 6.13 40.4\r## 2 2 10.8 36.3 5.61 39.5\r## 3 3 13.2 40.1 5.81 44.1\r## 4 4 13.9 43.0 11.2 47.5\r## 5 5 13.0 39.4 3.52 44.2\r## 6 6 20.8 51.5 16.5 56.1\r## 7 7 21.7 51.6 16.7 57.1\r## 8 8 12.6 37.7 6.04 42.6\r## 9 9 6.72 35.6 -4.02 39.7\r## 10 10 6.24 29.7 -0.167 32.6\r## 11 11 5.44 27.6 0.461 31.4\r## 12 12 16.6 41.9 14.9 46.1\r## # ... with 1 more variable: n_voos \u0026lt;int\u0026gt;\r # Por mês e aeroporto de origem\rflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n())\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 EWR 14.9 40.8 12.8 ## 2 1 JFK 8.62 36.0 1.37\r## 3 1 LGA 5.64 29.7 3.38\r## 4 2 EWR 13.1 37.2 8.78\r## 5 2 JFK 11.8 37.4 4.39\r## 6 2 LGA 6.96 33.4 3.15\r## 7 3 EWR 18.1 44.1 10.6 ## 8 3 JFK 10.7 35.3 2.58\r## 9 3 LGA 10.2 39.7 3.74\r## 10 4 EWR 17.4 43.9 14.1 ## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r Uma vez que você se familiariza com a gramática do dplyr, o processo de análise exploratória se torna bastante trivial e até certo ponto, prazeiroso. Mas o que eu realmente gosto é que ele também se torna visualmente óbvio para o leitor, com cada chamado podendo ser lido como uma declaração:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo.\n Você também pode rapidamente introduzir ou retirar passos em cada chamado deste utilizando o pipe, por exemplo:\nflights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38\r## # ... with 26 more rows, and 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;,\r## # n_voos \u0026lt;int\u0026gt;\r E a leitura fica:\n Utilizando o banco de dados flights, agrupe as observações por mês e aeroporto de origem, então, calcule as médias e desvios padrão dos atrasos no pouso e na decolagem e o número de vôos para cada grupo, então, ordene os resultados pelo maior atraso.\n De quebra, você ainda leva para casa um dado no formato “tabela,” fácil de exportar para outros softwares para embelezamento e publicação. Veja:\nresumo \u0026lt;- flights %\u0026gt;% group_by(month, origin) %\u0026gt;% summarize(atraso_decolagem_medio = mean(dep_delay, na.rm = T),\ratraso_decolagem_desvpad = sd(dep_delay, na.rm = T),\ratraso_pouso_medio = mean(arr_delay, na.rm = T),\ratraso_pouso_desvpad = sd(arr_delay, na.rm = T),\rn_voos = n()) %\u0026gt;% arrange(-atraso_decolagem_medio)\r ## `summarise()` has grouped output by 'month'. You can override using the `.groups` argument.\r print(resumo, n = Inf)\r ## # A tibble: 36 x 7\r## # Groups: month [12]\r## month origin atraso_decolagem_medio atraso_decolagem_desvp~ atraso_pouso_med~\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 7 JFK 23.8 53.3 20.2 ## 2 6 EWR 22.5 50.8 16.9 ## 3 7 EWR 22.0 49.5 15.5 ## 4 12 EWR 21.0 45.7 19.6 ## 5 6 JFK 20.5 50.2 17.6 ## 6 6 LGA 19.3 53.6 14.8 ## 7 7 LGA 19.0 52.0 14.2 ## 8 3 EWR 18.1 44.1 10.6 ## 9 4 EWR 17.4 43.9 14.1 ## 10 5 EWR 15.4 39.0 5.38 ## 11 1 EWR 14.9 40.8 12.8 ## 12 12 JFK 14.8 39.1 12.7 ## 13 12 LGA 13.6 39.8 12.0 ## 14 8 EWR 13.5 37.6 6.71 ## 15 2 EWR 13.1 37.2 8.78 ## 16 8 JFK 12.9 36.3 5.91 ## 17 5 JFK 12.5 38.5 2.12 ## 18 4 JFK 12.2 41.2 7.01 ## 19 2 JFK 11.8 37.4 4.39 ## 20 4 LGA 11.5 43.4 12.0 ## 21 8 LGA 11.2 39.2 5.41 ## 22 3 JFK 10.7 35.3 2.58 ## 23 5 LGA 10.6 40.6 2.80 ## 24 3 LGA 10.2 39.7 3.74 ## 25 10 EWR 8.64 32.7 2.60 ## 26 1 JFK 8.62 36.0 1.37 ## 27 9 EWR 7.29 35.0 -4.73 ## 28 2 LGA 6.96 33.4 3.15 ## 29 11 EWR 6.72 28.8 0.672\r## 30 9 JFK 6.64 32.5 -4.46 ## 31 9 LGA 6.21 39.0 -2.83 ## 32 1 LGA 5.64 29.7 3.38 ## 33 10 LGA 5.31 30.1 0.186\r## 34 11 LGA 4.77 26.6 1.55 ## 35 11 JFK 4.68 27.1 -0.873\r## 36 10 JFK 4.59 25.2 -3.59 ## # ... with 2 more variables: atraso_pouso_desvpad \u0026lt;dbl\u0026gt;, n_voos \u0026lt;int\u0026gt;\r Lembrem-se que é necessário atribuir \u0026lt;- os resultados das operações para que elas sejam salvas. Em geral, meu workflow é assim:\n# Começo com o banco\rflights\r ## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r # Seleciono algumas variáveis\rflights %\u0026gt;% select(month, dep_delay, arr_delay)\r ## # A tibble: 336,776 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 336,766 more rows\r # Recorto algumas observações\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6))\r ## # A tibble: 166,158 x 3\r## month dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 2 11\r## 2 1 4 20\r## 3 1 2 33\r## 4 1 -1 -18\r## 5 1 -6 -25\r## 6 1 -4 12\r## 7 1 -5 19\r## 8 1 -3 -14\r## 9 1 -3 -8\r## 10 1 -2 8\r## # ... with 166,148 more rows\r # Escolho os dominios e calculo as medidas resumo\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T))\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 10.0 6.13\r## 2 2 10.8 5.61\r## 3 3 13.2 5.81\r## 4 4 13.9 11.2 ## 5 5 13.0 3.52\r## 6 6 20.8 16.5\r # Acho bom organizar pelos atrasos maiores\rflights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r # Estou satisfeito, salvo meu resultado em outro objeto\ratrasos \u0026lt;- flights %\u0026gt;% select(month, dep_delay, arr_delay) %\u0026gt;% filter(between(month, 1, 6)) %\u0026gt;% group_by(month) %\u0026gt;% summarise(atraso_dec_medio = mean(dep_delay, na.rm = T),\ratraso_pou_medio = mean(arr_delay, na.rm = T)) %\u0026gt;% arrange(-atraso_dec_medio, -atraso_pou_medio)\ratrasos\r ## # A tibble: 6 x 3\r## month atraso_dec_medio atraso_pou_medio\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 6 20.8 16.5 ## 2 4 13.9 11.2 ## 3 3 13.2 5.81\r## 4 5 13.0 3.52\r## 5 2 10.8 5.61\r## 6 1 10.0 6.13\r Desta forma, consigo construir interativamente meus cálculos, verificando a cada passo se estou obtendo o resultado esperado. Visto de outra perspectiva, se encontro um código programado desta forma que não funciona, posso ir apagando cada %\u0026gt;% para identificar onde o problema ocorreu.\nEspero que tenha ficado claro que o assunto não se encerra por aqui. Existem diversas outras funções úteis no pacote, como count, if_else, case_when, top_n, bind_rows, bind_cols, as novas funções across e c_across e muitas, muitas outras. Nos livros vocês encontram vários outros exemplos e funções para facilitar o processo de análise de dados, mas nossa expectativa é que essa apresentação seja um ponto de partida para vocês se aprofundarem no seu próprio ritmo.\ndplyr para bancos de dados relacionais Nesta seção, o nosso problema não é mais a análise de dados presentes em um banco, mas o problema de relacionar informações sobre uma mesma unidade de análise que estão presentes em vários bancos de dados distintos.\nO banco nycflights13 contém várias tabelas que se relacionam, e elas funcionam como um excelente exemplo de banco de dados relacionais.\nNote que além do banco de dados dos vôos, temos informações sobre clima, aviões e companhias aéreas. Para nós, pode ser relevante reunir informações de diferentes fontes em um mesmo banco de dados, algo que é possível através de joins. Por uma questão de tempo, não vamos entrar muito a fundo no assunto, mas vamos introduzir dois conceitos chave e partir pros exemplos.\n  chaves são as variáveis que identificam cada observação em um banco de dados de forma única. Uma chave é dita “primária” quando identifica uma observação na sua própria tabela e “externa” quando ela identifica uma observação em outra tabela. Assim, qualquer operação de join é uma forma de relacionar uma chave primária e uma chave externa. Essa junção de chaves é uma relação, e as relações podem ser 1 para 1, 1 para muitos ou muitos para 1.\n  joins são tipos de operação no qual se opta por priorizar um grupo de observações em detrimento de outras. Podemos vê-los didaticamente a partir de duas figuras:\n  A primeira figura é interessante porque nos dá uma ideia de quais observações serão mantidas e quais serão descartadas, podemos imaginá-la como uma abstração da nossa escolha.\n Quero todas as informações sobre os vôos e os aeroportos, e as duas são igualmente importantes (inner_join, x = flights, y = airports).\n  Quero todas as observações do banco vôos e as informações disponíveis sobre a aeronave (left_join, x = flights, y = planes).\n  Quero todas as informações tanto sobre os vôos quanto sobre o clima em cada dia (full_join, x = flights, y = weather).\n  Quero as informações dos vôos realizados pelas companhias aéreas - minha prioridade são as cias. áreas (right_join, x = flights, y = carriers).\n A segunda figura é interessante porque elas mostra a mecânica de um join: cada observação tem a sua chave marcada com a observação correspondente no outro banco. Se as chaves são iguais, a operação é realizada, se as chaves não são iguais, a operação não é realizada. Dependendo do tipo de join, uma, as duas ou nenhuma das observações é descartada do banco resultante.\n Antes de começar a trabalhar com bancos relacionais, é uma boa ideia dar uma explorada nas chaves, vendo suas contagens, se há erros de digitação, etc. Por uma questão de tempo, vamos pular essa fase.\n Se as nossas chaves forem perfeitinhas, e inclusive tiverem o mesmo nome nas duas tabelas, basta invocar o tipo de join desejado.\n# Vamos dar uma enxugada no flights para poder ver o efeito dos joins com maior facilidade.\rflights2 \u0026lt;- flights %\u0026gt;% select(year:day, hour, origin, dest, tailnum, carrier)\rflights2\r ## # A tibble: 336,776 x 8\r## year month day hour origin dest tailnum carrier\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA ## 2 2013 1 1 5 LGA IAH N24211 UA ## 3 2013 1 1 5 JFK MIA N619AA AA ## 4 2013 1 1 5 JFK BQN N804JB B6 ## 5 2013 1 1 6 LGA ATL N668DN DL ## 6 2013 1 1 5 EWR ORD N39463 UA ## 7 2013 1 1 6 EWR FLL N516JB B6 ## 8 2013 1 1 6 LGA IAD N829AS EV ## 9 2013 1 1 6 JFK MCO N593JB B6 ## 10 2013 1 1 6 LGA ORD N3ALAA AA ## # ... with 336,766 more rows\r # Chaves perfeitas, mesmo nome nos dois bancos = natural join\rflights2 %\u0026gt;% left_join(weather) # Moleza\r ## Joining, by = c(\u0026quot;year\u0026quot;, \u0026quot;month\u0026quot;, \u0026quot;day\u0026quot;, \u0026quot;hour\u0026quot;, \u0026quot;origin\u0026quot;)\r## # A tibble: 336,776 x 18\r## year month day hour origin dest tailnum carrier temp dewp humid\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 39.0 28.0 64.4\r## 2 2013 1 1 5 LGA IAH N24211 UA 39.9 25.0 54.8\r## 3 2013 1 1 5 JFK MIA N619AA AA 39.0 27.0 61.6\r## 4 2013 1 1 5 JFK BQN N804JB B6 39.0 27.0 61.6\r## 5 2013 1 1 6 LGA ATL N668DN DL 39.9 25.0 54.8\r## 6 2013 1 1 5 EWR ORD N39463 UA 39.0 28.0 64.4\r## 7 2013 1 1 6 EWR FLL N516JB B6 37.9 28.0 67.2\r## 8 2013 1 1 6 LGA IAD N829AS EV 39.9 25.0 54.8\r## 9 2013 1 1 6 JFK MCO N593JB B6 37.9 27.0 64.3\r## 10 2013 1 1 6 LGA ORD N3ALAA AA 39.9 25.0 54.8\r## # ... with 336,766 more rows, and 7 more variables: wind_dir \u0026lt;dbl\u0026gt;,\r## # wind_speed \u0026lt;dbl\u0026gt;, wind_gust \u0026lt;dbl\u0026gt;, precip \u0026lt;dbl\u0026gt;, pressure \u0026lt;dbl\u0026gt;,\r## # visib \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r flights2 %\u0026gt;% left_join(airlines) # Moleza\r ## Joining, by = \u0026quot;carrier\u0026quot;\r## # A tibble: 336,776 x 9\r## year month day hour origin dest tailnum carrier name ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. ## 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways ## 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Airways ## 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet Airlines Inc.\r## 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Airways ## 10 2013 1 1 6 LGA ORD N3ALAA AA American Airlines Inc. ## # ... with 336,766 more rows\r # Chaves perfeitas, mas há variáveis nos dois bancos com o mesmo nome e que não são chaves\r# É necessário especificar qual a chave\rflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;)\r ## # A tibble: 336,776 x 16\r## year.x month day hour origin dest tailnum carrier year.y type ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wing mult~\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wing mult~\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wing mult~\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wing mult~\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wing mult~\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wing mult~\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000 Fixed wing mult~\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998 Fixed wing mult~\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004 Fixed wing mult~\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA \u0026lt;NA\u0026gt; ## # ... with 336,766 more rows, and 6 more variables: manufacturer \u0026lt;chr\u0026gt;,\r## # model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;, engine \u0026lt;chr\u0026gt;\r Veja que tanto flights2 quanto planes tem uma variável chamada year, mas elas significados diferentes. Em flights2 é o ano do vôo, enquanto em planes é o ano em que a aeronave entra em serviço. Na hora que fazemos o join, uma recebe o sufixo “x” e a outra “y” para a indicar a diferença. Você pode especificar o sufixo desejado para evitar confusão:\nflights2 %\u0026gt;% left_join(planes, by = \u0026quot;tailnum\u0026quot;, suffix = c(\u0026quot;_flight\u0026quot;, \u0026quot;_entered_service\u0026quot;))\r ## # A tibble: 336,776 x 16\r## year_flight month day hour origin dest tailnum carrier year_entered_serv~\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA 1999\r## 2 2013 1 1 5 LGA IAH N24211 UA 1998\r## 3 2013 1 1 5 JFK MIA N619AA AA 1990\r## 4 2013 1 1 5 JFK BQN N804JB B6 2012\r## 5 2013 1 1 6 LGA ATL N668DN DL 1991\r## 6 2013 1 1 5 EWR ORD N39463 UA 2012\r## 7 2013 1 1 6 EWR FLL N516JB B6 2000\r## 8 2013 1 1 6 LGA IAD N829AS EV 1998\r## 9 2013 1 1 6 JFK MCO N593JB B6 2004\r## 10 2013 1 1 6 LGA ORD N3ALAA AA NA\r## # ... with 336,766 more rows, and 7 more variables: type \u0026lt;chr\u0026gt;,\r## # manufacturer \u0026lt;chr\u0026gt;, model \u0026lt;chr\u0026gt;, engines \u0026lt;int\u0026gt;, seats \u0026lt;int\u0026gt;, speed \u0026lt;int\u0026gt;,\r## # engine \u0026lt;chr\u0026gt;\r Um aviso: cuidado com os produtos cartesianos. Não há um bom exemplo aqui no caso do flights porque o banco já está limpinho, mas se você especificar chaves com uma relação “muitos para muitos,” ele vai registrar no banco novo uma linha para cada combinação possível de variáveis. Em bancos maiores, isso geralmente estoura sua memória e trava o R. Veja este pequeno exemplo de brinquedo.\nx \u0026lt;- tribble(\r~key, ~val_x,\r1, \u0026quot;x1\u0026quot;,\r2, \u0026quot;x2\u0026quot;,\r2, \u0026quot;x3\u0026quot;,\r3, \u0026quot;x4\u0026quot;\r)\ry \u0026lt;- tribble(\r~key, ~val_y,\r1, \u0026quot;y1\u0026quot;,\r2, \u0026quot;y2\u0026quot;,\r2, \u0026quot;y3\u0026quot;,\r3, \u0026quot;y4\u0026quot;\r)\rleft_join(x, y, by = \u0026quot;key\u0026quot;)\r ## # A tibble: 6 x 3\r## key val_x val_y\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 1 x1 y1 ## 2 2 x2 y2 ## 3 2 x2 y3 ## 4 2 x3 y2 ## 5 2 x3 y3 ## 6 3 x4 y4\r Veja que no resultado foi criada uma linha para cada combinação de val_x e val_y que tem a mesma chave repetida. Podem até existir situações em que isso seja o que você quer mesmo, mas na minha experiência até o momento isso é problema com as chaves duplicadas e é sinal de que há algo errado.\nMas peraí, se você falou que tem 4 tipos de join, porque só dá exemplo de left_join?\nNa prática, operações relacionais são feitas de forma intencional: escolhemos bancos de dados de acordo com o valor que atribuímos a informação presente nele e pinçamos informações relacionadas de outros lugares para adicionar aquilo que é nosso foco. Por isso, na maioria dos casos, o left_join é o mais usual, porque preserva todas as informações do meu banco x e adiciona apenas as informações do banco y que combinaram com sucesso. Isso garante que eu não vou perder nenhuma informação do meu banco principal.\nPra encerrar essa parte, mais exemplos de joins.\n# Minhas chaves tem nomes diferentes, então uso um vetor do tipo c(\u0026quot;chave_x\u0026quot; = \u0026quot;chave_y\u0026quot;)\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;dest\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Georg~ 30.0 -95.3 97\r## 2 2013 1 1 5 LGA IAH N24211 UA Georg~ 30.0 -95.3 97\r## 3 2013 1 1 5 JFK MIA N619AA AA Miami~ 25.8 -80.3 8\r## 4 2013 1 1 5 JFK BQN N804JB B6 \u0026lt;NA\u0026gt; NA NA NA\r## 5 2013 1 1 6 LGA ATL N668DN DL Harts~ 33.6 -84.4 1026\r## 6 2013 1 1 5 EWR ORD N39463 UA Chica~ 42.0 -87.9 668\r## 7 2013 1 1 6 EWR FLL N516JB B6 Fort ~ 26.1 -80.2 9\r## 8 2013 1 1 6 LGA IAD N829AS EV Washi~ 38.9 -77.5 313\r## 9 2013 1 1 6 JFK MCO N593JB B6 Orlan~ 28.4 -81.3 96\r## 10 2013 1 1 6 LGA ORD N3ALAA AA Chica~ 42.0 -87.9 668\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r # Mesma coisa, só que agora juntando as informações da origem ao invés do destino\rflights2 %\u0026gt;% left_join(airports, c(\u0026quot;origin\u0026quot; = \u0026quot;faa\u0026quot;))\r ## # A tibble: 336,776 x 15\r## year month day hour origin dest tailnum carrier name lat lon alt\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 5 EWR IAH N14228 UA Newar~ 40.7 -74.2 18\r## 2 2013 1 1 5 LGA IAH N24211 UA La Gu~ 40.8 -73.9 22\r## 3 2013 1 1 5 JFK MIA N619AA AA John ~ 40.6 -73.8 13\r## 4 2013 1 1 5 JFK BQN N804JB B6 John ~ 40.6 -73.8 13\r## 5 2013 1 1 6 LGA ATL N668DN DL La Gu~ 40.8 -73.9 22\r## 6 2013 1 1 5 EWR ORD N39463 UA Newar~ 40.7 -74.2 18\r## 7 2013 1 1 6 EWR FLL N516JB B6 Newar~ 40.7 -74.2 18\r## 8 2013 1 1 6 LGA IAD N829AS EV La Gu~ 40.8 -73.9 22\r## 9 2013 1 1 6 JFK MCO N593JB B6 John ~ 40.6 -73.8 13\r## 10 2013 1 1 6 LGA ORD N3ALAA AA La Gu~ 40.8 -73.9 22\r## # ... with 336,766 more rows, and 3 more variables: tz \u0026lt;dbl\u0026gt;, dst \u0026lt;chr\u0026gt;,\r## # tzone \u0026lt;chr\u0026gt;\r O assunto, obviamente, não pára por aí. Nos livros vocês encontrarão mais exemplos e funções, como é o caso do semi_join e do anti_join e das operações “set,” intersect, union e setdiff, mas isso fica pra vocês explorarem por conta própria e virem tirar as dúvidas depois!\nstringr stringr contém uma família de funções, todas começadas em str_, cuja principal preocupação é a consistência. As funções do base para strings são muito úteis, porém, seus argumentos estão numa ordem um pouco estranha, algumas funções são vetorizadas e outras não. Quando você se acostuma, até que não é tão ruim, mas voltando para o assunto discutido ontem de tornar o seu código mais legível, é interessante ter a simplicidade oferecida.\nBasicão da string Como este curso já é pra praticantes de R, vou pular algumas coisas muito básicas de string, vamos ao que interessa.\nDeterminados caracteres tem um significado especial dentro das strings. Quem já tentou copiar e colar um caminho de arquivo do Windows pro R sabe disso. Então, nesses casos, é precisar “escapar” caracteres. Por exemplo, se você quiser escrever aspas, você usar a contrabarra \\ para “escapar” um caractere.\naspa_simples \u0026lt;- '\\'' # ou \u0026quot;'\u0026quot;\raspa_dupla \u0026lt;- \u0026quot;\\\u0026quot;\u0026quot; # ou '\u0026quot;'\r A regra do escape é simples, então se você quiser colocar uma contrabarra \\\nx \u0026lt;- c(\u0026quot;\\\\\u0026quot;, \u0026quot;\\\u0026quot;\u0026quot;)\rx\r ## [1] \u0026quot;\\\\\u0026quot; \u0026quot;\\\u0026quot;\u0026quot;\r writeLines(x)\r ## \\\r## \u0026quot;\r Outros caracteres especiais úteis: \u0026quot;\\n\u0026quot; para pular uma linha, \\t para Tab. Você pode ver os outros na ajuda das aspas \u0026quot;, basta digitar no console ?\u0026quot;'\u0026quot; ou ?'\u0026quot;'.\nOutra coisa que dá pra fazer, se você precisar incluir um caractere distinto, é usar unicode:\nx \u0026lt;- \u0026quot;\\u00b5\u0026quot;\rx\r ## [1] \u0026quot;µ\u0026quot;\r Ok, mas e o pacote stringr? Bem, ele tem o intuito de facilitar e dar consistência, então, todas as funções do pacote começam com as iniciais str_ justamente para serem utilizadas com o autocompletar do RStudio, que pode ser acessada com os atalhos Ctrl + Espaço ou Tab. Vamos ver agora alguns exemplos de funções do pacote.\nComprimento da string em caracteres:\nlibrary(stringr)\r# No RStudio, basta digitar 'str_' e apertar Tab ou Ctrl + Espaço\rx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_length(x)\r ## [1] 17\r x \u0026lt;- c(\u0026quot;Ministro Sinistro\u0026quot;, \u0026quot;Abelha Gulosa\u0026quot;, \u0026quot;p\u0026quot;)\rstr_length(x)\r ## [1] 17 13 1\r Concatenação de strings:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;xyz\u0026quot;\r Use o argumento sep para definir caracteres que aparecerão entre as strings originais:\nstr_c(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;z\u0026quot;, sep = \u0026quot; + \u0026quot;)\r ## [1] \u0026quot;x + y + z\u0026quot;\r Você pode trabalhar com strings que contém NAs:\nx \u0026lt;- c(\u0026quot;abc\u0026quot;, NA)\rstr_c(\u0026quot;|-\u0026quot;, x, \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; NA\r str_c(\u0026quot;|-\u0026quot;, str_replace_na(x), \u0026quot;-|\u0026quot;)\r ## [1] \u0026quot;|-abc-|\u0026quot; \u0026quot;|-NA-|\u0026quot;\r str_c é uma função vetorizada e automaticamente recicla seus argumentos pra ter o tamanho do maior:\n# Eu na graduação\rstr_c(\u0026quot;Profe, me dá mais \u0026quot;, c(\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;), \u0026quot; semanas pra entregar, por favor!\u0026quot;)\r ## [1] \u0026quot;Profe, me dá mais 1 semanas pra entregar, por favor!\u0026quot;\r## [2] \u0026quot;Profe, me dá mais 2 semanas pra entregar, por favor!\u0026quot;\r## [3] \u0026quot;Profe, me dá mais 3 semanas pra entregar, por favor!\u0026quot;\r # Eu de manhã\rstr_c(\u0026quot;Só mais \u0026quot;, c(\u0026quot;5\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;30\u0026quot;), \u0026quot; minutinhos e eu acordo!\u0026quot;)\r ## [1] \u0026quot;Só mais 5 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 10 minutinhos e eu acordo!\u0026quot;\r## [3] \u0026quot;Só mais 20 minutinhos e eu acordo!\u0026quot; \u0026quot;Só mais 30 minutinhos e eu acordo!\u0026quot;\r Se algum dos objetos passados para str_c tiver tamanho 0, ele é descartado. Útil para usar com testes lógicos.\nnome \u0026lt;- \u0026quot;Vinicius\u0026quot;\rsobrenome \u0026lt;- \u0026quot;Maia\u0026quot;\rtem_nome_do_meio \u0026lt;- FALSE\rstr_c(\r\u0026quot;Meu nome é \u0026quot;, nome, \u0026quot; \u0026quot;,\r# isso aqui retorna um vetor tamanho 0\rif (tem_nome_do_meio) \u0026quot; de Souza\u0026quot;, sobrenome,\r\u0026quot;.\u0026quot;\r)\r ## [1] \u0026quot;Meu nome é Vinicius Maia.\u0026quot;\r Conhecedores de paste reconhecerão o argumento collapse, que serve para transformar vetores de strings em uma única string.\nstr_c(c(\u0026quot;Natália\u0026quot;, \u0026quot;Martins\u0026quot;, \u0026quot;Arruda\u0026quot;), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;Natália Martins Arruda\u0026quot;\r De forma similar, conhecedores de substring deverão imediatamente reconhecer essa:\nx \u0026lt;- c(\u0026quot;Maçã\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Abacaxi\u0026quot;)\rstr_sub(x, 1, 3)\r ## [1] \u0026quot;Maç\u0026quot; \u0026quot;Ban\u0026quot; \u0026quot;Aba\u0026quot;\r str_sub(x, -3, -1)\r ## [1] \u0026quot;açã\u0026quot; \u0026quot;ana\u0026quot; \u0026quot;axi\u0026quot;\r str_sub não vai dar erro se a string for muito curta:\nstr_sub(\u0026quot;a\u0026quot;, 1, 5)\r ## [1] \u0026quot;a\u0026quot;\r Dá pra usar a forma str_sub(x) \u0026lt;- para modificar partes de strings\nstr_sub(x, 1, 1) \u0026lt;- str_to_lower(str_sub(x, 1, 1))\rx\r ## [1] \u0026quot;maçã\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;abacaxi\u0026quot;\r Note o uso de str_to_lower para mudar para minúsculas. O contrário é str_to_upper, também há uma para títulos, str_to_title, e para a primeira letra de uma frase, str_to_sentence.\nx \u0026lt;- \u0026quot;Ministro Sinistro\u0026quot;\rstr_to_lower(x)\r ## [1] \u0026quot;ministro sinistro\u0026quot;\r str_to_upper(x)\r ## [1] \u0026quot;MINISTRO SINISTRO\u0026quot;\r str_to_sentence(x)\r ## [1] \u0026quot;Ministro sinistro\u0026quot;\r str_to_title(x)\r ## [1] \u0026quot;Ministro Sinistro\u0026quot;\r Como vimos no readr, algumas questões relacionadas a strings dependem da língua, ou, na linguagem do pacote, são “locale dependent.” Por isso nas funções onde isso é relevante, o argumento se chama locale. Isso não é super relevante para quem trabalha com o inglês ou as línguas do oeste europeu, considerando que a maioria das línguas tem raízes similares, mas pode ser muito importante para outros idiomas. Vejamos este exemplo com a mudança da ordem das strings.\nx \u0026lt;- c(\u0026quot;abacaxi\u0026quot;, \u0026quot;escarola\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_sort(x, locale = \u0026quot;en\u0026quot;) # Inglês\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;banana\u0026quot; \u0026quot;escarola\u0026quot;\r str_sort(x, locale = \u0026quot;haw\u0026quot;) # Havaiano\r ## [1] \u0026quot;abacaxi\u0026quot; \u0026quot;escarola\u0026quot; \u0026quot;banana\u0026quot;\r É justamente para esses casos que str_sort e str_order oferecem a alternativa de você especificar o locale.\nTrabalhando com padrões e “expressões regulares” Expressões regulares são quase uma linguagem de programação em si, aqui, vamos dar uma passada muito rápida e ver alguns exemplos simples. São uma ferramenta muito útil, mas talvez não do interesse de todos.\nBasicamente, a ideia é fazer uma pesquisa na string, em busca de um padrão específico. Pode ser uma palavra, um espaço em branco, uma quebra de linha. Pode ficar muito complexo ou ser bem básico. O nosso objetivo aqui é que todos tenham a capacidade de trabalhar com padrões simples para corrigir inconsistências em bancos de dados, como no exemplo da aula anterior das colunas do dataset da OMS.\nPara visualizar padrões, vamos usar duas helper functions, str_view e str_view_all.\nx \u0026lt;- c(\u0026quot;mamão\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;ananas\u0026quot;)\rstr_view(x, \u0026quot;an\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rO resultado sai na aba “Viewer” do seu RStudio.\nO primeiro padrão que podemos usar é o ., que identifica qualquer caractere. As vezes na documentação esse tipo de padrão genérico é chamado de “wildcard.”\nstr_view(x, \u0026quot;.a.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n mamão\\n banana\\n ananas\\n\"},\"evals\":[],\"jsHooks\":[]}\rA forma de ler essa operação é: “Identifique qualquer conjunto de caracteres que tenha uma letra a no meio deles.”\nSe você quiser identificar um . numa string, você precisa usar o escape \\. Porém, a barra também é um escape! Então, ao escrever expressões regulares, precisamos usar \\\\. Veja:\ndot \u0026lt;- \u0026quot;.\u0026quot;\rcat(dot)\r ## .\r # erro\rdot \u0026lt;- \u0026quot;\\.\u0026quot;\r ## Error: '\\.' é uma seqüência de escape não reconhecida na cadeia de caracteres começando com \u0026quot;\u0026quot;\\.\u0026quot;\r # agora sim\rdot \u0026lt;- \u0026quot;\\\\.\u0026quot;\rcat(dot)\r ## \\.\r Agora em um exemplo:\nx \u0026lt;- c(\u0026quot;Praia.\u0026quot;, \u0026quot;Agora.\u0026quot;, \u0026quot;Ou.\u0026quot;, \u0026quot;Me.\u0026quot;, \u0026quot;Rebelo.\u0026quot;)\rstr_view(x, \u0026quot;a\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;u\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;o\\\\.\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Praia.\\n Agora.\\n Ou.\\n Me.\\n Rebelo.\\n\"},\"evals\":[],\"jsHooks\":[]}\rTá, mas se a contrabarra é utilizada para denotar uma expressão regular tipo o ., como eu faço para pesquisar uma contrabarra?\nx \u0026lt;- \u0026quot;Jake Peralta é o melhor detetive\\\\gênio\u0026quot;\rcat(x)\r ## Jake Peralta é o melhor detetive\\gênio\r A solução é escapar o escape do escape, sacou?\nstr_view(x, \u0026quot;\\\\\\\\\u0026quot;)\r \r{\"x\":{\"html\":\"\\n Jake Peralta é o melhor detetive\\\\gênio\\n\"},\"evals\":[],\"jsHooks\":[]}\rÉ enrolado mesmo…\nPara não estender muito o assunto, vamos ver vários exemplos de caracteres especiais a ser usados em expressões regulares.\n^ encontra o início de uma string\nx \u0026lt;- c(\u0026quot;maçã\u0026quot;, \u0026quot;banana\u0026quot;, \u0026quot;mamão\u0026quot;)\rstr_view(x, \u0026quot;^m\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\r$ encontra o final\nstr_view(x, \u0026quot;a$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n maçã\\n banana\\n mamão\\n\"},\"evals\":[],\"jsHooks\":[]}\rPara forçar a expressão a achar apenas a palavra completa, use os dois\nx \u0026lt;- c(\u0026quot;vitamina de banana\u0026quot;, \u0026quot;sundae de banana\u0026quot;, \u0026quot;banana\u0026quot;)\rstr_view(x, \u0026quot;banana\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;^banana$\u0026quot;)\r \r{\"x\":{\"html\":\"\\n vitamina de banana\\n sundae de banana\\n banana\\n\"},\"evals\":[],\"jsHooks\":[]}\rUse classes de caracteres para encontrar genéricos\nQualquer digito:\nx \u0026lt;- \u0026quot;15 de Maio de 2021.\u0026quot;\rstr_view(x, \u0026quot;\\\\d\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer espaço em branco:\nstr_view(x, \u0026quot;\\\\s\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere de um grupo: [abc]\nstr_view(x, \u0026quot;[M]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[eM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[deM]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rQualquer caractere menos esses: [^abc]\nstr_view(x, \u0026quot;[^15]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;[^15 de Maio de ]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rUsar uma classe pra evitar digitar 5 milhões de contrabarras\nstr_view(x, \u0026quot;[.]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(\u0026quot;a*c\u0026quot;, \u0026quot;[*]\u0026quot;)\r \r{\"x\":{\"html\":\"\\n a*c\\n\"},\"evals\":[],\"jsHooks\":[]}\rVocê pode misturar strings com classes também\nx \u0026lt;- c(\u0026quot;15 de Maio de 2021.\u0026quot;, \u0026quot;16 de Maio de 2021.\u0026quot;)\rstr_view(x, \u0026quot;1[56] de Maio\u0026quot;)\r \r{\"x\":{\"html\":\"\\n 15 de Maio de 2021.\\n 16 de Maio de 2021.\\n\"},\"evals\":[],\"jsHooks\":[]}\rInfelizmente, alguns caracteres tem significado especial dentro das classes, e você tem que usar contrabarras para fugir deles: ] \\ ^ e -.\nVocê pode lidar com repetições\nx \u0026lt;- c(\u0026quot;Mariele\u0026quot;, \u0026quot;Marielle\u0026quot;, \u0026quot;Mariellle\u0026quot;, \u0026quot;Marie\u0026quot;)\rstr_view(x, \u0026quot;Mariell?e\u0026quot;) # l aparece 0 ou 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel+e\u0026quot;) # l aparece 1 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel*\u0026quot;) # l aparece 0 ou + vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{0}\u0026quot;) # l aparece exatamente 0 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1}\u0026quot;) # l aparece exatamente 1 vez\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2}\u0026quot;) # l aparece exatamente 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{3}\u0026quot;) # l aparece exatamente 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,}\u0026quot;) # l aparece exatamente 1 vez ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,}\u0026quot;) # l aparece exatamente 2 vezes ou mais\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{1,2}\u0026quot;) # l aparece de 1 a 2 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rstr_view(x, \u0026quot;Mariel{2,3}\u0026quot;) # l aparece de 2 a 3 vezes\r \r{\"x\":{\"html\":\"\\n Mariele\\n Marielle\\n Mariellle\\n Marie\\n\"},\"evals\":[],\"jsHooks\":[]}\rEsse assunto é enorme, e ainda estamos só na superfície. Há grupos, lookarounds, e muitos outros detalhes envolvendo expressões regulares, e vocês podem consultar os livros de referência para mergulhar mais fundo. Mas vamos parar por aqui para nos concentrar no que interessa.\nEm geral, temos um banco de dados com strings problemáticas, tipo erros de digitação, inconsistências etc. O primeiro passo, em geral, é detectar os problemas.\nx \u0026lt;- c(\u0026quot;São Paulo\u0026quot;, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;Sao Paulo\u0026quot;, \u0026quot;sp\u0026quot;, \u0026quot;SP\u0026quot;, \u0026quot;Sp\u0026quot;)\rstr_detect(x, \u0026quot;ã\u0026quot;)\r ## [1] TRUE FALSE FALSE FALSE FALSE FALSE\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] FALSE FALSE FALSE TRUE TRUE TRUE\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;)\r ## [1] FALSE TRUE TRUE FALSE FALSE FALSE\r Você pode se utilizar do fato da resposta ser um vetor lógico para descobrir quantos problemas você tem\n# Contagens\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% sum()\r ## [1] 1\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% sum()\r ## [1] 3\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% sum()\r ## [1] 2\r # Proporções\rstr_detect(x, \u0026quot;ã\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.1666667\r str_detect(x, \u0026quot;[Ss][Pp]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.5\r str_detect(x, \u0026quot;[Ss][Aa][Oo]\u0026quot;) %\u0026gt;% mean()\r ## [1] 0.3333333\r Depois de detectar seus problemas, você pode querer extrair uma parte dos seus casos: use str_subset\nstr_subset(x, \u0026quot;[Ss][Pp]\u0026quot;)\r ## [1] \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Em geral, no entanto, você vai estar trabalhando num data frame. Então use dplyr::filter e str_detect.\ndf \u0026lt;- tibble::tibble(\rnome = c(\u0026quot;Marcos\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;cebolinha\u0026quot;, \u0026quot;Beiçola\u0026quot;, \u0026quot;nadir\u0026quot;, \u0026quot;Monica\u0026quot;),\ruf = x,\rdtnsc = c(\u0026quot;15 de Maio de 1980\u0026quot;, \u0026quot;1 de Jan de 2001\u0026quot;, \u0026quot;6 de Ago de 1993\u0026quot;, \u0026quot;20 de Abril de 1964\u0026quot;, \u0026quot;24 de Nov de 1975\u0026quot;, \u0026quot;14 de Dezembro de 1997\u0026quot;)\r)\rdf %\u0026gt;% dplyr::filter(str_detect(uf, \u0026quot;[Ss][Pp]\u0026quot;))\r ## # A tibble: 3 x 3\r## nome uf dtnsc ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Beiçola sp 20 de Abril de 1964 ## 2 nadir SP 24 de Nov de 1975 ## 3 Monica Sp 14 de Dezembro de 1997\r Você pode contar quantos matches você tem str_count\nstr_count(x, \u0026quot;o\u0026quot;)\r ## [1] 2 0 2 0 0 0\r str_count(x, \u0026quot;[Oo]\u0026quot;)\r ## [1] 2 2 2 0 0 0\r # e usar num data frame\rdf %\u0026gt;% dplyr::mutate(vogais = str_count(uf, \u0026quot;[aeiou]\u0026quot;),\rconsoantes = str_count(uf, \u0026quot;[^aeiou]\u0026quot;))\r ## # A tibble: 6 x 5\r## nome uf dtnsc vogais consoantes\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 4 5\r## 2 rogério SAO PAULO 1 de Jan de 2001 0 9\r## 3 cebolinha Sao Paulo 6 de Ago de 1993 5 4\r## 4 Beiçola sp 20 de Abril de 1964 0 2\r## 5 nadir SP 24 de Nov de 1975 0 2\r## 6 Monica Sp 14 de Dezembro de 1997 0 2\r Você pode extrair str_extract as informações que você quer\nstr_extract(df$dtnsc, \u0026quot;\\\\d+\u0026quot;)\r ## [1] \u0026quot;15\u0026quot; \u0026quot;1\u0026quot; \u0026quot;6\u0026quot; \u0026quot;20\u0026quot; \u0026quot;24\u0026quot; \u0026quot;14\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\d+$\u0026quot;)\r ## [1] \u0026quot;1980\u0026quot; \u0026quot;2001\u0026quot; \u0026quot;1993\u0026quot; \u0026quot;1964\u0026quot; \u0026quot;1975\u0026quot; \u0026quot;1997\u0026quot;\r str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;)\r ## [1] \u0026quot; de Maio de \u0026quot; \u0026quot; de Jan de \u0026quot; \u0026quot; de Ago de \u0026quot; \u0026quot; de Abril de \u0026quot; ## [5] \u0026quot; de Nov de \u0026quot; \u0026quot; de Dezembro de \u0026quot;\r # Na tibble\rdf %\u0026gt;% dplyr::mutate(\rdia = str_extract(dtnsc, \u0026quot;\\\\d+\u0026quot;),\rmes = str_extract(df$dtnsc, \u0026quot;\\\\D+\u0026quot;),\rano = str_extract(dtnsc, \u0026quot;\\\\d+$\u0026quot;))\r ## # A tibble: 6 x 6\r## nome uf dtnsc dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 de Maio de 1980 15 \u0026quot; de Maio de \u0026quot; 1980 ## 2 rogério SAO PAULO 1 de Jan de 2001 1 \u0026quot; de Jan de \u0026quot; 2001 ## 3 cebolinha Sao Paulo 6 de Ago de 1993 6 \u0026quot; de Ago de \u0026quot; 1993 ## 4 Beiçola sp 20 de Abril de 1964 20 \u0026quot; de Abril de \u0026quot; 1964 ## 5 nadir SP 24 de Nov de 1975 24 \u0026quot; de Nov de \u0026quot; 1975 ## 6 Monica Sp 14 de Dezembro de 1997 14 \u0026quot; de Dezembro de \u0026quot; 1997\r # Melhor ainda\rdf %\u0026gt;% tidyr::extract(\rdtnsc, c(\u0026quot;dia\u0026quot;, \u0026quot;mes\u0026quot;, \u0026quot;ano\u0026quot;), regex = \u0026quot;(\\\\d+) de (\\\\D+) de (\\\\d+$)\u0026quot;\r)\r ## # A tibble: 6 x 5\r## nome uf dia mes ano ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Marcos São Paulo 15 Maio 1980 ## 2 rogério SAO PAULO 1 Jan 2001 ## 3 cebolinha Sao Paulo 6 Ago 1993 ## 4 Beiçola sp 20 Abril 1964 ## 5 nadir SP 24 Nov 1975 ## 6 Monica Sp 14 Dezembro 1997\r Similar a ideia de extração, podemos substituir com str_replace\nstr_replace(x, \u0026quot;[Ss][Pp]\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot;\r str_replace(x, \u0026quot;SAO PAULO\u0026quot;, \u0026quot;São Paulo\u0026quot;)\r ## [1] \u0026quot;São Paulo\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;Sao Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r str_replace(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Paulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r Tanto str_extract quanto str_replace substituem apenas a primeira marca, se você quiser substituir todas, utilize str_..._all\nstr_extract_all(x, \u0026quot;a\u0026quot;, simplify = TRUE)\r ## [,1] [,2]\r## [1,] \u0026quot;a\u0026quot; \u0026quot;\u0026quot; ## [2,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [3,] \u0026quot;a\u0026quot; \u0026quot;a\u0026quot; ## [4,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [5,] \u0026quot;\u0026quot; \u0026quot;\u0026quot; ## [6,] \u0026quot;\u0026quot; \u0026quot;\u0026quot;\r str_replace_all(x, \u0026quot;a\u0026quot;, \u0026quot;ã\u0026quot;)\r ## [1] \u0026quot;São Pãulo\u0026quot; \u0026quot;SAO PAULO\u0026quot; \u0026quot;São Pãulo\u0026quot; \u0026quot;sp\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;Sp\u0026quot;\r O assunto não acaba, mas vamos parar por aqui. Novamente, recomendo consultarem os materiais para quem quiser ir mais a fundo nisso. É bem capaz de no andar da carruagem aparecerem outros exemplos nos quais a manipulação de strings pode ser importante.\nforcats Esse é um pacotinho muito que facilita bastante a vida de quem trabalha com variável categórica, ou, no R, os factors. Ele consiste em uma série de “helper functions” baseadas em funções do base e do stats que trabalham com os componentes de um factor, ou seja, seus levels e seus values.\nImagino que todos aqui estão familiarizados com fatores e com a sua criação, então vamos direto ao que interessa. Educação é um vetor de caracteres que vem com os níveis educacionais de um população.\neducacao \u0026lt;- c(\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;,\r\u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;, \u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;)\rx \u0026lt;- factor(educacao, levels = c(\u0026quot;Fundamental\u0026quot;, \u0026quot;Médio\u0026quot;, \u0026quot;Superior\u0026quot;))\rx\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Fundamental Médio Superior\r levels(x)\r ## [1] \u0026quot;Fundamental\u0026quot; \u0026quot;Médio\u0026quot; \u0026quot;Superior\u0026quot;\r relevel(x, \u0026quot;Superior\u0026quot;)\r ## [1] Superior Fundamental Médio Superior Fundamental Médio ## [7] Superior Fundamental Médio Superior Fundamental Médio ## Levels: Superior Fundamental Médio\r Em geral, diversas tarefas envolvendo fatores no base não são muito simples. Por exemplo, se eu quiser modificar os nomes dos níveis de um fator depois dele já estar criado, modificar a ordem dos níveis, ou agrupar diversos níveis em um só. forcats vem justamente oferecer soluções nesse sentido. Normalmente, estamos trabalhando com bancos de dados, e não com um vetor solitário, por isso, vamos usar o gss_cat, uma amostra do General Social Survey aplicado pelo NORC e pela Universidade de Chicago, que vem no pacote forcats.\nlibrary(forcats)\rgss_cat\r ## # A tibble: 21,483 x 9\r## year marital age race rincome partyid relig denom tvhours\r## \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 2000 Never ma~ 26 White $8000 to ~ Ind,near r~ Protesta~ Souther~ 12\r## 2 2000 Divorced 48 White $8000 to ~ Not str re~ Protesta~ Baptist~ NA\r## 3 2000 Widowed 67 White Not appli~ Independent Protesta~ No deno~ 2\r## 4 2000 Never ma~ 39 White Not appli~ Ind,near r~ Orthodox~ Not app~ 4\r## 5 2000 Divorced 25 White Not appli~ Not str de~ None Not app~ 1\r## 6 2000 Married 25 White $20000 - ~ Strong dem~ Protesta~ Souther~ NA\r## 7 2000 Never ma~ 36 White $25000 or~ Not str re~ Christian Not app~ 3\r## 8 2000 Divorced 44 White $7000 to ~ Ind,near d~ Protesta~ Luthera~ NA\r## 9 2000 Married 44 White $25000 or~ Not str de~ Protesta~ Other 0\r## 10 2000 Married 47 White $25000 or~ Strong rep~ Protesta~ Souther~ 3\r## # ... with 21,473 more rows\r Contagens\nUma das primeiras coisas que interessa ao lidar com fatores, é obter suas contagens, o que é algo muito simples utilizando a gramática do dplyr.\n# Função count\rgss_cat %\u0026gt;% count(race)\r ## # A tibble: 3 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% count(race, .drop = FALSE)\r ## # A tibble: 4 x 2\r## race n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Other 1959\r## 2 Black 3129\r## 3 White 16395\r## 4 Not applicable 0\r # Visualização com ggplot\rlibrary(ggplot2)\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar()\r # Incluindo níveis com contagem = 0.\rgss_cat %\u0026gt;% ggplot(aes(race)) + geom_bar() + scale_x_discrete(drop = FALSE)\r Note o uso do argumento drop nos dois casos, para indicar que casos com 0 observações não devem ser removidos do resultado.\nModificando a ordem A segunda tarefa comum quando trabalhamos com fatores é modificar a ordem em que eles aparecem. Não é tanto o caso quando trabalhamos com fatores ordenados, mas diversos tipos de variáveis categóricas não possuem uma ordem lógica pre-definida e, mesmo assim, nos interessa apresentá-los de acordo com uma determinada hierarquia visual, seja porque eles são os mais frequentes ou porque queremos destacar algum elemento em particular. forcats implementa diversas estratégias de reordenamento de fatores. Vamos vê-las brevemente.\nDigamos que eu queira saber o tempo médio de televisão assistida por membros das diversas religiões. Eu poderia produzir um sumário e depois plotar isso num gráfico.\nrelig_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(relig) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r O display está técnicamente correto, mas a forma desorganizada dos níveis no eixo Y dificulta a nossa capacidade de fazer comparações. Talvez fosse mais interessante ordenar este resultado por ordem decrescente do número de horas de tv. Mas, como fazer isso de forma direta, sem precisar realizar diversas computações?\n# Direto no plot\rrelig_summary %\u0026gt;% ggplot(aes(tvhours, fct_reorder(relig, tvhours))) + geom_point()\r # Antes de passar o data.frame para a plotagem\rrelig_summary %\u0026gt;% mutate(relig = fct_reorder(relig, tvhours)) %\u0026gt;% ggplot(aes(tvhours, relig)) + geom_point()\r Note como posso aplicar a transformação diretamente na variável durante o processo de plotagem, ou antes, e uma invocação de mutate. Na minha opinião, o segundo jeito é o mais adequado, por duas razões: é mais fácil de digitar, inserir e retirar do código e é mais fácil para um leitor identificar que uma transformação foi feita na variável plotada.\nOutro exemplo: que tal exarminarmos a relação entre a idade e a renda declarada? Primeiro, é preciso construir um sumário, parecido com o primeiro:\nrincome_summary \u0026lt;- gss_cat %\u0026gt;%\rgroup_by(rincome) %\u0026gt;%\rsummarise(\rage = mean(age, na.rm = TRUE),\rtvhours = mean(tvhours, na.rm = TRUE),\rn = n()\r)\rrincome_summary %\u0026gt;% mutate(rincome = fct_reorder(rincome, age)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Aqui, o reordenamento das variáveis de acordo com a idade não faz muito sentido, porque os níveis de renda tem uma ordem própria. Nesse caso, não é recomendado utilizar fct_reorder.\nrincome_summary %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Só que ao plotar, notamos um problema: a categoria “Not applicable” ficou primeiro e isso desorganiza visualmente nosso gráfico. Sem problema! Utilizamos fct_relevel para modificar a ordem de uma variável arbitrariamente. O padrão é colocar pro começo (Parecido com o comportamento de stats::relevel), mas você pode especificar outra posição.\nrincome_summary %\u0026gt;% mutate(rincome = fct_relevel(rincome, \u0026quot;Not applicable\u0026quot;)) %\u0026gt;% ggplot(aes(age, rincome)) + geom_point()\r Notem como nos exemplos acima, o uso do %\u0026gt;% nos permite alterar partes do nosso código de maneira interativa para chegar no resultado desejado.\nOutro tipo de mudança de ordem interessante ocorre quando temos uma terceira “dimensão” no nosso gráfico. Em geral, utilizamos cores, formas ou linhas quebradas para diferenciar entre categorias e gostaríamos que a nossa legenda acompanhasse a tendência do gráfico. Compare:\nby_age \u0026lt;- gss_cat %\u0026gt;%\rfilter(!is.na(age)) %\u0026gt;%\rcount(age, marital) %\u0026gt;%\rgroup_by(age) %\u0026gt;%\rmutate(prop = n / sum(n))\r# Sem alteração na ordem\rby_age %\u0026gt;% ggplot(aes(age, prop, colour = marital)) +\rgeom_line(na.rm = TRUE)\r # Com alteração na ordem\rggplot(by_age, aes(age, prop, colour = fct_reorder2(marital, age, prop))) +\rgeom_line() +\rlabs(colour = \u0026quot;marital\u0026quot;)\r No caso de fct_reorder2, é melhor fazer a alteração de ordem dentro da função gráfica, pois dentro uma invocação de mutate, ela não funcionou durante meus testes.\nPor último, podemos querer ordenar um gráfico de barras de acordo com a frequência das categorias, o que podemos fazer com fct_infreq e fct_rev (opcional).\ngss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r # OU\rgss_cat %\u0026gt;%\rmutate(marital = marital %\u0026gt;% fct_infreq() %\u0026gt;% fct_rev()) %\u0026gt;%\rggplot(aes(marital)) +\rgeom_bar()\r Notem o uso do pipe na hora de modificar a variável “marital.”\nModificando os níveis O outro tipo de operação bastante comum é a alteração nos níves do fator. Em geral, queremos que os nossos níveis sejam representativos das nossas categorias de análise, sejam de fácil leitura e entendimento e contenham um número significativo de observações. Por essa razão, frequentemente precisamos alterar os rótulos, agrupar categorias, etc.\nVejamos o exemplo da variável partyid, que registra a identificação do entrevistado com os partidos políticos dos EUA.\ngss_cat %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 154\r## 2 Don't know 1\r## 3 Other party 393\r## 4 Strong republican 2314\r## 5 Not str republican 3032\r## 6 Ind,near rep 1791\r## 7 Independent 4119\r## 8 Ind,near dem 2499\r## 9 Not str democrat 3690\r## 10 Strong democrat 3490\r Vamos supor que, por qualquer motivo, essa forma de representação das categorias não nos satisfaz. Vejamos algumas das ferramentas que podemos utilizar para modificar esse fator.\nPodemos, simplesmente, reescrever essas categorias de forma mais completa:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r\u0026quot;Outro partido\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Não sei\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Sem resposta\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Sem resposta 154\r## 2 Não sei 1\r## 3 Outro partido 393\r## 4 Republicano, forte 2314\r## 5 Republicano, fraco 3032\r## 6 Independente, próx. repub. 1791\r## 7 Independente 4119\r## 8 Independente, próx. democ. 2499\r## 9 Democrata, fraco 3690\r## 10 Democrata, forte 3490\r A função utilizada é fct_recode e ela é a mais genérica e flexível de todas, porém, exige que cada nível seja modificado individualmente. Dentro dela, é possível agrupar vários níveis associando vários níveis antigos a um mesmo nível novo. Veja o exemplo:\ngss_cat %\u0026gt;% mutate(partyid = fct_recode(partyid,\r\u0026quot;Republicano, forte\u0026quot; = \u0026quot;Strong republican\u0026quot;,\r\u0026quot;Republicano, fraco\u0026quot; = \u0026quot;Not str republican\u0026quot;,\r\u0026quot;Independente, próx. repub.\u0026quot; = \u0026quot;Ind,near rep\u0026quot;,\r\u0026quot;Independente, próx. democ.\u0026quot; = \u0026quot;Ind,near dem\u0026quot;,\r\u0026quot;Independente\u0026quot; = \u0026quot;Independent\u0026quot;,\r\u0026quot;Democrata, forte\u0026quot; = \u0026quot;Strong democrat\u0026quot;,\r\u0026quot;Democrata, fraco\u0026quot; = \u0026quot;Not str democrat\u0026quot;,\r# Note o nome\r\u0026quot;Outro\u0026quot; = \u0026quot;Other party\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;Don't know\u0026quot;,\r\u0026quot;Outro\u0026quot; = \u0026quot;No answer\u0026quot;\r)) %\u0026gt;% count(partyid)\r ## # A tibble: 8 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano, forte 2314\r## 3 Republicano, fraco 3032\r## 4 Independente, próx. repub. 1791\r## 5 Independente 4119\r## 6 Independente, próx. democ. 2499\r## 7 Democrata, fraco 3690\r## 8 Democrata, forte 3490\r Se você quiser recategorizar um fator que tem muitos níveis para um menor, com poucos níveis, utilize fct_collapse:\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\rOutro = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\rRepublicano = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\rIndependente = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\rDemocrata = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Repare que do lado esquerdo, nos valores novos, não foi necessário usar aspas. É preciso cuidado com essa característica dos verbos do tidyverse. Ela se chama “tidy evaluation” e está um pouco fora do escopo do curso. Basicamente, se rolar dúvida ou der erros, se for usar acentos ou algum caractere diferente, use aspas.\ngss_cat %\u0026gt;%\rmutate(partyid = fct_collapse(partyid,\r\u0026quot;Outro\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Other party\u0026quot;),\r\u0026quot;Republicano\u0026quot; = c(\u0026quot;Strong republican\u0026quot;, \u0026quot;Not str republican\u0026quot;),\r\u0026quot;Independente\u0026quot; = c(\u0026quot;Ind,near rep\u0026quot;, \u0026quot;Independent\u0026quot;, \u0026quot;Ind,near dem\u0026quot;),\r\u0026quot;Democrata\u0026quot; = c(\u0026quot;Not str democrat\u0026quot;, \u0026quot;Strong democrat\u0026quot;)\r)) %\u0026gt;%\rcount(partyid)\r ## # A tibble: 4 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Outro 548\r## 2 Republicano 5346\r## 3 Independente 8409\r## 4 Democrata 7180\r Outro tipo de mudança importante no número de níveis é agrupar os níveis menos frequentes, por exemplo, para produzir uma visualização que dê maior destaque aos níveis mais frequentes. Esse é o trabalho de fct_lump.\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Other 913\r Note que usando o argumento n eu indico quantos níveis eu quero. No caso, escolhi os 5 níveis mais frequentes e todos os outros são automáticamente agrupados na categoria “Other.” Posso mudar esse nome também:\ngss_cat %\u0026gt;% mutate(relig = fct_lump(relig, n = 5, other_level = \u0026quot;Outros\u0026quot;)) %\u0026gt;% count(relig)\r ## # A tibble: 6 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Christian 689\r## 2 None 3523\r## 3 Jewish 388\r## 4 Catholic 5124\r## 5 Protestant 10846\r## 6 Outros 913\r Exercícios   Encontre os vôos que:\n Atrasaram mais de duas horas Com destino a Houston (IAH ou HOU) Operados pela United, American ou Delta Decolaram entre julho e setembro Chegaram com mais de duas horas de atraso, mas não decolaram com atraso Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo Decolaram entre a meia-noite e 6 da manhã (inclusive)    Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).\n  Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.\n  As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.\n  O que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?\n  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: “150,” “219,” “312,” “471.” Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;115\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;118\u0026quot; \u0026quot;116\u0026quot; \u0026quot;100\u0026quot; \u0026quot;108\u0026quot; \u0026quot;113\u0026quot; \u0026quot;119\u0026quot; \u0026quot;121\u0026quot; \u0026quot;103\u0026quot;\r## [13] \u0026quot;116\u0026quot; \u0026quot;111\u0026quot; \u0026quot;111\u0026quot; \u0026quot;115\u0026quot; \u0026quot;114\u0026quot; \u0026quot;102\u0026quot; \u0026quot;116\u0026quot; \u0026quot;103\u0026quot; \u0026quot;120\u0026quot; \u0026quot;115\u0026quot; \u0026quot;123\u0026quot; \u0026quot;103\u0026quot;\r## [25] \u0026quot;119\u0026quot; \u0026quot;230\u0026quot; \u0026quot;228\u0026quot; \u0026quot;225\u0026quot; \u0026quot;214\u0026quot; \u0026quot;225\u0026quot; \u0026quot;206\u0026quot; \u0026quot;207\u0026quot; \u0026quot;208\u0026quot; \u0026quot;202\u0026quot; \u0026quot;210\u0026quot; \u0026quot;229\u0026quot;\r## [37] \u0026quot;204\u0026quot; \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;218\u0026quot; \u0026quot;223\u0026quot; \u0026quot;221\u0026quot; \u0026quot;205\u0026quot; \u0026quot;214\u0026quot; \u0026quot;220\u0026quot; \u0026quot;227\u0026quot; \u0026quot;202\u0026quot; \u0026quot;224\u0026quot;\r## [49] \u0026quot;214\u0026quot; \u0026quot;201\u0026quot; \u0026quot;305\u0026quot; \u0026quot;310\u0026quot; \u0026quot;309\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;303\u0026quot; \u0026quot;312\u0026quot; \u0026quot;310\u0026quot;\r## [61] \u0026quot;303\u0026quot; \u0026quot;302\u0026quot; \u0026quot;305\u0026quot; \u0026quot;303\u0026quot; \u0026quot;304\u0026quot; \u0026quot;306\u0026quot; \u0026quot;309\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;309\u0026quot; \u0026quot;306\u0026quot; \u0026quot;311\u0026quot;\r## [73] \u0026quot;306\u0026quot; \u0026quot;307\u0026quot; \u0026quot;310\u0026quot; \u0026quot;417\u0026quot; \u0026quot;477\u0026quot; \u0026quot;470\u0026quot; \u0026quot;493\u0026quot; \u0026quot;414\u0026quot; \u0026quot;446\u0026quot; \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;476\u0026quot;\r## [85] \u0026quot;432\u0026quot; \u0026quot;490\u0026quot; \u0026quot;499\u0026quot; \u0026quot;429\u0026quot; \u0026quot;414\u0026quot; \u0026quot;455\u0026quot; \u0026quot;409\u0026quot; \u0026quot;462\u0026quot; \u0026quot;447\u0026quot; \u0026quot;483\u0026quot; \u0026quot;458\u0026quot; \u0026quot;471\u0026quot;\r## [97] \u0026quot;402\u0026quot; \u0026quot;423\u0026quot; \u0026quot;464\u0026quot; \u0026quot;483\u0026quot;\r  Explore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?\n  Qual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?\n  A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?\n  Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?\n  ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"fa0304036676bc16efc6e61759597fd7","permalink":"https://laddem.github.io/courses/tidyverse/dia2/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia2/","section":"courses","summary":"Operações em variáveis e bancos de dados Hoje vamos apresentar dois pacotes com finalidades mais específicas para trabalhar com variáveis de tipo caractere e fator e um pacote super importante para as operações com bancos de dados.","tags":null,"title":"stringr, forcats e dplyr","type":"book"},{"authors":null,"categories":null,"content":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.frame e o código utilizado para gerar o gráfico. Acho que se o termo sobrecarga infromacional não existisse, eu teria inventado ele na hora.\nAnedotas a parte, não é culpa do autor. O livro pressupõe um certo conhecimento prévio que eu não tinha quando o li pela primeira vez. Imagino que a maioria de vocês já viu gráficos na vida e até construiu um ou dois deles usando esse ou outros softwares estatísticos. O que talvez nem todos tenham claro na mente é que os gráficos são uma codificação num sistema de coordenadas das informações presentes em um banco de dados através de escalas. Vamos destrinchar um pouco melhor isso:\nSuponha que você tenha o banco de dados mpg, presente na biblioteca ggplot2.\nlibrary(ggplot2)\rmpg\r ## # A tibble: 234 x 11\r## manufacturer model displ year cyl trans drv cty hwy fl class\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 audi a4 1.8 1999 4 auto(l~ f 18 29 p comp~\r## 2 audi a4 1.8 1999 4 manual~ f 21 29 p comp~\r## 3 audi a4 2 2008 4 manual~ f 20 31 p comp~\r## 4 audi a4 2 2008 4 auto(a~ f 21 30 p comp~\r## 5 audi a4 2.8 1999 6 auto(l~ f 16 26 p comp~\r## 6 audi a4 2.8 1999 6 manual~ f 18 26 p comp~\r## 7 audi a4 3.1 2008 6 auto(a~ f 18 27 p comp~\r## 8 audi a4 quat~ 1.8 1999 4 manual~ 4 18 26 p comp~\r## 9 audi a4 quat~ 1.8 1999 4 auto(l~ 4 16 25 p comp~\r## 10 audi a4 quat~ 2 2008 4 manual~ 4 20 28 p comp~\r## # ... with 224 more rows\r De posse desse banco, você gostaria de construir um gráfico relacionando a eficiência do combustível de um carro (hwy) com o seu peso (displ). Sábio e malandro no ggplot2, você escreve o código a seguir:\nggplot(mpg, aes(displ,hwy, color = class)) +\rgeom_point()\r Mas fica a dúvida: que escolhas foram feitas no momento de traduzir a minha intenção de produzir um diagrama de dispersão (scatterplot) do peso com o consumo de gasolina para a representação gráfica diante de nós? Que unidades de medidas estão dispostas nos eixos X e Y? Qual o sistema de coordenadas no qual isto foi representado? Quem define os limites de início e fim de cada eixo? Como cada ponto recebeu a sua cor? Essas perguntas podem parecer óbvias ou tontas, dependendo da perspectiva e da experiência do usuário, mas elas são centrais para entender como construir e modificar gráficos no ggplot2.\nO pacote é inspirado pela Gramática dos Gráficos, e procura decompor o processo de produção de gráficos em uma sequência de camadas que vão se sobrepondo até chegar no objeto desejado.\n a camada dos dados e do mapeamento estético (que variáveis vão em quais eixos/escalas) a camada dos objetos geométricos (pontos, linhas, barras, etc.) a camada das escalas (natural? logarítmica? escala de cores?) a camada das facetas (mini gráficos separados por alguma característica) a camada das transformações estatísticas (distribuições de probabilidade, contagens, proporções, etc.) o sistema de coordenadas (cartesiano? polar?)  Obviamente, nem todo gráfico possui essa complexidade, e na verdade, a maioria dos gráficos que fazemos se encaixa num pequeno subgrupo de todas essas especificações, então porque toda essa complexidade?\nPorque não? Em primeiro lugar, se você está produzindo visualizações simples que cumprem seu propósito, você não precisa se preocupar com quase nada disso, os padrões do ggplot2, via de regra, se encaixam perfeitamente na maioria dos problemas e, em segundo lugar, se você sentir a necessidade de ir mais fundo e produzir visualizações mais complexas, as mesmas ferramentas que você já conhece estão a sua disposição.\nTrês gráficos para entender a mecânica do ggplot2 Scatterplots Voltemos para o nosso gráfico original, vamos decompô-lo em suas camadas como se estivéssemos construindo ele passo-a-passo:\n# Primeiro, a camada dos dados e mapeamentos estéticos\rggplot(\r# Dados\rdata = mpg,\r# Que variável vai em que eixo\rmapping = aes(x = displ, y = hwy)\r)\r Examinando a saída, vemos que ggplot desenhou um canvas com nossas variáveis, mas ainda nenhum objeto geométrico. Tudo bem, adicionamos (+) uma camada de objetos geométricos, no caso, pontos.\n# Objetos geométricos começam com \u0026quot;geom_\u0026quot;\rggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + # adicionamos\rgeom_point()\r Agora, nosso gráfico já tem uma cara de diagrama de dispersão. Mas ainda não tem as cores das classes de automóvel. Tudo bem, voltamos para a primeira camada e informamos que queremos um terceiro mapeamento estético.\n# A cor é mapeada a variável class\rggplot(data = mpg, mapping = aes(\rx = displ, y = hwy,\rcolor = class) # novo mapeamento estético\r) + # adicionamos\rgeom_point()\r Ok, chegamos no gráfico original. Mas como podem entender melhor as outras camadas? Vamos pensar, por exemplo, que talvez queiramos trabalhar a variável hwy numa escala logarítmica. Poderíamos transformar a variável original, claro, mas o ggplot2 nos permite especificar as transformações diretamente nas escalas do gráfico!\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() + # adicionando uma nova \u0026quot;camada\u0026quot;\rscale_y_continuous(trans = \u0026quot;log\u0026quot;)\r Mas você, leitor, não ficou satisfeito. Você queria era transformar a variável displ em raíz quadrada. Tudo bem:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;) # especificamos a transformação na escala de x\r Outro leitor não estava interessado nas escalas dos eixos x ou y, que são contínuas nesse caso, mas sim na seleção de cores utilizadas para representar a escala das cores. Por ser um leitor conhecedor das formas de deficiência visual cromática, ele optou pelas paletas de cores do Colorbrewer:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) # transformação da escala de cores\r Um geógrafo entrou na conversa e disse que o sistema cartesiano de coordenadas estava iludindo os leitores a pensar que a relação entre peso e consumo de combustível estava distorcida pelas diferenças entre as unidades de medida das variáveis, produzida pelo sistema cartesiano de coordenadas, então ele sugeriu que usássemos um sistema de coordenadas fixas:\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) +\rcoord_fixed()\r Ficou horrível, esse geógrafo não sabe nada. Como recompensa pela sua ignorância, agora ele ocupa um cargo no primeiro escalão do Ministério da Saúde.\nOutro pesquisador estava interessado em visualizar as relações entre consumo, peso e classe, mas levando em consideração o fabricante do veículo, então, ele sugeriu que construíssemos um gráfico para cada. Você, que é preguiçoso, usou a capacidade do ggplot2 de dividir gráficos através da introdução de uma camada de facets.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + # adicionamos mais uma camada\rfacet_wrap(~manufacturer) # de facetas\r Agora, muito satisfeitos com o resultado do nosso trabalho, resolvemos incluir o gráfico numa publicação, mas do jeito que está, não dá. Então adicionamos mais algumas camadas para torná-lo apresentável.\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;) + facet_wrap(~manufacturer) +\r# Colocamos os nomes nos eixos\rlabs(title = \u0026quot;Relação entre peso e economia de combustível de automóveis\u0026quot;,\rsubtitle = \u0026quot;Separado por categoria e fabricante\u0026quot;,\rx = \u0026quot;Peso do veículo em toneladas\u0026quot;,\ry = \u0026quot;Consumo em milhas por galão de 3,5l\u0026quot;,\rcolor = \u0026quot;Categoria\u0026quot;,\rcaption = \u0026quot;Fonte: Agência de Proteção Ambiental Estadunidense.\u0026quot;) +\r# Escolhemos um tema bonito\rtheme_light() +\r# Mudamos a posição da legenda, pra ficar mais jeitozinho\rtheme(legend.position = \u0026quot;bottom\u0026quot;)\r Pronto. Mamãe vai ficar orgulhosa.\nBrincadeiras a parte, entendendo um pouco melhor a gramática do gráfico, podemos construir nossas visualizações passo a passo, até chegar no resultado desejado.\nLineplots O segundo exemplo que quero mostrar pra vocês é a construção de gráficos com linhas. Eles são interessantes porque dão bastante dor de cabeça pra quem está começando. Vamos continuar brincando com o mpg.\nAgora que eu fiz meu diagrama de dispersão, estou interessado em começar um processo de modelagem, mas primeiro quero ter uma noção visual da relação entre as variáveis.\nggplot(mpg, aes(displ, hwy)) +\rgeom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r geom_smooth ajusta um modelo aos dados e desenha a linha com os valores preditos. Agora que temos dois objetos geométricos, talvez seja interessante ver o que acontece se eu colocar as cores das classes.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Veja que ele fez o possível para aplicar as escalas nos dois objetos geométricos. Eu pedi para geom_smooth tirar os intervalos de confiança para melhorar a visibilidade. Mas e seu eu quisesse ver a cor dos pontos, mas manter a linha de tendência geral? Você pode especificar mapeamentos estéticos gerais (na primeira camada) ou mapeamentos estéticos locais (dentro de cada camada geométrica).\nggplot(mpg, aes(displ, hwy)) + # mapeamentos gerais, se aplicam a todos os objetos\rgeom_point(aes(color = class)) + # mapeamento local, só se aplica aqui\rgeom_smooth(se = FALSE)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Ok, mas e se eu quisesse um modelo linear ao invés de um \u0026ldquo;Smoother de Loess\u0026rdquo;?\nggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Não vou entrar muito nos argumentos de cada objeto geométrico e função, vocês podem aprender isso na prática olhando a documentação das funções que são do interesse de vocês. ?geom_smooth para ver todas as possibilidades. Uma dica boa é usar geom_smooth para verificar interações entre variáveis numéricas e fatores.\nggplot(mpg, aes(displ, hwy, color = factor(cyl))) + geom_point() +\rgeom_smooth(method = lm)\r ## `geom_smooth()` using formula 'y ~ x'\r Ok, mas e se temos um gráfico de linhas mais tradicional, tipo uma série histórica?\neconomics\r ## # A tibble: 574 x 6\r## date pce pop psavert uempmed unemploy\r## \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 507. 198712 12.6 4.5 2944\r## 2 1967-08-01 510. 198911 12.6 4.7 2945\r## 3 1967-09-01 516. 199113 11.9 4.6 2958\r## 4 1967-10-01 512. 199311 12.9 4.9 3143\r## 5 1967-11-01 517. 199498 12.8 4.7 3066\r## 6 1967-12-01 525. 199657 11.8 4.8 3018\r## 7 1968-01-01 531. 199808 11.7 5.1 2878\r## 8 1968-02-01 534. 199920 12.3 4.5 3001\r## 9 1968-03-01 544. 200056 11.7 4.1 2877\r## 10 1968-04-01 544 200208 12.3 4.6 2709\r## # ... with 564 more rows\r Podemos criar um gráfico de linhas tendo como base a data (date) e alguma das variáveis registradas, como a taxa de desemprego.\nggplot(economics, aes(x = date, y = uempmed)) +\rgeom_line()\r Ou o consumo em bilhões de dólares\nggplot(economics, aes(x = date, y = pce)) +\rgeom_line()\r Ou a população\nggplot(economics, aes(x = date, y = pop)) +\rgeom_line()\r Ok, mas eu quero comparar visualmente o que ocorre com uma variável quando a outra muda. Podemos recorrer ao que aprendemos sobre mapeamentos estéticos globais e locais.\nggplot(economics, aes(x = date)) +\rgeom_line(aes(y = uempmed)) +\rgeom_line(aes(y = pce)) +\rgeom_line(aes(y = pop))\r Ficou meio ruim, porque as variável tem grandezas distintas. Podemos tentar resolver esse problema aplicando transformações na variável idade, mas meio que pra qualquer lugar onde caminhos, batemos numa parede ou noutra. Esse tipo de solução é muito frequente entre pessoas que vem do base pro ggplot2, porque no base estamos acostumado a ideia de adicionar mais objetos geométricos ao nosso gráfico original adicionando invocações à funções como lines ou text. Porém, a solução preferida no tidyverse é aplicar uma transformação no banco original de tal forma que as nossas variáveis numéricas caiam todas num par que especifica o nome da variável | e o valor dela.\nlibrary(tidyr)\reconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;)\r ## # A tibble: 2,870 x 3\r## date variavel valor\r## \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1967-07-01 pce 507. ## 2 1967-07-01 pop 198712 ## 3 1967-07-01 psavert 12.6\r## 4 1967-07-01 uempmed 4.5\r## 5 1967-07-01 unemploy 2944 ## 6 1967-08-01 pce 510. ## 7 1967-08-01 pop 198911 ## 8 1967-08-01 psavert 12.6\r## 9 1967-08-01 uempmed 4.7\r## 10 1967-08-01 unemploy 2945 ## # ... with 2,860 more rows\r Talvez não fique imediatamente claro para todos porque eu optei por esta solução, mas talvez essa próxima figura fale mais que mil palavras.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line() +\rfacet_wrap(~variavel, scales = \u0026quot;free_y\u0026quot;, ncol = 1)\r A ênfase em usar tidy data no tidyverse decorre do fato de que todos os pacotes são programados para usar a forma de organização do banco como uma alavanca para facilitar a análise de dados. Vejam esta outra pipeline.\n# Como vamos fazer algumas transformações nos dados, vamos carregar o dplyr aqui\rlibrary(dplyr)\r ## ## Attaching package: 'dplyr'\r ## The following objects are masked from 'package:stats':\r## ## filter, lag\r ## The following objects are masked from 'package:base':\r## ## intersect, setdiff, setequal, union\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, shape = variavel)) +\rgeom_line()\r E agora vejam um dos erros mais comuns de quem está começando:\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor)) +\rgeom_line()\r Ao não especificar uma separação entre grupos, o ggplot2 não interpreta meus dados! Ele simplesmente conecta as observações mais ou menos na ordem em que elas aparecem no eixo x. Para resolver esse problema, precisamos especificar grupos! Seja indiretamente, através de uma escala de cores, formas ou tipos de linha, seja diretamente através da estética groups.\neconomics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, group = variavel)) +\rgeom_line()\r economics %\u0026gt;% pivot_longer(cols = -date,\rnames_to = \u0026quot;variavel\u0026quot;,\rvalues_to = \u0026quot;valor\u0026quot;) %\u0026gt;% filter(variavel %in% c(\u0026quot;psavert\u0026quot;, \u0026quot;uempmed\u0026quot;)) %\u0026gt;% ggplot(aes(date, valor, color = variavel, linetype = variavel)) +\rgeom_line()\r Legal né?\nBarcharts Para terminar e ilustrar alguns exemplos de transformação estatística, vamos fazer alguns gráficos de barras usando o diamonds, um banco de dados para fazer a alegria das piores pessoas na história da humanidade.\ndiamonds\r ## # A tibble: 53,940 x 10\r## carat cut color clarity depth table price x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43\r## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31\r## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31\r## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63\r## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75\r## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48\r## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47\r## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53\r## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49\r## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39\r## # ... with 53,930 more rows\r Que tal um gráfico básico, do número de diamantes de acordo com a qualidade de seu corte (cut). Olhando a ajuda do ?geom_bar você vai na certeza de que você entendeu a aula e escreve o seguinte código:\nggplot(diamonds, aes(x = cut, color = cut)) +\rgeom_bar()\r E agora, você fica olhando pro seu computador com cara de tacho. O que aconteceu? Bom, no caso de geoms com duas dimensões, podem existir casos em que você quer dar mapeamentos estéticos distintos para as bordas e para o conteúdo deles. Por isso, existem as estéticas color e fill. Você pode pensar nelas como a casca do pão e o recheio.\nggplot(diamonds, aes(x = cut, fill = cut)) +\rgeom_bar()\r Mas, você ainda não está satisfeito. Pela sua ampla experiência com uma das indústrias mais sangrentas e retrógadas do planeta você entende que a qualidade do corte não é o suficiente para determinar o valor de um diamante, então você quer ver a distribuição também pelo nível de transparência do diamante, codificado na variável clarity.\nggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar()\r Esse é um primeiro passo interessante, e se tivessemos apenas duas ou três categorias, a gente poderia parar por aí. Mas no geral, para facilitar comparações, queremos poder controlar o posicionamento das barras. Isso é possível ajustando o argumento position dos geoms onde isso é necessário.\n# O padrão\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;stack\u0026quot;)\r # O certo\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;dodge\u0026quot;)\r # Empilhadas a 100%, para facilitar comparações entre categorias\rggplot(diamonds, aes(x = cut, fill = clarity)) +\rgeom_bar(position = \u0026quot;fill\u0026quot;)\r Pode parecer jocoso, mas em 99% dos casos, o correto é você usar barras lado-a-lado, assim você visualmente pode comparar as categorias simplesmente comparando a altura das barras. Da próxima vez que você pensar em construir um gráfico de pizza, desista e faça um gráfico de barras com position = \u0026quot;dodge\u0026quot;. Seus leitores vão agradecer.\nEsse exemplo também é legal para gente olhar um pouco para a parte de transformações estatísticas nas variáveis:\ndiamonds2 \u0026lt;- diamonds %\u0026gt;% count(cut) %\u0026gt;% mutate(prop = n/sum(n))\rdiamonds2 %\u0026gt;% ggplot() +\rgeom_bar(aes(x = cut, y = prop), stat = \u0026quot;identity\u0026quot;)\r Por padrão, geom_bar já faz o primeiro passo e utiliza as contagens (stat_count) para produzir o gráfico de barras, mas eu posso mudar esse comportamento através do argumento stat. Eu também posso querer mostrar proprções ao invés de contagens de outra forma mais sucinta.\nggplot(diamonds, aes(x = cut, # ao fazer isso, eu mudo o padrão de contagens para proporções.\ry = stat(prop), # preciso especificar o grupo, se não todas as barras vão a 100%.\rgroup = 1)) +\rgeom_bar()\r Você pode construir seus gráficos a partir de transformações estatísticas ao invés de objetos geométricos:\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\rfun = median\r)\r As transformações estatísticas começam sempre com stat_ e cada uma tem um objeto geométrico padrão, que você pode mudar com o argumento geom.\nggplot(data = diamonds) + stat_summary(\rmapping = aes(x = cut, y = depth),\rfun.min = min,\rfun.max = max,\r# Não dá pra mostrar a mediana com barras de erro, sorry\r#fun = median,\rgeom = \u0026quot;errorbar\u0026quot;\r)\r E era basicamente isso que eu tinha a dizer sobre como construir gráficos no ggplot2! Abaixo, uma seção com alguns detalhes para quem tiver interesse nessa parte de embelezamento dos gráficos.\nPerfumaria Essa seção pretende introduzir um pouco uma parte de customização dos gráficos. Frequentemente, as publicações de regras mais estritas sobre formatos, fontes, temas, etc. As opções padrão do ggplot2 podem não se acomodar, então, cabe a nós ajeitar essa reta final.\nTítulos e rótulos A melhor maneira de ajustar títulos e rótulos é através de labs, porque você resolve tudo em uma só invocação. Mas também há uma função ggtitle. Com ela, é possível setar apenas título e subtítulo.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;)\r A maioria das opções de customização mais fina está na camada theme. Internamente, cada elemento do gráfico é controlado por uma função element_, por exemplo, element_text desenha textos e recebe argumentos relativos a isso, como família da fonte, tamanho, cor, etc.\nAli, você tem um controle mais direto sobre a construção do gráfico. No que diz respeito aos rótulos, podemos mudar a fonte do título.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;))\r Usando uma síntaxe similar e os argumentos da função element_text, você pode mudar qual outro elemento textual do gráfico.\nEixos Continuando o nosso frankenstein, podemos fazer alterações nos eixos, como remover pedaços de um eixo, modificar sua forma, seu ângulo e ajustar sua posição.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rggtitle(\u0026quot;Título do gráfico\u0026quot;, \u0026quot;Subtítulo do gráfico\u0026quot;) +\r# Family é meio complicado de mudar, mas você pode escolher serif, sans ou mono\rtheme(plot.title = element_text(family = \u0026quot;serif\u0026quot;, face = \u0026quot;bold\u0026quot;, colour = \u0026quot;red\u0026quot;),\rplot.subtitle = element_text(family = \u0026quot;mono\u0026quot;, face = \u0026quot;italic\u0026quot;, color = \u0026quot;forestgreen\u0026quot;),\r# você pode remover pedaços inteiros do gráfico com \u0026quot;element_blank()\u0026quot;\raxis.ticks.y = element_blank(),\raxis.text.y = element_blank(),\raxis.title.y = element_blank(),\r# você pode mudar a orientação, angulo, posição e até formato de elementos\raxis.title = element_text(angle = 90, hjust = 1),\raxis.text.x = element_text(angle = 45, vjust = 1),\raxis.ticks.x = element_line(\rcolour = \u0026quot;royalblue3\u0026quot;,\rarrow = grid::arrow(angle = 45, length = unit(0.5, \u0026quot;cm\u0026quot;), ends = \u0026quot;first\u0026quot;, type = \u0026quot;closed\u0026quot;))\r)\r Realmente, o céu é o limite e você pode deixar o seu gráfico tão horrível quanto você quiser.\nLegendas Legendas no ggplot2 são controladas em alguns lugares diferentes. Elas são tratadas como guias (guides) no sentido de que são guias para o leitor. Vamos pegar outra variável de cores, para poder brincar com diferentes tipos de legenda.\nggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point()\r Por padrão, ele entende cilindros como numérico e faz uma barra de cores contínua. Mas eu quero uma legenda!\n# Jeito 1 - Simples e rápido\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = \u0026quot;legend\u0026quot;)\r # Jeito 2 - Posso mudar detalhes!\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\rguides(color = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;))\r # Jeito 3 - Mexendo diretamente nas escalas\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(guide = \u0026quot;legend\u0026quot;, option = \u0026quot;B\u0026quot;)\r # Jeito 3 - de novo, mas agora usando a especificação mais completa do guia\rggplot(mpg, aes(displ, hwy, color = cyl)) +\rgeom_point() +\r# Minha escala de cores preferida\rscale_color_viridis_c(\rguide = guide_legend(title = \u0026quot;Cilindrossss\u0026quot;,\rtitle.position = \u0026quot;right\u0026quot;,\rlabel.position = \u0026quot;bottom\u0026quot;,\rdirection = \u0026quot;horizontal\u0026quot;), option = \u0026quot;B\u0026quot;)\r Em qualquer lugar onde você possa especificar guides, você pode passar o valor FALSE para remover a legenda.\n# Na camada \u0026quot;guides()\u0026quot;\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rguides(color = FALSE)\r # Na própria escala\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rscale_size(guide = FALSE)\r # Bônus = no tema, mas aí você remove todas\rggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point() +\rtheme(legend.position = \u0026quot;none\u0026quot;)\r Escalas Já dei uma palhinha de editar escalas, antes, então aqui vai um pouco mais de detalhe:\nggplot(mpg, aes(displ, hwy, color = cyl, size = cyl)) +\rgeom_point()\r # Mudar as cores manualmente\rcores \u0026lt;- c(\u0026quot;red\u0026quot;, \u0026quot;green\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;yellow\u0026quot;, \u0026quot;purple\u0026quot;, \u0026quot;tomato\u0026quot;, \u0026quot;wheat2\u0026quot;)\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores)\r # Mudar os tamanhos\rggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_radius para fazer proprcional ao raio\rscale_radius(range = c(3,6))\r ggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_color_manual(values = cores) +\r# scale_size para fazer proprcional a área\rscale_size(range = c(2,4))\r É possível aplicar transformações na variável diretamente na escala, mudar o número de breaks e especificar labels e alterar os limites do gráfico manualmente.\nggplot(mpg, aes(displ, hwy, color = class, size = cyl)) +\rgeom_point() +\rscale_x_continuous(trans = \u0026quot;sqrt\u0026quot;, name = \u0026quot;Peso\u0026quot;) +\rscale_y_continuous(\rname = \u0026quot;Consumo (rodovia)\u0026quot;,\rlimits = c(0, 50),\rbreaks = c(10, 20, 30, 40, 50), labels = c(\u0026quot;fogo no clima\u0026quot;, \u0026quot;aquecimento global\u0026quot;, \u0026quot;caldeira planetária\u0026quot;, \u0026quot;deixa pra próxima geração\u0026quot;, \u0026quot;desastre em câmera lenta\u0026quot;))\r Cada escala vai ter argumentos específicos que fazem sentido em seu próprio contexto. Escalas contínuas tem argumentos para transformação estatística, escalas discretas não aceitam argumentos contínuos e etc.\nIsto encerra nossa parte de ggplot2, que tal uns exercícios pra esquentar?\nExercícios  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?\n  Utilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.\n  Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.\n  No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?\n  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  ggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r  Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.\n  Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.\n  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Tente recriar o seguinte gráfico  ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"b9e37b7e1055bb09bf3bd731ebee0b86","permalink":"https://laddem.github.io/courses/tidyverse/dia3/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia3/","section":"courses","summary":"O pacote ggplot2 e a \u0026ldquo;gramática dos gráficos\u0026rdquo; Ainda me lembro da primeira vez que li o terceiro capítulo de R for Data Science em que o conceito de visualização de dados é apresentado junto com a ideia de data.","tags":null,"title":"ggplot2","type":"book"},{"authors":null,"categories":null,"content":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer. Pra não ficar uma coisa solta no começo da aula, aqui uma foto de gatinho pra vocês:\nO assunto da aula de hoje é talvez um pouco mais abstrato do que as aulas anteriores. Vamos falar bastante de funções, loops e programação funcional. São termos que fazem parte do jargão da computação, mas que mesmo usuários veteranos do R como software estatístico para análise de dados podem ter pouca familiaridade. Ao invés de começar definindo o que vamos fazer, vou começar definindo o que não vamos.\n  Não vamos revisar a fundo o assunto de iterações. Os livros fazem um bom serviço, é um assunto espinhoso e não basta compreender os conceitos, tem que botar a mão na massa pra ter um entendimento não apenas da teoria, mas também para conseguir resolver os muitos problemas que aparecem quando você está construindo iterações com maior nível de complexidade.\n  Não vamos cavar fundo em todos os aspectos da programação funcional ou de todas as funções do purrr. São muitas e temos poucas horas.\n  Agora o que SIM vamos fazer é revisar muito brevemente a sintaxe de um for loop, ver em que situações a gente o utilizaria e como você pode substituir seus vários for loops por funções no purrr, com exemplos de aplicação quando possível. Se der tempo, vamos entrar um pouco na ideia de utilizar programação funcional para resolver problemas mais genéricos em que precisamos generalizar alguma tarefa.\n# Primeiro, nossos pacotes!\rlibrary(tidyverse) # o purrr já é carregado automaticamente junto com os outros,\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r # Se quiser carregar apenas o purrr, descomente a linha abaixo\r# library(purrr)\r Iterações Do ponto de vista prático, uma iteração é uma repetição uma linha de código de tal forma que apenas uma pequena parte previsível do código muda entre uma repetição e outra. Por exemplo, digamos que você vai calcular uma soma de x.\nx \u0026lt;- runif(100, 0, 1000)\rx\r ## [1] 511.21033 511.89922 773.63835 75.66633 722.47241 117.13315 951.66865\r## [8] 105.49553 770.73902 497.39858 324.68612 717.92247 527.07341 585.00887\r## [15] 380.39971 17.15150 957.58816 225.99117 653.19930 276.15361 531.60984\r## [22] 496.43149 804.00073 727.48489 86.62227 951.70058 382.33849 624.78218\r## [29] 83.78090 591.81424 473.27932 777.49061 467.26225 319.52625 14.61723\r## [36] 843.51570 657.64747 509.07023 60.33003 933.35876 91.72044 351.31833\r## [43] 595.22138 148.48688 31.02683 245.96797 491.90911 303.65395 993.94694\r## [50] 14.63012 532.77839 978.14352 985.71426 259.13229 545.54421 835.12723\r## [57] 900.39120 598.04300 85.86639 917.62820 902.74467 883.72252 511.84901\r## [64] 101.90038 346.86150 655.52290 447.19990 755.65847 546.60029 341.40437\r## [71] 550.06610 356.46386 645.91008 690.29805 11.03944 831.26283 821.42773\r## [78] 216.10993 687.41842 536.72430 833.02925 298.43149 470.50705 368.70771\r## [85] 609.66773 738.84025 675.22583 348.49183 453.19584 579.29202 190.77600\r## [92] 943.77276 22.31339 641.31284 28.05916 606.97261 344.78386 874.06792\r## [99] 974.14733 618.56387\r Esqueça, por um instante, a função sum. O cálculo da soma se dá pela soma de todos os elementos do vetor x. Então, é necessário repetir a operação de soma através da acumulação dos valores. Veja que é tudo totalmente previsível, cada nova repetição simplesmente adiciona mais um valor ao vetor original e esse valor pode ser encontrado na próxima posição de x. Esse é o típico caso de iteração. No R, a melhor prática é inicializar uma variável antes e salvar os resultados da iteração nela.\n# Inicialização\rresult \u0026lt;- x[[1]]\r# Sequência\rfor (i in 2:length(x)) {\r# Corpo\rresult \u0026lt;- result + x[[i]]\r}\r# Comparando os dois resultados\rresult\r ## [1] 51405.75\r sum(x)\r ## [1] 51405.75\r Outro exemplo de mesmo tipo é repetição de uma mesma operação em vários vetores/colunas/variáveis comuns. Por exemplo, se eu tenho um data.frame com três colunas numéricas e eu gostaria de calcular a soma de cada uma.\n# Data.frame\rdf \u0026lt;- tibble(x = rnorm(100, 50, 25),\ry = rnorm(100, 100, 25),\rz = rnorm(100, 200, 25))\r# Inicialização\rresult \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = length(df))\r# Sequência\rfor (i in seq_along(df)) {\rresult[[i]] \u0026lt;- sum(df[[i]])\r}\r# Resultado\rresult\r ## [1] 5175.084 10214.559 19979.241\r Essa é a minha revisão de 5 minutos de iteração em R usando for loops. Como já é de costume, tem muito mais. Por exemplo, existe um outro tipo de iterador no R básico chamado while, que tem um funcionamento diferente do for. Ao invés de você ter um resultado de tamanho previsível, você pode ter um resultado de tamanho desconhecido. Vou deixar o while para vocês pesquisarem porque o bom e velho for costuma cobrir a maioria dos casos de uso do cientista de dados.\nProgramação funcional Beleza, agora que já dominamos (ou não) o for loop, encontramos várias situações em que a gente gostaria de realizar a mesma operação várias vezes, mas, o for loop é como uma feijoada: é gostoso, mas é pesado. For loops em geral são \u0026ldquo;verbosos\u0026rdquo;, você precisa escrever bastante para chegar em um determinado resultado e, depois de escrever alguns, você cansa de ter que repetir todos os pedaços dele. E se você pudesse abstrair o loop para uma função? Aí você não precisaria escrever toda aquela parafernalha.\nsoma \u0026lt;- function(x) {\rresult \u0026lt;- 0\rfor (i in 1:length(x)) {\rresult \u0026lt;- result + x[[i]]\r}\rresult\r}\rsoma(x)\r ## [1] 51405.75\r Ao fazer isso, eu ganho duas vantagens:\n  Manutenção: sempre que eu precisar repetir a operação, eu consigo simplificar muito meu código. Não preciso escrever um for loop para cada soma que eu precisar fazer. Se meus requerimentos mudarem no futuro, eu só preciso mudar um pedaço de código.\n  Leitura: o humano que lê um for loop vai precisar de um minuto para se familiarizar com a operação e entender o que está sendo iterado, calculado, etc. O humano que lê \u0026ldquo;soma\u0026rdquo; sabe que ocorrerá uma soma. Você alinha a expectativa com a execução.\n  Outro exemplo.\nsoma_xyz \u0026lt;- function(x) {\rsoma_xyz \u0026lt;- vector(mode = \u0026quot;double\u0026quot;, length = nrow(x))\rfor (i in seq_along(x[[1]])) {\rsoma_xyz[[i]] \u0026lt;- x[[1]][[i]] + x[[2]][[i]] + x[[3]][i]\r}\rsoma_xyz\r}\rdf$soma_xyz2 \u0026lt;- soma_xyz(df)\rdf\r ## # A tibble: 100 x 4\r## x y z soma_xyz2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 64.0 84.6 204. 352.\r## 2 80.3 81.0 210. 371.\r## 3 56.7 124. 210. 391.\r## 4 88.0 99.6 222. 409.\r## 5 8.80 91.8 220. 320.\r## 6 33.6 105. 175. 314.\r## 7 63.3 94.3 202. 359.\r## 8 44.4 79.0 191. 314.\r## 9 59.4 119. 192. 371.\r## 10 27.8 45.1 202. 275.\r## # ... with 90 more rows\r Outra vantagem de ter na mão uma função, é que eu posso me apropriar das ferramentas de programação funcional do R. São as funções da família apply, que recebem uma lista de objetos e aplicam uma função em cada um. Basicamente, aquela abstração do for loop que estavamos buscando.\nVejam como eu posso recriar o exemplo das somas das colunas do data.frame usando a função soma.\nsapply(df, soma)\r ## x y z soma_xyz2 ## 5175.084 10214.559 19979.241 35368.884\r Eu sei, o exemplo é muito simples pra ter uma aplicação real. Até porque já vimos como fazer esse tipo de operação com summarize lá atrás. Mas talvez, na hora que você estiver realizando alguma operação de repetição, você se lembre dessa possibilidade e ela lhe seja útil.\no pacote purrr Até o momento, nos limitamos a utilizar funções presentes no base, mas o verdadeiro intuito dessa aula é introduzir as facilidade trazidas pelas funções do tidyverse. No pacote purrr, são importadas funções com diversas funcionalidades que facilitam o trabalho com objetos mais complexos, como listas (pense saída de modelo), iterações envolvendo mais de um argumento (pense escrever diversos objetos em diversos arquivos distintos) e assim sucessivamente. Abaixo, segue uma lista das funções do pacote com uma descrição curta.\n  a família map_(): similar a família apply do R base. Recebe uma lista de objetos de entrada e uma função e devolve uma lista com os resultados.\n  map2_(): mesma coisa, só que você pode passar duas listas de objetos e uma função que requer dois argumentos variáveis. pmap() é a generalização, em que você passa p listas e uma função que pede p argumentos.\n  imap(): aplica uma função tanto ao vetor, como a seu nome/índice. É meio louco, mas é muito útil para alguns casos de uso.\n  modify_(): permite aplicar alterações no objeto estilo o que você faria com uma pipeline de filter %\u0026gt;% mutate\n  safely(): e suas irmãs possibly() e quietly() ajudam a obter resultados mesmo quando há ocorre um erro na iteração.\n  transpose(), flatten_: manipulam e reformatam listas.\n  invoke_map(): aplica uma lista de funções a uma (opcional) segunda lista de parâmetros.\n  reduce() e accumulate(): generalizam as operações de sumarização (pense soma acumulada, média, limite, fatorial)\n  pluck(): pesca elementos de uma lista com uma sintaxe linear e bonitinha.\n  E muito mais coisas\n  No interesse de ir direto ao ponto e não tentar ser exaustivo, vamos ver algumas delas em mais detalhe.\nA função map Essa função é praticamente uma cópia de lapply.\ndf %\u0026gt;% lapply(sum)\r ## $x\r## [1] 5175.084\r## ## $y\r## [1] 10214.56\r## ## $z\r## [1] 19979.24\r## ## $soma_xyz2\r## [1] 35368.88\r df %\u0026gt;% map(sum)\r ## $x\r## [1] 5175.084\r## ## $y\r## [1] 10214.56\r## ## $z\r## [1] 19979.24\r## ## $soma_xyz2\r## [1] 35368.88\r Embora existam pequenas diferenças técnicas entre elas, a principal vantagem de map é a possibilidade de criar funções anônimas com uma síntaxe enxuta. Pense, por exemplo, em elevar ao quadrado.\ndf %\u0026gt;% lapply(function(x) x ^ 2)\r ## $x\r## [1] 4101.73466 6442.94757 3219.96411 7740.50083 77.52392 1127.58641\r## [7] 4003.18277 1970.49014 3530.47096 774.99987 2443.20895 2865.99209\r## [13] 4835.03006 2291.73704 3472.69766 1827.06745 1954.20529 5005.39589\r## [19] 599.55337 6840.21539 2690.90027 4443.48342 8176.61716 1122.35347\r## [25] 6124.43204 4090.38758 1258.12990 2903.93407 1505.60524 816.50506\r## [31] 2762.76527 10206.93299 3383.39474 3929.24440 858.32911 299.32177\r## [37] 6349.05638 465.28473 1911.37533 7033.14246 813.33451 1467.96694\r## [43] 2018.47077 2411.16517 1945.70017 3561.26161 1401.68199 3657.67548\r## [49] 5975.33518 3707.27733 82.02548 8828.42227 6899.83497 938.19812\r## [55] 3413.88464 927.31285 1181.68012 2922.96590 2157.63334 4754.98150\r## [61] 3069.83817 2994.45852 20.95274 3286.19224 5448.84573 4614.42975\r## [67] 5147.05677 3342.69959 2750.92683 916.98522 138.26289 3952.18991\r## [73] 5720.72876 2815.19365 2091.69446 1278.02274 10.68606 1700.03805\r## [79] 3664.47310 5700.26729 155.81705 964.87730 1704.68622 1187.67307\r## [85] 2495.20060 5450.75572 934.23105 4995.71787 3996.69171 3570.77096\r## [91] 3647.71154 8265.66190 8104.97900 2787.03070 105.38002 2139.97839\r## [97] 2188.88388 4027.12053 1516.84960 4629.35075\r## ## $y\r## [1] 7151.412 6565.904 15465.469 9912.371 8422.026 11062.683 8898.726\r## [8] 6233.135 14195.810 2030.401 5565.017 15515.046 11528.588 9451.909\r## [15] 6173.870 4146.633 3164.735 18272.908 24261.140 17448.823 17156.170\r## [22] 4154.849 10407.268 10852.507 12008.867 11661.905 9962.577 5827.709\r## [29] 1917.046 11350.607 12628.009 14620.744 8851.069 7313.565 10635.098\r## [36] 8405.690 11204.093 10624.971 6625.751 17180.077 6758.962 14635.734\r## [43] 15028.864 6287.385 9670.247 27097.833 12444.103 5174.200 1987.106\r## [50] 3968.708 14741.992 7745.702 7529.071 11367.992 11004.793 13263.630\r## [57] 14356.074 15834.530 11392.086 13884.453 8110.941 3459.290 17805.823\r## [64] 9464.322 10653.107 13969.328 16219.520 4533.473 5779.148 7423.940\r## [71] 19330.647 20030.626 10051.328 7654.627 2168.127 17940.152 11978.961\r## [78] 7928.637 15345.071 5966.271 15963.726 14123.782 4730.376 22526.893\r## [85] 13404.375 15081.751 19130.641 27500.443 6542.030 10927.504 3684.683\r## [92] 9811.098 15832.925 17041.849 17629.378 6607.492 5663.422 11701.811\r## [99] 6023.724 21869.526\r## ## $z\r## [1] 41508.55 43955.22 44122.17 49181.30 48234.98 30624.13 40730.31 36356.66\r## [9] 36849.43 40839.24 47870.88 55940.49 56158.85 52453.95 36367.21 33702.16\r## [17] 40651.44 37526.54 33466.91 40098.83 21280.36 31668.90 59987.43 42429.94\r## [25] 47436.91 56383.51 42850.74 33140.52 30740.82 33382.25 39325.68 29803.55\r## [33] 27582.72 36055.88 30141.33 43135.68 49081.05 35531.51 40896.89 40136.05\r## [41] 58039.94 40374.40 20277.93 48318.24 41539.72 53062.55 61468.63 33130.61\r## [49] 41153.57 25438.34 34253.86 50562.05 24140.92 42847.66 38727.46 36720.32\r## [57] 51322.56 51123.33 30686.04 26044.65 35205.08 55941.68 39308.71 34987.88\r## [65] 42918.57 31031.96 52151.91 25617.74 21877.90 43197.98 50814.30 41798.91\r## [73] 58608.88 42227.48 54186.38 59475.44 41981.70 23404.82 40336.76 35826.02\r## [81] 46172.67 58244.33 31089.67 40382.25 57512.31 29234.02 46584.44 42845.56\r## [89] 31071.13 43848.77 44352.73 40918.43 32501.86 25508.47 48716.72 43616.08\r## [97] 44454.40 26486.83 27212.78 35157.45\r## ## $soma_xyz2\r## [1] 124148.61 137606.30 153004.39 167534.34 102528.67 98443.05 129183.67\r## [8] 98605.19 137289.51 75617.30 117526.93 171902.94 171300.16 139966.73\r## [15] 107718.82 84518.14 91254.97 159715.19 131903.56 172263.61 108065.60\r## [22] 95527.45 191287.26 118103.71 164546.97 167607.18 117160.41 97514.41\r## [29] 66521.08 101010.74 131945.81 155695.49 101332.42 114302.78 93658.30\r## [36] 100282.91 165708.24 98060.42 107156.57 172454.54 123655.43 129762.85\r## [43] 96050.56 121250.73 119896.30 206700.80 157546.17 98865.47 105456.51\r## [50] 80303.71 99572.67 165510.17 105760.85 118506.39 129690.11 113734.26\r## [57] 144960.84 164839.64 107819.22 121223.89 110953.64 122540.12 113084.32\r## [64] 116731.92 147608.24 131247.09 182727.87 81340.51 76386.89 105160.94\r## [71] 124394.78 167153.29 174711.06 119745.34 105675.64 171036.97 100877.23\r## [78] 80236.65 148417.75 116977.26 125109.75 153072.34 82018.20 148614.57\r## [85] 164467.96 135141.96 148004.12 196696.37 102638.38 139645.42 110024.06\r## [92] 153859.84 156926.37 117683.63 132321.18 113158.92 110811.31 111811.48\r## [99] 79254.85 162752.56\r df %\u0026gt;% map(~ .x ^ 2)\r ## $x\r## [1] 4101.73466 6442.94757 3219.96411 7740.50083 77.52392 1127.58641\r## [7] 4003.18277 1970.49014 3530.47096 774.99987 2443.20895 2865.99209\r## [13] 4835.03006 2291.73704 3472.69766 1827.06745 1954.20529 5005.39589\r## [19] 599.55337 6840.21539 2690.90027 4443.48342 8176.61716 1122.35347\r## [25] 6124.43204 4090.38758 1258.12990 2903.93407 1505.60524 816.50506\r## [31] 2762.76527 10206.93299 3383.39474 3929.24440 858.32911 299.32177\r## [37] 6349.05638 465.28473 1911.37533 7033.14246 813.33451 1467.96694\r## [43] 2018.47077 2411.16517 1945.70017 3561.26161 1401.68199 3657.67548\r## [49] 5975.33518 3707.27733 82.02548 8828.42227 6899.83497 938.19812\r## [55] 3413.88464 927.31285 1181.68012 2922.96590 2157.63334 4754.98150\r## [61] 3069.83817 2994.45852 20.95274 3286.19224 5448.84573 4614.42975\r## [67] 5147.05677 3342.69959 2750.92683 916.98522 138.26289 3952.18991\r## [73] 5720.72876 2815.19365 2091.69446 1278.02274 10.68606 1700.03805\r## [79] 3664.47310 5700.26729 155.81705 964.87730 1704.68622 1187.67307\r## [85] 2495.20060 5450.75572 934.23105 4995.71787 3996.69171 3570.77096\r## [91] 3647.71154 8265.66190 8104.97900 2787.03070 105.38002 2139.97839\r## [97] 2188.88388 4027.12053 1516.84960 4629.35075\r## ## $y\r## [1] 7151.412 6565.904 15465.469 9912.371 8422.026 11062.683 8898.726\r## [8] 6233.135 14195.810 2030.401 5565.017 15515.046 11528.588 9451.909\r## [15] 6173.870 4146.633 3164.735 18272.908 24261.140 17448.823 17156.170\r## [22] 4154.849 10407.268 10852.507 12008.867 11661.905 9962.577 5827.709\r## [29] 1917.046 11350.607 12628.009 14620.744 8851.069 7313.565 10635.098\r## [36] 8405.690 11204.093 10624.971 6625.751 17180.077 6758.962 14635.734\r## [43] 15028.864 6287.385 9670.247 27097.833 12444.103 5174.200 1987.106\r## [50] 3968.708 14741.992 7745.702 7529.071 11367.992 11004.793 13263.630\r## [57] 14356.074 15834.530 11392.086 13884.453 8110.941 3459.290 17805.823\r## [64] 9464.322 10653.107 13969.328 16219.520 4533.473 5779.148 7423.940\r## [71] 19330.647 20030.626 10051.328 7654.627 2168.127 17940.152 11978.961\r## [78] 7928.637 15345.071 5966.271 15963.726 14123.782 4730.376 22526.893\r## [85] 13404.375 15081.751 19130.641 27500.443 6542.030 10927.504 3684.683\r## [92] 9811.098 15832.925 17041.849 17629.378 6607.492 5663.422 11701.811\r## [99] 6023.724 21869.526\r## ## $z\r## [1] 41508.55 43955.22 44122.17 49181.30 48234.98 30624.13 40730.31 36356.66\r## [9] 36849.43 40839.24 47870.88 55940.49 56158.85 52453.95 36367.21 33702.16\r## [17] 40651.44 37526.54 33466.91 40098.83 21280.36 31668.90 59987.43 42429.94\r## [25] 47436.91 56383.51 42850.74 33140.52 30740.82 33382.25 39325.68 29803.55\r## [33] 27582.72 36055.88 30141.33 43135.68 49081.05 35531.51 40896.89 40136.05\r## [41] 58039.94 40374.40 20277.93 48318.24 41539.72 53062.55 61468.63 33130.61\r## [49] 41153.57 25438.34 34253.86 50562.05 24140.92 42847.66 38727.46 36720.32\r## [57] 51322.56 51123.33 30686.04 26044.65 35205.08 55941.68 39308.71 34987.88\r## [65] 42918.57 31031.96 52151.91 25617.74 21877.90 43197.98 50814.30 41798.91\r## [73] 58608.88 42227.48 54186.38 59475.44 41981.70 23404.82 40336.76 35826.02\r## [81] 46172.67 58244.33 31089.67 40382.25 57512.31 29234.02 46584.44 42845.56\r## [89] 31071.13 43848.77 44352.73 40918.43 32501.86 25508.47 48716.72 43616.08\r## [97] 44454.40 26486.83 27212.78 35157.45\r## ## $soma_xyz2\r## [1] 124148.61 137606.30 153004.39 167534.34 102528.67 98443.05 129183.67\r## [8] 98605.19 137289.51 75617.30 117526.93 171902.94 171300.16 139966.73\r## [15] 107718.82 84518.14 91254.97 159715.19 131903.56 172263.61 108065.60\r## [22] 95527.45 191287.26 118103.71 164546.97 167607.18 117160.41 97514.41\r## [29] 66521.08 101010.74 131945.81 155695.49 101332.42 114302.78 93658.30\r## [36] 100282.91 165708.24 98060.42 107156.57 172454.54 123655.43 129762.85\r## [43] 96050.56 121250.73 119896.30 206700.80 157546.17 98865.47 105456.51\r## [50] 80303.71 99572.67 165510.17 105760.85 118506.39 129690.11 113734.26\r## [57] 144960.84 164839.64 107819.22 121223.89 110953.64 122540.12 113084.32\r## [64] 116731.92 147608.24 131247.09 182727.87 81340.51 76386.89 105160.94\r## [71] 124394.78 167153.29 174711.06 119745.34 105675.64 171036.97 100877.23\r## [78] 80236.65 148417.75 116977.26 125109.75 153072.34 82018.20 148614.57\r## [85] 164467.96 135141.96 148004.12 196696.37 102638.38 139645.42 110024.06\r## [92] 153859.84 156926.37 117683.63 132321.18 113158.92 110811.31 111811.48\r## [99] 79254.85 162752.56\r Através do uso de fórmulas ~ é possível especificar funções anônimas simples economizando caracteres e utilizando o autocompletar.\nQue tal esta pipeline?\nlibrary(nycflights13)\r# Médias de todas as variáveis numéricas usando where()\rflights %\u0026gt;% select(where(is.numeric)) %\u0026gt;% map(mean)\r ## $year\r## [1] 2013\r## ## $month\r## [1] 6.54851\r## ## $day\r## [1] 15.71079\r## ## $dep_time\r## [1] NA\r## ## $sched_dep_time\r## [1] 1344.255\r## ## $dep_delay\r## [1] NA\r## ## $arr_time\r## [1] NA\r## ## $sched_arr_time\r## [1] 1536.38\r## ## $arr_delay\r## [1] NA\r## ## $flight\r## [1] 1971.924\r## ## $air_time\r## [1] NA\r## ## $distance\r## [1] 1039.913\r## ## $hour\r## [1] 13.18025\r## ## $minute\r## [1] 26.2301\r Ou esta\n# Proporção de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(mean)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 0.02451184\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 0.02451184\r## ## $arr_time\r## [1] 0.0258718\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 0.02800081\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 0.007458964\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 0.02800081\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r # Contagem de missings em todas as variáveis\rflights %\u0026gt;% map(is.na) %\u0026gt;% map(sum)\r ## $year\r## [1] 0\r## ## $month\r## [1] 0\r## ## $day\r## [1] 0\r## ## $dep_time\r## [1] 8255\r## ## $sched_dep_time\r## [1] 0\r## ## $dep_delay\r## [1] 8255\r## ## $arr_time\r## [1] 8713\r## ## $sched_arr_time\r## [1] 0\r## ## $arr_delay\r## [1] 9430\r## ## $carrier\r## [1] 0\r## ## $flight\r## [1] 0\r## ## $tailnum\r## [1] 2512\r## ## $origin\r## [1] 0\r## ## $dest\r## [1] 0\r## ## $air_time\r## [1] 9430\r## ## $distance\r## [1] 0\r## ## $hour\r## [1] 0\r## ## $minute\r## [1] 0\r## ## $time_hour\r## [1] 0\r A outra grande vantagem do map é ter acesso fácil ao controle do tipo de saída.\n# Vetor numérico\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_dbl(mean)\r ## year month day dep_time sched_dep_time ## 0.000000000 0.000000000 0.000000000 0.024511842 0.000000000 ## dep_delay arr_time sched_arr_time arr_delay carrier ## 0.024511842 0.025871796 0.000000000 0.028000808 0.000000000 ## flight tailnum origin dest air_time ## 0.000000000 0.007458964 0.000000000 0.000000000 0.028000808 ## distance hour minute time_hour ## 0.000000000 0.000000000 0.000000000 0.000000000\r # Vetor de caracteres\rflights %\u0026gt;% map(is.na) %\u0026gt;% map_chr(mean)\r ## year month day dep_time sched_dep_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.024512\u0026quot; \u0026quot;0.000000\u0026quot; ## dep_delay arr_time sched_arr_time arr_delay carrier ## \u0026quot;0.024512\u0026quot; \u0026quot;0.025872\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; \u0026quot;0.000000\u0026quot; ## flight tailnum origin dest air_time ## \u0026quot;0.000000\u0026quot; \u0026quot;0.007459\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.028001\u0026quot; ## distance hour minute time_hour ## \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot; \u0026quot;0.000000\u0026quot;\r Um exemplo um pouco mais elaborado: avaliação inicial de variáveis em um modelo. Em geral, é comum rodar um modelo para cada variável numérica para ver como elas se comportam.\nrespvar \u0026lt;- \u0026quot;hwy\u0026quot;\rpredvars \u0026lt;- names(select(mpg, where(is.numeric), -hwy))\rtibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rsummary = map(fit, summary),\rr2 = map_dbl(summary, \u0026quot;r.squared\u0026quot;),\rFStat = map_df(summary, \u0026quot;fstatistic\u0026quot;),\rcoefs = map_df(fit, coef),\r)\r ## # A tibble: 4 x 6\r## names fit summary r2 FStat$value $numdf $dendf coefs$`(Interce~ $displ\r## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.87e-1 329. 1 232 35.7 -3.53\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;smmry~ 4.66e-6 0.00108 1 232 17.7 NA ## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;smmry~ 5.81e-1 321. 1 232 40.0 NA ## 4 cty \u0026lt;lm\u0026gt; \u0026lt;smmry~ 9.14e-1 2459. 1 232 0.892 NA\r Ok, a saída não está muito bonitinha! Mas com um pouco mais de trabalho, programadores melhores que eu fizeram isso:\nmodels \u0026lt;- tibble(\rnames = predvars,\rfit = map(names, ~lm(paste0(respvar, \u0026quot;~\u0026quot;, .x), data = mpg)),\rtidied = fit %\u0026gt;% map(broom::tidy),\rglanced = fit %\u0026gt;% map(broom::glance),\raugmented = fit %\u0026gt;% map(broom::augment)\r)\rmodels\r ## # A tibble: 4 x 5\r## names fit tidied glanced augmented ## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; ## 1 displ \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 2 year \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 3 cyl \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r## 4 cty \u0026lt;lm\u0026gt; \u0026lt;tibble [2 x 5]\u0026gt; \u0026lt;tibble [1 x 12]\u0026gt; \u0026lt;tibble [234 x 8]\u0026gt;\r Grande coisa, Vinícius, o output é ilegível! Calma! Lembram da primeira aula em que eu comentei que havia mais funções no tidyr?\n# Coeficientes\rmodels %\u0026gt;% select(tidied) %\u0026gt;%\rtidyr::unnest(tidied) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)\r ## # A tibble: 4 x 5\r## term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ -3.53 0.195 -18.2 2.04e- 46\r## 2 year 0.00285 0.0867 0.0329 9.74e- 1\r## 3 cyl -2.82 0.157 -17.9 1.18e- 45\r## 4 cty 1.34 0.0270 49.6 1.87e-125\r # Estatísticas do modelo\rmodels %\u0026gt;% select(names, glanced) %\u0026gt;% unnest(glanced)\r ## # A tibble: 4 x 13\r## names r.squared adj.r.squared sigma statistic p.value df logLik AIC\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 0.587 0.585 3.84 329. 2.04e- 46 1 -646. 1297.\r## 2 year 0.00000466 -0.00431 5.97 0.00108 9.74e- 1 1 -749. 1504.\r## 3 cyl 0.581 0.579 3.87 321. 1.18e- 45 1 -647. 1301.\r## 4 cty 0.914 0.913 1.75 2459. 1.87e-125 1 -462. 931.\r## # ... with 4 more variables: BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;, df.residual \u0026lt;int\u0026gt;,\r## # nobs \u0026lt;int\u0026gt;\r # Bancos \u0026quot;aumentados\u0026quot; com valores ajustados, resíduos, distâncias de cook, etc.\rmodels %\u0026gt;% filter(names == \u0026quot;displ\u0026quot;) %\u0026gt;% select(names, augmented) %\u0026gt;% unnest(augmented)\r ## # A tibble: 234 x 9\r## names hwy displ .fitted .resid .hat .sigma .cooksd .std.resid\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 2 displ 29 1.8 29.3 -0.343 0.0115 3.84 0.0000468 -0.0898\r## 3 displ 31 2 28.6 2.36 0.00984 3.84 0.00191 0.619 ## 4 displ 30 2 28.6 1.36 0.00984 3.84 0.000634 0.357 ## 5 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 6 displ 26 2.8 25.8 0.188 0.00543 3.84 0.00000660 0.0491\r## 7 displ 27 3.1 24.8 2.25 0.00463 3.84 0.000802 0.587 ## 8 displ 26 1.8 29.3 -3.34 0.0115 3.84 0.00445 -0.876 ## 9 displ 25 1.8 29.3 -4.34 0.0115 3.83 0.00751 -1.14 ## 10 displ 28 2 28.6 -0.636 0.00984 3.84 0.000138 -0.167 ## # ... with 224 more rows\r Isso aqui é só uma palhinha de modelagem com o tidyverse, mas acho que é uma demonstração muito convincente da aplicabilidade dos exemplos que vimos usando programação funcional.\nOutro exemplo mais simples com map2: salvar vários arquivos de uma vez só.\ndf1 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf2 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf3 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdf4 \u0026lt;- tibble(x = rnorm(100), y = rnorm(100), z = rnorm(100))\rdfs \u0026lt;- list(df1, df2, df3, df4)\rdfs\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.423 0.647 0.340 ## 2 0.168 -0.654 0.134 ## 3 0.317 -1.52 0.479 ## 4 -0.0876 0.229 -0.579 ## 5 1.08 1.01 -1.05 ## 6 0.0523 0.726 -0.790 ## 7 0.967 -1.01 -0.814 ## 8 0.772 0.262 1.28 ## 9 -1.07 -0.549 -0.759 ## 10 1.19 0.768 -0.0372\r## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.426 0.427 -0.428 ## 2 -0.532 0.0595 -1.46 ## 3 0.211 -0.125 1.14 ## 4 0.853 -0.376 -0.0773 ## 5 1.45 1.32 -0.248 ## 6 -1.11 0.785 -0.0661 ## 7 -1.03 -0.237 -0.00866\r## 8 0.950 0.449 1.25 ## 9 -0.467 -0.0485 0.168 ## 10 0.886 -0.338 -0.376 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.69 -0.524 -0.0254 ## 2 -2.34 2.02 0.459 ## 3 -1.01 -0.0508 0.678 ## 4 0.117 -0.427 -0.240 ## 5 -2.26 -0.598 -0.863 ## 6 0.801 0.397 -0.923 ## 7 -0.484 0.501 0.00797\r## 8 1.07 1.49 0.587 ## 9 0.102 -1.25 0.393 ## 10 -1.09 -0.789 1.65 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.563 -0.756 1.34 ## 2 0.150 0.664 0.373 ## 3 -0.762 1.28 -1.12 ## 4 0.888 0.920 -0.0385\r## 5 -0.786 1.66 -0.914 ## 6 1.27 -0.454 0.721 ## 7 1.39 -0.567 0.289 ## 8 -1.49 0.489 0.545 ## 9 -0.173 0.780 -1.17 ## 10 0.335 -0.947 -0.959 ## # ... with 90 more rows\r paths \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:4)\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r map2(dfs, paths, ~write_csv(x = .x, file = .y))\r ## [[1]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.423 0.647 0.340 ## 2 0.168 -0.654 0.134 ## 3 0.317 -1.52 0.479 ## 4 -0.0876 0.229 -0.579 ## 5 1.08 1.01 -1.05 ## 6 0.0523 0.726 -0.790 ## 7 0.967 -1.01 -0.814 ## 8 0.772 0.262 1.28 ## 9 -1.07 -0.549 -0.759 ## 10 1.19 0.768 -0.0372\r## # ... with 90 more rows\r## ## [[2]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.426 0.427 -0.428 ## 2 -0.532 0.0595 -1.46 ## 3 0.211 -0.125 1.14 ## 4 0.853 -0.376 -0.0773 ## 5 1.45 1.32 -0.248 ## 6 -1.11 0.785 -0.0661 ## 7 -1.03 -0.237 -0.00866\r## 8 0.950 0.449 1.25 ## 9 -0.467 -0.0485 0.168 ## 10 0.886 -0.338 -0.376 ## # ... with 90 more rows\r## ## [[3]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1.69 -0.524 -0.0254 ## 2 -2.34 2.02 0.459 ## 3 -1.01 -0.0508 0.678 ## 4 0.117 -0.427 -0.240 ## 5 -2.26 -0.598 -0.863 ## 6 0.801 0.397 -0.923 ## 7 -0.484 0.501 0.00797\r## 8 1.07 1.49 0.587 ## 9 0.102 -1.25 0.393 ## 10 -1.09 -0.789 1.65 ## # ... with 90 more rows\r## ## [[4]]\r## # A tibble: 100 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.563 -0.756 1.34 ## 2 0.150 0.664 0.373 ## 3 -0.762 1.28 -1.12 ## 4 0.888 0.920 -0.0385\r## 5 -0.786 1.66 -0.914 ## 6 1.27 -0.454 0.721 ## 7 1.39 -0.567 0.289 ## 8 -1.49 0.489 0.545 ## 9 -0.173 0.780 -1.17 ## 10 0.335 -0.947 -0.959 ## # ... with 90 more rows\r E se eu quiser ler um banco de dados que está em vários arquivos diferentes? Vamos usar os que acabamos de criar\n# Bum! Uma linha\rpaths %\u0026gt;% map_dfr(read_csv, .id = \u0026quot;arquivo\u0026quot;)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r ## # A tibble: 400 x 4\r## arquivo x y z\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 -0.423 0.647 0.340 ## 2 1 0.168 -0.654 0.134 ## 3 1 0.317 -1.52 0.479 ## 4 1 -0.0876 0.229 -0.579 ## 5 1 1.08 1.01 -1.05 ## 6 1 0.0523 0.726 -0.790 ## 7 1 0.967 -1.01 -0.814 ## 8 1 0.772 0.262 1.28 ## 9 1 -1.07 -0.549 -0.759 ## 10 1 1.19 0.768 -0.0372\r## # ... with 390 more rows\r As possibilidades são inúmeras. A regra é a seguinte: viu uma tarefa que precisa ser repetida muitas vezes? Pense com carinho em usar uma função vetorizada através de map_.\nPredicados O objetivo de um função predicado é selecionar elementos de uma lista com base em uma função. Em geral, são funções simples que retornam um valor TRUE ou FALSE com base em alguma característica do objeto, como o tipo.\nl \u0026lt;- list(c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c(1, 2, 3))\rl %\u0026gt;% str()\r ## List of 2\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.numeric) %\u0026gt;% str()\r ## List of 1\r## $ : num [1:3] 1 2 3\r l %\u0026gt;% keep(is.character) %\u0026gt;% str()\r ## List of 1\r## $ : chr [1:3] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;\r O uso mais frequente que vejo de keep e discard é como uma espécie de atalho para select. Como data.frames são secretamente listas, você pode rapidamente selecionar todas as variáveis do banco que tenham o mesmo tipo.\nflights %\u0026gt;% keep(is.numeric)\r ## # A tibble: 336,776 x 14\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 6 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;\r flights %\u0026gt;% discard(is.character)\r ## # A tibble: 336,776 x 15\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 7 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;,\r## # time_hour \u0026lt;dttm\u0026gt;\r Como outros aspectos do purrr, a grande vantagem aqui é a generalidade. Essas funções funcionam em qualquer lista de objetos e não apenas em data.frames.\nLidando com a presença de erros A próxima dica forte é utilizar os advérbios (chique) safely() e companhia para lidar com erros.\nx \u0026lt;- list(a = c(1,2,3), b = c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), c = c(99, 88, 77))\rx %\u0026gt;% map(sum)\r ## Error in .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm): 'type' inválido (character) do argumento\r Não conseguimos nada! A mensagem de erro nem nos informa onde o problema ocorreu. E agora?\nx %\u0026gt;% map(safely(sum)) %\u0026gt;% str()\r ## List of 3\r## $ a:List of 2\r## ..$ result: num 6\r## ..$ error : NULL\r## $ b:List of 2\r## ..$ result: NULL\r## ..$ error :List of 2\r## .. ..$ message: chr \u0026quot;'type' inválido (character) do argumento\u0026quot;\r## .. ..$ call : language .Primitive(\u0026quot;sum\u0026quot;)(..., na.rm = na.rm)\r## .. ..- attr(*, \u0026quot;class\u0026quot;)= chr [1:3] \u0026quot;simpleError\u0026quot; \u0026quot;error\u0026quot; \u0026quot;condition\u0026quot;\r## $ c:List of 2\r## ..$ result: num 264\r## ..$ error : NULL\r x %\u0026gt;% map(possibly(sum, otherwise = NA_real_)) %\u0026gt;% str()\r ## List of 3\r## $ a: num 6\r## $ b: num NA\r## $ c: num 264\r Essas funções permitem alterar a saída de uma função quando ocorrer um erro. quietly é parecido, mas ela captura mais a saída do R, o texto em si.\nx \u0026lt;- list(1, -1)\rx %\u0026gt;% map(quietly(log)) %\u0026gt;% str()\r ## List of 2\r## $ :List of 4\r## ..$ result : num 0\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr(0) ## ..$ messages: chr(0) ## $ :List of 4\r## ..$ result : num NaN\r## ..$ output : chr \u0026quot;\u0026quot;\r## ..$ warnings: chr \u0026quot;NaNs produzidos\u0026quot;\r## ..$ messages: chr(0)\r Chamando listas de funções Vamos supor que você tem um vetor de números e você quer aplicar um monte de funções diferentes nele, mas você não quer ter que ficar copiando e colando tudo.\nnumeros \u0026lt;- rnorm(25, 50, 10)\rnumeros\r ## [1] 40.28363 47.05338 55.52213 67.17898 63.43975 31.32029 26.02457 44.61720\r## [9] 65.55023 49.84583 51.14611 55.58084 49.75603 46.89402 59.27724 55.44557\r## [17] 54.67422 60.47497 44.36346 40.90925 53.91280 53.97654 74.11447 60.40166\r## [25] 52.34901\r Nessas situações, você gostaria de chamar várias funções no mesmo objeto ou grupo de objetos, mas você não sabe bem como fazer isso\u0026hellip; Então, invoke_map vem ao resgate.\nfuncs \u0026lt;- list(\u0026quot;mean\u0026quot;, \u0026quot;sd\u0026quot;, \u0026quot;IQR\u0026quot;, \u0026quot;sum\u0026quot;, \u0026quot;length\u0026quot;, \u0026quot;range\u0026quot;, \u0026quot;min\u0026quot;, \u0026quot;max\u0026quot;)\rargs \u0026lt;- list(list(na.rm = T, trim = 0.05),\rlist(na.rm=T), list(type = 2),\rlist(na.rm = T), list(),\rlist(na.rm = T), list(na.rm = T), list(na.rm = T))\rfuncs %\u0026gt;% str()\r ## List of 8\r## $ : chr \u0026quot;mean\u0026quot;\r## $ : chr \u0026quot;sd\u0026quot;\r## $ : chr \u0026quot;IQR\u0026quot;\r## $ : chr \u0026quot;sum\u0026quot;\r## $ : chr \u0026quot;length\u0026quot;\r## $ : chr \u0026quot;range\u0026quot;\r## $ : chr \u0026quot;min\u0026quot;\r## $ : chr \u0026quot;max\u0026quot;\r args %\u0026gt;% str()\r ## List of 8\r## $ :List of 2\r## ..$ na.rm: logi TRUE\r## ..$ trim : num 0.05\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ type: num 2\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ : list()\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r## $ :List of 1\r## ..$ na.rm: logi TRUE\r invoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ : num 52.3\r## $ : num 10.8\r## $ : num 12.4\r## $ : num 1304\r## $ : int 25\r## $ : num [1:2] 26 74.1\r## $ : num 26\r## $ : num 74.1\r Fica mais bonito se você nomear os argumentos, ai o output fica melhorzinho.\nnames(funcs) \u0026lt;- unlist(funcs)\rinvoke_map(funcs, args, x = numeros) %\u0026gt;% glimpse()\r ## List of 8\r## $ mean : num 52.3\r## $ sd : num 10.8\r## $ IQR : num 12.4\r## $ sum : num 1304\r## $ length: int 25\r## $ range : num [1:2] 26 74.1\r## $ min : num 26\r## $ max : num 74.1\r Claro que esse exemplo aqui talvez não seja útil para vocês, mas espero que quando vocês encontrarem uma situação em que você gostaria de aplicar uma bateria de funções no mesmo objeto ou grupo de objetos, vocês se lembrem dessa possibilidade.\nreduce e accumulate Essas duas funções são desenhadas para fazer aplicações recursivas de funções que recebem dois argumentos (operadores matemáticos, _joins, etc. Recursividade em linhas gerais, é você repetir uma operação com o resultado da repetição anterior. Pense em somas ou produtos acumulados, em que o próximo valor é determinado pela aplicação de uma regra sobre o anterior.\naccumulate(1:10, `+`)\r ## [1] 1 3 6 10 15 21 28 36 45 55\r accumulate(1:10, `*`)\r ## [1] 1 2 6 24 120 720 5040 40320 362880\r## [10] 3628800\r A principal diferença entre accumulate e reduce é que a primeira guarda os resultados intermediários, enquanto a segunda retorna apenas o último.\nreduce(1:10, `+`)\r ## [1] 55\r reduce(1:10, `*`)\r ## [1] 3628800\r Uma aplicação bastante prática dessas funções é a produção de um único banco de dados a partir de vários arquivos separados.\n# Lembra dos nossos arquivos lá em cima?\rpaths\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot;\r Vamos fingir que não temos acesso a map_dfr e precisamos importar esses objetos e todos compõem um único banco. Imaginaem que tratam-se de dados por ano.\ndfs \u0026lt;- map(paths, read_csv)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r## ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_double(),\r## z = col_double()\r## )\r glimpse(dfs)\r ## List of 4\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.4228 0.1677 0.3166 -0.0876 1.0804 ...\r## ..$ y: num [1:100] 0.647 -0.654 -1.521 0.229 1.014 ...\r## ..$ z: num [1:100] 0.34 0.134 0.479 -0.579 -1.048 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] -0.426 -0.532 0.211 0.853 1.452 ...\r## ..$ y: num [1:100] 0.4268 0.0595 -0.1254 -0.3762 1.3227 ...\r## ..$ z: num [1:100] -0.4284 -1.4608 1.1365 -0.0773 -0.2477 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] 1.689 -2.343 -1.015 0.117 -2.26 ...\r## ..$ y: num [1:100] -0.524 2.0172 -0.0508 -0.4266 -0.598 ...\r## ..$ z: num [1:100] -0.0254 0.4592 0.6776 -0.2399 -0.8627 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r## $ : spec_tbl_df [100 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\r## ..$ x: num [1:100] 0.563 0.15 -0.762 0.888 -0.786 ...\r## ..$ y: num [1:100] -0.756 0.664 1.281 0.92 1.659 ...\r## ..$ z: num [1:100] 1.3386 0.3727 -1.1177 -0.0385 -0.9144 ...\r## ..- attr(*, \u0026quot;spec\u0026quot;)=\r## .. .. cols(\r## .. .. x = col_double(),\r## .. .. y = col_double(),\r## .. .. z = col_double()\r## .. .. )\r new_df \u0026lt;- reduce(dfs, bind_rows)\rnew_df\r ## # A tibble: 400 x 3\r## x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.423 0.647 0.340 ## 2 0.168 -0.654 0.134 ## 3 0.317 -1.52 0.479 ## 4 -0.0876 0.229 -0.579 ## 5 1.08 1.01 -1.05 ## 6 0.0523 0.726 -0.790 ## 7 0.967 -1.01 -0.814 ## 8 0.772 0.262 1.28 ## 9 -1.07 -0.549 -0.759 ## 10 1.19 0.768 -0.0372\r## # ... with 390 more rows\r O resultado é o mesmo observado em map_dfr, mas essa abordagem é genérica, ou seja, ela se aplica para qualquer grupo de objetos e para qualquer função que recebe dois argumentos e precisa ser repetida de maneira recursiva.\n# Apaga os arquivos pra eles não ficarem ai gastando memória a toa\rfile.remove(paths)\r ## [1] TRUE TRUE TRUE TRUE\r pluck Esta função é um atalho para as tesouras duplas do r [[. Seu objeto é facilitar a leitura de códigos que pescam elementos profundos de uma lista aninhada.\nl \u0026lt;- list(\rlist(-1, x = 1, y = c(2), z = \u0026quot;a\u0026quot;),\rlist(-2, x = 4, y = c(5, 6), z = \u0026quot;b\u0026quot;),\rlist(-3, x = 8, y = c(9, 10, 11))\r)\rglimpse(l)\r ## List of 3\r## $ :List of 4\r## ..$ : num -1\r## ..$ x: num 1\r## ..$ y: num 2\r## ..$ z: chr \u0026quot;a\u0026quot;\r## $ :List of 4\r## ..$ : num -2\r## ..$ x: num 4\r## ..$ y: num [1:2] 5 6\r## ..$ z: chr \u0026quot;b\u0026quot;\r## $ :List of 3\r## ..$ : num -3\r## ..$ x: num 8\r## ..$ y: num [1:3] 9 10 11\r Se você chamar map_ nessa lista, você pode extrair os elementos delas pelo nome.\nmap_dbl(l, \u0026quot;x\u0026quot;)\r ## [1] 1 4 8\r map(l, \u0026quot;y\u0026quot;)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r map(l, \u0026quot;z\u0026quot;)\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r Ou pela posição na lista\nmap_dbl(l, 1)\r ## [1] -1 -2 -3\r map_dbl(l, 2)\r ## [1] 1 4 8\r map(l, 3)\r ## [[1]]\r## [1] 2\r## ## [[2]]\r## [1] 5 6\r## ## [[3]]\r## [1] 9 10 11\r Ou os dois\nmap_dbl(l, list(\u0026quot;x\u0026quot;, 1))\r ## [1] 1 4 8\r map(l, list(\u0026quot;z\u0026quot;, 1))\r ## [[1]]\r## [1] \u0026quot;a\u0026quot;\r## ## [[2]]\r## [1] \u0026quot;b\u0026quot;\r## ## [[3]]\r## NULL\r map(l, list(\u0026quot;y\u0026quot;, 3))\r ## [[1]]\r## NULL\r## ## [[2]]\r## NULL\r## ## [[3]]\r## [1] 11\r Se um componente não existir, você recebe um erro\nmap_chr(l, \u0026quot;z\u0026quot;)\r ## Error: Result 3 must be a single string, not NULL of length 0\r Mas você pode resolver isso passando um valor padrão\nmap_chr(l, \u0026quot;z\u0026quot;, .default = NA_character_)\r ## [1] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; NA\r Tudo isso funciona com base na função pluck\npluck(l, 1)\r ## [[1]]\r## [1] -1\r## ## $x\r## [1] 1\r## ## $y\r## [1] 2\r## ## $z\r## [1] \u0026quot;a\u0026quot;\r pluck(l, 1, 2)\r ## [1] 1\r pluck(l, 2, 3)\r ## [1] 5 6\r pluck(l, 1, \u0026quot;x\u0026quot;)\r ## [1] 1\r pluck(l, 2, \u0026quot;z\u0026quot;)\r ## [1] \u0026quot;b\u0026quot;\r pluck(l, 3, \u0026quot;y\u0026quot;)\r ## [1] 9 10 11\r Exercícios   Utilize uma das funções map_ para:\n  Calcular a média de cada coluna em mtcars.\n  Determinar o tipo de cada coluna em flights.\n  Computar o número de valores únicos em cada coluna de iris.\n  Gere 10 distribuições aleatórias (rnorm) com médias -10, 0, 10 e 100.\n  Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?\n  Usando as funções predicado keep e discard:\n  Selecione todas as colunas caractere no banco flights.\n  Descarte os caracteres em mpg.\n  Selecione os fatores ordenados em diamonds.\n  Descarte as variáveis não-numéricas em iris\n  Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.\n  Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.\n  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r ","date":1621728000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621728000,"objectID":"8fc2c9a43ba39b58554f36d137f8df4b","permalink":"https://laddem.github.io/courses/tidyverse/dia4/","publishdate":"2021-05-23T00:00:00Z","relpermalink":"/courses/tidyverse/dia4/","section":"courses","summary":"O autor dos pacotes do tidyverse core é completamente fascinado por gatos, por isso, tantas referências ao bixo nos nomes dos pacotes. \u0026ldquo;Purr\u0026rdquo; (em inglês) é o som que os gatos fazem quando sentem prazer.","tags":null,"title":"purrr","type":"book"},{"authors":null,"categories":null,"content":"Soluções dos exercícios.\nreadr, tibble, tidyr # Não esqueça dos pacotes!\rlibrary(tidyverse)\r ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --\r ## v ggplot2 3.3.3 v purrr 0.3.4\r## v tibble 3.1.2 v dplyr 1.0.6\r## v tidyr 1.1.3 v stringr 1.4.0\r## v readr 1.4.0 v forcats 0.5.1\r ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --\r## x dplyr::filter() masks stats::filter()\r## x dplyr::lag() masks stats::lag()\r  Como você importaria o banco \u0026ldquo;epa78.csv\u0026rdquo;  file \u0026lt;- readr_example(\u0026quot;epa78.txt\u0026quot;)\r Primeiro, é bom verificar como estão dispostas as informações no arquivo texto\nread_lines(file, n_max = 10)\r ## [1] \u0026quot;ALFA ROMEO ALFA ROMEO 78010003\u0026quot;\r## [2] \u0026quot;ALFETTA 03 81 8 74 7 89 9 ALFETTA 78010053\u0026quot;\r## [3] \u0026quot;SPIDER 2000 01 SPIDER 2000 78010103\u0026quot;\r## [4] \u0026quot;AMC AMC 78020002\u0026quot;\r## [5] \u0026quot;GREMLIN 03 79 9 79 9 GREMLIN 78020053\u0026quot;\r## [6] \u0026quot;PACER 04 89 11 89 11 PACER 78020103\u0026quot;\r## [7] \u0026quot;PACER WAGON 07 90 26 91 26 PACER WAGON 78020153\u0026quot;\r## [8] \u0026quot;CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 78020203\u0026quot;\r## [9] \u0026quot;CONCORD WAGON 07 91 30 91 30 CONCORD WAGON 78020253\u0026quot;\r## [10] \u0026quot;MATADOR COUPE 05 97 14 97 14 MATADOR COUPE 78020303\u0026quot;\r Ao identificar que se trata de um arquivo colunado, mas que as colunas são separadas por espaços, escolho o read_fwf com o fwf_empty.\ndic \u0026lt;- fwf_empty(file)\rdf \u0026lt;- read_fwf(file, col_positions = dic)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## X1 = col_character(),\r## X2 = col_character(),\r## X3 = col_double(),\r## X4 = col_double(),\r## X5 = col_double(),\r## X6 = col_double(),\r## X7 = col_double(),\r## X8 = col_double(),\r## X9 = col_double(),\r## X10 = col_double(),\r## X11 = col_character(),\r## X12 = col_double()\r## )\r df\r ## # A tibble: 20 x 12\r## X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 ALFA RO~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ALFA R~ 7.80e7\r## 2 ALFETTA 03 81 8 74 7 89 9 NA NA ALFETTA 7.80e7\r## 3 SPIDER ~ 01 NA NA NA NA NA NA NA NA SPIDER~ 7.80e7\r## 4 AMC \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AMC 7.80e7\r## 5 GREMLIN 03 79 9 NA NA NA NA 79 9 GREMLIN 7.80e7\r## 6 PACER 04 89 11 NA NA NA NA 89 11 PACER 7.80e7\r## 7 PACER W~ 07 90 26 91 26 NA NA NA NA PACER ~ 7.80e7\r## 8 CONCORD 04 88 12 90 11 90 11 83 16 CONCORD 7.80e7\r## 9 CONCORD~ 07 91 30 NA NA 91 30 NA NA CONCOR~ 7.80e7\r## 10 MATADOR~ 05 97 14 97 14 NA NA NA NA MATADO~ 7.80e7\r## 11 MATADOR~ 06 110 20 NA NA 110 20 NA NA MATADO~ 7.80e7\r## 12 MATADOR~ 09 112 50 NA NA 112 50 NA NA MATADO~ 7.80e7\r## 13 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 14 ASTON M~ \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA ASTON ~ 7.80e7\r## 15 AUDI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AUDI 7.81e7\r## 16 FOX 03 84 11 84 11 84 11 NA NA FOX 7.81e7\r## 17 FOX WAG~ 07 83 40 NA NA 83 40 NA NA FOX WA~ 7.81e7\r## 18 5000 04 90 15 NA NA 90 15 NA NA 5000 7.81e7\r## 19 AVANTI \u0026lt;NA\u0026gt; NA NA NA NA NA NA NA NA AVANTI 7.81e7\r## 20 AVANTI ~ 02 75 8 75 8 NA NA NA NA AVANTI~ 7.81e7\r Importe o banco \u0026ldquo;challenge.csv\u0026rdquo; e resolva os problemas com o tipo da coluna.  Ao verificar as primeiras 10 linhas do banco, podemos notar algo estranho\nfile \u0026lt;- readr_example(\u0026quot;challenge.csv\u0026quot;)\rread_lines(file, n_max = 10)\r ## [1] \u0026quot;x,y\u0026quot; \u0026quot;404,NA\u0026quot; \u0026quot;4172,NA\u0026quot; \u0026quot;3004,NA\u0026quot; \u0026quot;787,NA\u0026quot; \u0026quot;37,NA\u0026quot; \u0026quot;2332,NA\u0026quot;\r## [8] \u0026quot;2489,NA\u0026quot; \u0026quot;1449,NA\u0026quot; \u0026quot;3665,NA\u0026quot;\r Parece ser um arquivo csv comum, com duas colunas, mas uma delas parece ter apenas NAs. Se a gente proceder com a importação padrão, chegaremos em\ndf \u0026lt;- read_csv(file)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_logical()\r## )\r ## Warning: 1000 parsing failures.\r## row col expected actual file\r## 1001 y 1/0/T/F/TRUE/FALSE 2015-01-16 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1002 y 1/0/T/F/TRUE/FALSE 2018-05-18 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1003 y 1/0/T/F/TRUE/FALSE 2015-09-05 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1004 y 1/0/T/F/TRUE/FALSE 2012-11-28 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## 1005 y 1/0/T/F/TRUE/FALSE 2020-01-13 'C:/Users/vinic/Documents/R/win-library/4.1/readr/extdata/challenge.csv'\r## .... ... .................. .......... ........................................................................\r## See problems(...) for more details.\r df\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;lgl\u0026gt;\r## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r No console de vocês, deve aparecer que foram importadas as colunas x como double e y como logical. Mas uma chuva de \u0026ldquo;parsing failures\u0026rdquo;, indicando que expected = 1/0/T/F/TRUE/FALSE, actual = 2015-01-16.\nNa verdade, ao tentar adivinhar o tipo de colunas, o readr lê as primeiras 1000 observações em busca de um padrão. Você pode resolver esse problema:\n# 1. Aumentando o número de observações utilizadas para adivinhar as colunas\rdf \u0026lt;- read_csv(file, guess_max = 1001)\r ## ## -- Column specification --------------------------------------------------------\r## cols(\r## x = col_double(),\r## y = col_date(format = \u0026quot;\u0026quot;)\r## )\r # A específicação da coluna Y agora é \u0026lt;date\u0026gt;\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r # 2. escolhendo diretamente o tipo de coluna antes da importação\rtipos \u0026lt;- cols(\ry = col_date()\r)\rdf \u0026lt;- read_csv(file, col_types = tipos)\r# Mesmo resultado\rdf\r ## # A tibble: 2,000 x 2\r## x y ## \u0026lt;dbl\u0026gt; \u0026lt;date\u0026gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # ... with 1,990 more rows\r Com o banco sala_aula dado a seguir, transforme-o para que ele contenha as variáveis nome, avaliação e nota.  sala_aula \u0026lt;- tribble(\r~name, ~teste1, ~teste2, ~prova1,\r\u0026quot;Billy\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;D\u0026quot; , \u0026quot;C\u0026quot;,\r\u0026quot;Suzy\u0026quot;, \u0026quot;F\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;, \u0026quot;\u0026lt;NA\u0026gt;\u0026quot;,\r\u0026quot;Lionel\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot; , \u0026quot;B\u0026quot;,\r\u0026quot;Jenny\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;A\u0026quot; , \u0026quot;B\u0026quot;\r)\r É sempre bom começar planejando o banco que queremos construir. Queremos um banco que tenha 3 variáveis: o nome, o tipo de prova aplicada e a nota de cada aluno. Para isso, precisamos colocar os nomes das colunas teste1, teste2 e prova1 numa variável e os valores das células em outra. Vamos chamar essas colunas de \u0026ldquo;avaliação\u0026rdquo; e \u0026ldquo;nota\u0026rdquo;, elas formam um par.\nAgora vamos chamar pivot_wider e especificar esses argumentos.\nsala_aula %\u0026gt;% pivot_longer(\r# Primeiro, identificamos as colunas que serão modificadas\rcols = c(teste1, teste2, prova1),\r# Agora, indicamos os nomes das colunas que receberão\r# os nomes das colunas transformadas\rnames_to = \u0026quot;avaliacao\u0026quot;,\r# os valores das células\rvalues_to = \u0026quot;nota\u0026quot;\r)\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r Transforme o banco relig_income para que ele contenha as colunas religião, renda e frequência.  relig_income\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r O banco relig_income parece ter uma organização em que temos 2 variáveis, mas uma delas está numa coluna \u0026ldquo;religion\u0026rdquo; e a outra está em 10 colunas, \u0026ldquo;income\u0026rdquo;. Queremos um banco que tenha 3 colunas: a religião, o nível de renda, e o número de pessoas em cada combinação das duas primeiras.\nComo no exerício anterior, vamos chamar pivot_longer e especificar\nrelig_income %\u0026gt;% pivot_longer(\r# As colunas a serem modificadas, notem o uso de ':' para selecionar várias\r# colunas em sequência\rcols = `\u0026lt;$10k`:`Don't know/refused`,\r# Variável recebe os nomes da antiga coluna\rnames_to = \u0026quot;nivel_renda\u0026quot;,\r# Variável recebe os valores das células\rvalues_to = \u0026quot;contagem\u0026quot;\r)\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r Transforme o banco billboard para que ele contenha apenas uma coluna \u0026ldquo;semana\u0026rdquo; e uma coluna com a posição da música no ranking.   Dica, você pode selecionar várias colunas usando o atalho wk1:wk76\n billboard\r ## # A tibble: 317 x 79\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 68 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;, wk66 \u0026lt;lgl\u0026gt;, wk67 \u0026lt;lgl\u0026gt;, wk68 \u0026lt;lgl\u0026gt;, wk69 \u0026lt;lgl\u0026gt;, wk70 \u0026lt;lgl\u0026gt;,\r## # wk71 \u0026lt;lgl\u0026gt;, wk72 \u0026lt;lgl\u0026gt;, wk73 \u0026lt;lgl\u0026gt;, wk74 \u0026lt;lgl\u0026gt;, wk75 \u0026lt;lgl\u0026gt;, wk76 \u0026lt;lgl\u0026gt;\r Da mesma forma como fizemos nos anteriores, queremos transformar as várias wk1:wk76 em um par de colunas, uma que me diga a semana e a outra que me diga em que posição no ranking a música estava.\nbillboard %\u0026gt;% pivot_longer(\r# Colunas que serão transformadas\rcols = wk1:wk76,\r# Nome da variável que receberá os nomes das colunas\rnames_to = \u0026quot;semana\u0026quot;,\r# Nome da variável que receberá os valores das células\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\r# Nesse caso, uso o argumento opcional para eliminar os NAs\rvalues_drop_na = TRUE\r# Experimente mudar este argumento para FALSE e veja o resultado\r# Quando uma música não está mais nas paradas, ela recebe NA. Acho\r# justificado excluir os NAs nesse caso.\r)\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r Experimente fazer o caminho inverso dos exercícios 3 a 5, devolvendo os datasets ao seu formato original. O que você observou?  Vou começar enxugando os códigos anteriores para criar os resultados que produzimos e salvá-los em objetos.\nsala_aula_long \u0026lt;- sala_aula %\u0026gt;% pivot_longer(\rcols = c(teste1, teste2, prova1),\rnames_to = \u0026quot;avaliacao\u0026quot;,\rvalues_to = \u0026quot;nota\u0026quot;\r)\rrelig_income_long \u0026lt;- relig_income %\u0026gt;% pivot_longer(\rcols = `\u0026lt;$10k`:`Don't know/refused`,\rnames_to = \u0026quot;nivel_renda\u0026quot;,\rvalues_to = \u0026quot;contagem\u0026quot;\r)\rbillboard_long \u0026lt;- billboard %\u0026gt;% pivot_longer(\rcols = wk1:wk76,\rnames_to = \u0026quot;semana\u0026quot;,\rvalues_to = \u0026quot;posicao_rank\u0026quot;,\rvalues_drop_na = TRUE\r)\rsala_aula_long\r ## # A tibble: 12 x 3\r## name avaliacao nota ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 Billy teste1 \u0026lt;NA\u0026gt; ## 2 Billy teste2 D ## 3 Billy prova1 C ## 4 Suzy teste1 F ## 5 Suzy teste2 \u0026lt;NA\u0026gt; ## 6 Suzy prova1 \u0026lt;NA\u0026gt; ## 7 Lionel teste1 B ## 8 Lionel teste2 C ## 9 Lionel prova1 B ## 10 Jenny teste1 A ## 11 Jenny teste2 A ## 12 Jenny prova1 B\r relig_income_long\r ## # A tibble: 180 x 3\r## religion nivel_renda contagem\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic \u0026lt;$10k 27\r## 2 Agnostic $10-20k 34\r## 3 Agnostic $20-30k 60\r## 4 Agnostic $30-40k 81\r## 5 Agnostic $40-50k 76\r## 6 Agnostic $50-75k 137\r## 7 Agnostic $75-100k 122\r## 8 Agnostic $100-150k 109\r## 9 Agnostic \u0026gt;150k 84\r## 10 Agnostic Don't know/refused 96\r## # ... with 170 more rows\r billboard_long\r ## # A tibble: 5,307 x 5\r## artist track date.entered semana posicao_rank\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk1 87\r## 2 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk2 82\r## 3 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk3 72\r## 4 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk4 77\r## 5 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk5 87\r## 6 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk6 94\r## 7 2 Pac Baby Don't Cry (Keep... 2000-02-26 wk7 99\r## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91\r## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87\r## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92\r## # ... with 5,297 more rows\r O caminho inverso desses bancos de dados, é utilizar pivot_wider. Aqui, vamos escolher um par de colunas que contém:\n O nome das colunas que queremos criar O valor que queremos passar para as células dessas novas colunas  Vamos ver exemplos comentados como no anterior\nsala_aula_long %\u0026gt;% pivot_wider(\r# Aqui, identificamos colunas que NÃO SERÃO MODIFICADAS\r# É o contrário de pivot_longer. Por padrão, são todas as que não são\r# mencionadas na transformação, mas para deixar bem claro, # vou deixar explícito.\rid_cols = name,\r# Variável com os nomes para as novas colunas\rnames_from = avaliacao,\r# Variável com os valores para as células\rvalues_from = nota\r)\r ## # A tibble: 4 x 4\r## name teste1 teste2 prova1\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Billy \u0026lt;NA\u0026gt; D C ## 2 Suzy F \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; ## 3 Lionel B C B ## 4 Jenny A A B\r relig_income_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = religion,\r# Variável com os nomes para as novas colunas\rnames_from = nivel_renda,\r# Variável com os valores para as células\rvalues_from = contagem\r)\r ## # A tibble: 18 x 11\r## religion `\u0026lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Agnostic 27 34 60 81 76 137 122\r## 2 Atheist 12 27 37 52 35 70 73\r## 3 Buddhist 27 21 30 34 33 58 62\r## 4 Catholic 418 617 732 670 638 1116 949\r## 5 Don’t k~ 15 14 15 11 10 35 21\r## 6 Evangel~ 575 869 1064 982 881 1486 949\r## 7 Hindu 1 9 7 9 11 34 47\r## 8 Histori~ 228 244 236 238 197 223 131\r## 9 Jehovah~ 20 27 24 24 21 30 15\r## 10 Jewish 19 19 25 25 30 95 69\r## 11 Mainlin~ 289 495 619 655 651 1107 939\r## 12 Mormon 29 40 48 51 56 112 85\r## 13 Muslim 6 7 9 10 9 23 16\r## 14 Orthodox 13 17 23 32 32 47 38\r## 15 Other C~ 9 7 11 13 13 14 18\r## 16 Other F~ 20 33 40 46 49 63 46\r## 17 Other W~ 5 2 3 4 2 7 3\r## 18 Unaffil~ 217 299 374 365 341 528 407\r## # ... with 3 more variables: $100-150k \u0026lt;dbl\u0026gt;, \u0026gt;150k \u0026lt;dbl\u0026gt;,\r## # Don't know/refused \u0026lt;dbl\u0026gt;\r billboard_long %\u0026gt;% pivot_wider(\r# Colunas não modificadas\rid_cols = c(artist, track, date.entered),\r# Variável com os nomes para as novas colunas\rnames_from = semana,\r# Variável com os valores para as células\rvalues_from = posicao_rank\r)\r ## # A tibble: 317 x 68\r## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2 Pac Baby D~ 2000-02-26 87 82 72 77 87 94 99 NA\r## 2 2Ge+her The Ha~ 2000-09-02 91 87 92 NA NA NA NA NA\r## 3 3 Doors~ Krypto~ 2000-04-08 81 70 68 67 66 57 54 53\r## 4 3 Doors~ Loser 2000-10-21 76 76 72 69 67 65 55 59\r## 5 504 Boyz Wobble~ 2000-04-15 57 34 25 17 17 31 36 49\r## 6 98^0 Give M~ 2000-08-19 51 39 34 26 26 19 2 2\r## 7 A*Teens Dancin~ 2000-07-08 97 97 96 95 100 NA NA NA\r## 8 Aaliyah I Don'~ 2000-01-29 84 62 51 41 38 35 35 38\r## 9 Aaliyah Try Ag~ 2000-03-18 59 53 38 28 21 18 16 14\r## 10 Adams, ~ Open M~ 2000-08-26 76 76 74 69 68 67 61 58\r## # ... with 307 more rows, and 57 more variables: wk9 \u0026lt;dbl\u0026gt;, wk10 \u0026lt;dbl\u0026gt;,\r## # wk11 \u0026lt;dbl\u0026gt;, wk12 \u0026lt;dbl\u0026gt;, wk13 \u0026lt;dbl\u0026gt;, wk14 \u0026lt;dbl\u0026gt;, wk15 \u0026lt;dbl\u0026gt;, wk16 \u0026lt;dbl\u0026gt;,\r## # wk17 \u0026lt;dbl\u0026gt;, wk18 \u0026lt;dbl\u0026gt;, wk19 \u0026lt;dbl\u0026gt;, wk20 \u0026lt;dbl\u0026gt;, wk21 \u0026lt;dbl\u0026gt;, wk22 \u0026lt;dbl\u0026gt;,\r## # wk23 \u0026lt;dbl\u0026gt;, wk24 \u0026lt;dbl\u0026gt;, wk25 \u0026lt;dbl\u0026gt;, wk26 \u0026lt;dbl\u0026gt;, wk27 \u0026lt;dbl\u0026gt;, wk28 \u0026lt;dbl\u0026gt;,\r## # wk29 \u0026lt;dbl\u0026gt;, wk30 \u0026lt;dbl\u0026gt;, wk31 \u0026lt;dbl\u0026gt;, wk32 \u0026lt;dbl\u0026gt;, wk33 \u0026lt;dbl\u0026gt;, wk34 \u0026lt;dbl\u0026gt;,\r## # wk35 \u0026lt;dbl\u0026gt;, wk36 \u0026lt;dbl\u0026gt;, wk37 \u0026lt;dbl\u0026gt;, wk38 \u0026lt;dbl\u0026gt;, wk39 \u0026lt;dbl\u0026gt;, wk40 \u0026lt;dbl\u0026gt;,\r## # wk41 \u0026lt;dbl\u0026gt;, wk42 \u0026lt;dbl\u0026gt;, wk43 \u0026lt;dbl\u0026gt;, wk44 \u0026lt;dbl\u0026gt;, wk45 \u0026lt;dbl\u0026gt;, wk46 \u0026lt;dbl\u0026gt;,\r## # wk47 \u0026lt;dbl\u0026gt;, wk48 \u0026lt;dbl\u0026gt;, wk49 \u0026lt;dbl\u0026gt;, wk50 \u0026lt;dbl\u0026gt;, wk51 \u0026lt;dbl\u0026gt;, wk52 \u0026lt;dbl\u0026gt;,\r## # wk53 \u0026lt;dbl\u0026gt;, wk54 \u0026lt;dbl\u0026gt;, wk55 \u0026lt;dbl\u0026gt;, wk56 \u0026lt;dbl\u0026gt;, wk57 \u0026lt;dbl\u0026gt;, wk58 \u0026lt;dbl\u0026gt;,\r## # wk59 \u0026lt;dbl\u0026gt;, wk60 \u0026lt;dbl\u0026gt;, wk61 \u0026lt;dbl\u0026gt;, wk62 \u0026lt;dbl\u0026gt;, wk63 \u0026lt;dbl\u0026gt;, wk64 \u0026lt;dbl\u0026gt;,\r## # wk65 \u0026lt;dbl\u0026gt;\r Tanto pivot_longer quanto pivot_wider tem mais argumentos para lidar com situações complexas, como quando você precisa aplicar transformações em variáveis antes de reformatar o banco ou precisa utilizar múltiplas colunas, mas eu deixo isso para vocês descobrirem por conta própria quando estiverem confortáveis com a sintaxe básica.\nO que os argumentos extra e fill em separate fazem? Utilize o exemplo a seguir como guia.  tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;))\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r Por padrão, separate espera que todas as colunas sendo separadas tenham o mesmo comprimento. Por exemplo, no primeiro caso, indicamos que vamos criar três novas colunas, chamadas de \u0026ldquo;um\u0026rdquo;, \u0026ldquo;dois\u0026rdquo; e \u0026ldquo;tres\u0026rdquo;. Mas os vetores tem tamanhos diferentes. Um deles tem 4 letras ao invés de 3. No segundo exemplo, um deles tem duas letras ao invés de três. Esse tipo de situação é bastante comum quando lidamos com erros de digitação. Então, o que fazer com o elemento que está sobrando ou faltando?\n# Sobrando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;warn\u0026quot;) # avise que ocorreu (padrão)\r ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;drop\u0026quot;) # descarte o que sobrou\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f ## 3 h i j\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e,f,g\u0026quot;, \u0026quot;h,i,j\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), extra = \u0026quot;merge\u0026quot;) # junte com o último\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e f,g ## 3 h i j\r # Note especialmente no último caso o que ocorreu com as colunas.\r# Faltando\rtibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;warn\u0026quot;) # avise e preencha a direita\r ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2].\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;left\u0026quot;) # preencha a esquerda\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 \u0026lt;NA\u0026gt; d e ## 3 f g i\r tibble(x = c(\u0026quot;a,b,c\u0026quot;, \u0026quot;d,e\u0026quot;, \u0026quot;f,g,i\u0026quot;)) %\u0026gt;% separate(x, c(\u0026quot;um\u0026quot;, \u0026quot;dois\u0026quot;, \u0026quot;tres\u0026quot;), fill = \u0026quot;right\u0026quot;) # preencha a direta\r ## # A tibble: 3 x 3\r## um dois tres ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 a b c ## 2 d e \u0026lt;NA\u0026gt; ## 3 f g i\r # Note na sua saída do R como ficou a tibble e onde foram colocados NAs\r# em cada caso\r Tanto unite como separate possuem um argumento remove. Pra que ele serve e quando você o utilizaria no valor FALSE?  Acho que a melhor forma de compreender isso é utilizar um banco de dados. Vamos pegar aquele da população retirado da Wikipédia.\npopulacao \u0026lt;- tribble(\r~Rank, ~Country, ~Population,\t~'% of world', ~Day, ~Month, ~Year, ~Source,\r1L, \u0026quot;China\u0026quot;, 1411778724, \u0026quot;17.9%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;Seventh Census on 2020\u0026quot;,\r2L, \u0026quot;India\u0026quot;, 1377123716, \u0026quot;17.5%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[3]\u0026quot;,\r3L, \u0026quot;United States\u0026quot;, 331695937, \u0026quot;4.22%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[4]\u0026quot;,\r4L, \u0026quot;Indonesia\u0026quot;, 271350000, \u0026quot;3.45%\u0026quot;, \u0026quot;31\u0026quot;, \u0026quot;Dec\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;National annual estimate[5]\u0026quot;,\r5L, \u0026quot;Pakistan\u0026quot;, 225200000, \u0026quot;2.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r6L, \u0026quot;Brazil\u0026quot;, 213154869, \u0026quot;2.71%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[6]\u0026quot;,\r7L, \u0026quot;Nigeria\u0026quot;, 211401000, \u0026quot;2.69%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jul\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;UN projection[2]\u0026quot;,\r8L, \u0026quot;Bangladesh\u0026quot;, 170689832, \u0026quot;2.17%\u0026quot;, \u0026quot;19\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National population clock[7]\u0026quot;,\r9L, \u0026quot;Russia\u0026quot;, 146171015, \u0026quot;1.86%\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;Jan\u0026quot;, \u0026quot;2021\u0026quot;, \u0026quot;National annual estimate[8]\u0026quot;,\r10L, \u0026quot;Mexico\u0026quot;, 126014024, \u0026quot;1.60%\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;2020\u0026quot;, \u0026quot;2020 census result[9]\u0026quot;\r)\rpopulacao\r ## # A tibble: 10 x 8\r## Rank Country Population `% of world` Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 Seventh Census o~\r## 2 2 India 1377123716 17.5% 19 May 2021 National populat~\r## 3 3 United Sta~ 331695937 4.22% 19 May 2021 National populat~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 2020 National annual ~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19 May 2021 National populat~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19 May 2021 National populat~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 National annual ~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 2020 census resu~\r Vamos ver dois exemplos, um com unite e outro com separate para exemplificar o que remove faz.\n# Unir as colunas Day, Month, Year, remove = TRUE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = TRUE) # padrão\r ## # A tibble: 10 x 6\r## Rank Country Population `% of world` Data Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_2020 Seventh Census on 2020 ## 2 2 India 1377123716 17.5% 19_May_20~ National population cl~\r## 3 3 United Stat~ 331695937 4.22% 19_May_20~ National population cl~\r## 4 4 Indonesia 271350000 3.45% 31_Dec_20~ National annual estima~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_2021 UN projection[2] ## 6 6 Brazil 213154869 2.71% 19_May_20~ National population cl~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_2021 UN projection[2] ## 8 8 Bangladesh 170689832 2.17% 19_May_20~ National population cl~\r## 9 9 Russia 146171015 1.86% 1_Jan_2021 National annual estima~\r## 10 10 Mexico 126014024 1.60% 2_Mar_2020 2020 census result[9]\r # Unir as colunas Day, Month, Year, remove = FALSE\rpopulacao %\u0026gt;% unite(Data, Day, Month, Year, remove = FALSE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Data Day Month Year Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1_Nov_~ 1 Nov 2020 Seventh Ce~\r## 2 2 India 1377123716 17.5% 19_May~ 19 May 2021 National p~\r## 3 3 United S~ 331695937 4.22% 19_May~ 19 May 2021 National p~\r## 4 4 Indonesia 271350000 3.45% 31_Dec~ 31 Dec 2020 National a~\r## 5 5 Pakistan 225200000 2.86% 1_Jul_~ 1 Jul 2021 UN project~\r## 6 6 Brazil 213154869 2.71% 19_May~ 19 May 2021 National p~\r## 7 7 Nigeria 211401000 2.69% 1_Jul_~ 1 Jul 2021 UN project~\r## 8 8 Banglade~ 170689832 2.17% 19_May~ 19 May 2021 National p~\r## 9 9 Russia 146171015 1.86% 1_Jan_~ 1 Jan 2021 National a~\r## 10 10 Mexico 126014024 1.60% 2_Mar_~ 2 Mar 2020 2020 censu~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Agora com separate: Separar a coluna year em século e ano, apenas como exemplo\n# remove = TRUE, padrão\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = TRUE)\r ## # A tibble: 10 x 9\r## Rank Country Population `% of world` Day Month seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 20 20 Seventh Cen~\r## 2 2 India 1377123716 17.5% 19 May 20 21 National po~\r## 3 3 United S~ 331695937 4.22% 19 May 20 21 National po~\r## 4 4 Indonesia 271350000 3.45% 31 Dec 20 20 National an~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 20 21 UN projecti~\r## 6 6 Brazil 213154869 2.71% 19 May 20 21 National po~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 20 21 UN projecti~\r## 8 8 Banglade~ 170689832 2.17% 19 May 20 21 National po~\r## 9 9 Russia 146171015 1.86% 1 Jan 20 21 National an~\r## 10 10 Mexico 126014024 1.60% 2 Mar 20 20 2020 census~\r # remove = FALSE\rpopulacao %\u0026gt;% separate(Year, c(\u0026quot;seculo\u0026quot;, \u0026quot;ano\u0026quot;), sep = 2, remove = FALSE)\r ## # A tibble: 10 x 10\r## Rank Country Population `% of world` Day Month Year seculo ano Source ## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 1 China 1411778724 17.9% 1 Nov 2020 20 20 Sevent~\r## 2 2 India 1377123716 17.5% 19 May 2021 20 21 Nation~\r## 3 3 United ~ 331695937 4.22% 19 May 2021 20 21 Nation~\r## 4 4 Indones~ 271350000 3.45% 31 Dec 2020 20 20 Nation~\r## 5 5 Pakistan 225200000 2.86% 1 Jul 2021 20 21 UN pro~\r## 6 6 Brazil 213154869 2.71% 19 May 2021 20 21 Nation~\r## 7 7 Nigeria 211401000 2.69% 1 Jul 2021 20 21 UN pro~\r## 8 8 Banglad~ 170689832 2.17% 19 May 2021 20 21 Nation~\r## 9 9 Russia 146171015 1.86% 1 Jan 2021 20 21 Nation~\r## 10 10 Mexico 126014024 1.60% 2 Mar 2020 20 20 2020 c~\r # Vejam o que aconteceu com as colunas nos dois bancos.\r Eu gosto de utilizar esse argumento quando eu tenho dúvida sobre o resultado e quero fazer inspeção visual para detectar eventuais problemas na separação ou junção. Uma vez que estou satisfeito com o resultado, em geral eu uso o remove=TRUE. Vocês tem que decidir se precisam manter as colunas originais ou se a coluna transformada é o suficiente.\nCompare o argumento values_fill em pivot_wider e fill em complete. Qual é a diferença?  A resposta curta é simples: em pivot_wider, podemos ter aqueles missings \u0026ldquo;implícitos\u0026rdquo; que não apareciam no nosso banco longo e, durante a transformação, eles viram NAs nas colunas. Ó argumento values_fill indica um valor para ser preenchido no lugar de NA.\nEm complete, temos uma situação similar. O que fazer quando for encontrada uma combinação de valores no banco longo que é um \u0026ldquo;missing implícito\u0026rdquo;? Você pode especificar um valor padrão para preenchê-lo.\nSão funções similares, mas uma funciona sem reformatar o banco e a outra durante o processo de reformatação. Veja um exemplo abaixo com aquela tibble das ações.\nacoes \u0026lt;- tibble(\rano = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\rqdr = c( 1, 2, 3, 4, 2, 3, 4),\rlucro = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)\r)\racoes\r ## # A tibble: 7 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 NA ## 5 2016 2 0.92\r## 6 2016 3 0.17\r## 7 2016 4 2.66\r # Vamos supor que o NA implícito significa que a empresa teve # lucro = 0 naquele quadrimestre.\r# pivot_wider, values_fill\racoes %\u0026gt;% pivot_wider(\rid_cols = ano,\rnames_from = qdr,\rvalues_from = lucro,\rvalues_fill = 0\r)\r ## # A tibble: 2 x 5\r## ano `1` `2` `3` `4`\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1.88 0.59 0.35 NA ## 2 2016 0 0.92 0.17 2.66\r # complete, fill\racoes %\u0026gt;% complete(ano, qdr, fill = list(lucro = 0))\r ## # A tibble: 8 x 3\r## ano qdr lucro\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2015 1 1.88\r## 2 2015 2 0.59\r## 3 2015 3 0.35\r## 4 2015 4 0 ## 5 2016 1 0 ## 6 2016 2 0.92\r## 7 2016 3 0.17\r## 8 2016 4 2.66\r Note o resultado. E note também que values_fill em pivot_wider é um pouco mais criterioso na hora de fazer as transformações.\nstringr, forcats e dplyr library(nycflights13)\r   Encontre os vôos que:\n  Atrasaram mais de duas horas\n  flights %\u0026gt;% filter(dep_delay \u0026gt; 120)\r ## # A tibble: 9,723 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 848 1835 853 1001 1950\r## 2 2013 1 1 957 733 144 1056 853\r## 3 2013 1 1 1114 900 134 1447 1222\r## 4 2013 1 1 1540 1338 122 2020 1825\r## 5 2013 1 1 1815 1325 290 2120 1542\r## 6 2013 1 1 1842 1422 260 1958 1535\r## 7 2013 1 1 1856 1645 131 2212 2005\r## 8 2013 1 1 1934 1725 129 2126 1855\r## 9 2013 1 1 1938 1703 155 2109 1823\r## 10 2013 1 1 1942 1705 157 2124 1830\r## # ... with 9,713 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Com destino a Houston (IAH ou HOU)  flights %\u0026gt;% filter(dest %in% c(\u0026quot;IAH\u0026quot;, \u0026quot;HOU\u0026quot;))\r ## # A tibble: 9,313 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 623 627 -4 933 932\r## 4 2013 1 1 728 732 -4 1041 1038\r## 5 2013 1 1 739 739 0 1104 1038\r## 6 2013 1 1 908 908 0 1228 1219\r## 7 2013 1 1 1028 1026 2 1350 1339\r## 8 2013 1 1 1044 1045 -1 1352 1351\r## 9 2013 1 1 1114 900 134 1447 1222\r## 10 2013 1 1 1205 1200 5 1503 1505\r## # ... with 9,303 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Operados pela United, American ou Delta  unique(flights$carrier)\r ## [1] \u0026quot;UA\u0026quot; \u0026quot;AA\u0026quot; \u0026quot;B6\u0026quot; \u0026quot;DL\u0026quot; \u0026quot;EV\u0026quot; \u0026quot;MQ\u0026quot; \u0026quot;US\u0026quot; \u0026quot;WN\u0026quot; \u0026quot;VX\u0026quot; \u0026quot;FL\u0026quot; \u0026quot;AS\u0026quot; \u0026quot;9E\u0026quot; \u0026quot;F9\u0026quot; \u0026quot;HA\u0026quot; \u0026quot;YV\u0026quot;\r## [16] \u0026quot;OO\u0026quot;\r flights %\u0026gt;% filter(carrier %in% c(\u0026quot;UA\u0026quot;, \u0026quot;AA\u0026quot;, \u0026quot;DL\u0026quot;))\r ## # A tibble: 139,504 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 554 600 -6 812 837\r## 5 2013 1 1 554 558 -4 740 728\r## 6 2013 1 1 558 600 -2 753 745\r## 7 2013 1 1 558 600 -2 924 917\r## 8 2013 1 1 558 600 -2 923 937\r## 9 2013 1 1 559 600 -1 941 910\r## 10 2013 1 1 559 600 -1 854 902\r## # ... with 139,494 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre julho e setembro  flights %\u0026gt;% filter(between(month, 7, 9))\r ## # A tibble: 86,326 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 7 1 1 2029 212 236 2359\r## 2 2013 7 1 2 2359 3 344 344\r## 3 2013 7 1 29 2245 104 151 1\r## 4 2013 7 1 43 2130 193 322 14\r## 5 2013 7 1 44 2150 174 300 100\r## 6 2013 7 1 46 2051 235 304 2358\r## 7 2013 7 1 48 2001 287 308 2305\r## 8 2013 7 1 58 2155 183 335 43\r## 9 2013 7 1 100 2146 194 327 30\r## 10 2013 7 1 100 2245 135 337 135\r## # ... with 86,316 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Chegaram com mais de duas horas de atraso, mas não decolaram com atraso  flights %\u0026gt;% filter(arr_delay \u0026gt; 120, dep_delay \u0026lt;= 0)\r ## # A tibble: 29 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 27 1419 1420 -1 1754 1550\r## 2 2013 10 7 1350 1350 0 1736 1526\r## 3 2013 10 7 1357 1359 -2 1858 1654\r## 4 2013 10 16 657 700 -3 1258 1056\r## 5 2013 11 1 658 700 -2 1329 1015\r## 6 2013 3 18 1844 1847 -3 39 2219\r## 7 2013 4 17 1635 1640 -5 2049 1845\r## 8 2013 4 18 558 600 -2 1149 850\r## 9 2013 4 18 655 700 -5 1213 950\r## 10 2013 5 22 1827 1830 -3 2217 2010\r## # ... with 19 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Atrasaram mais de uma hora para decolar, mas recuperaram mais de 30 minutos durante o voo  flights %\u0026gt;% filter(dep_delay \u0026gt; 60, dep_delay - arr_delay \u0026gt;= 30)\r ## # A tibble: 2,046 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 1716 1545 91 2140 2039\r## 2 2013 1 1 2205 1720 285 46 2040\r## 3 2013 1 1 2326 2130 116 131 18\r## 4 2013 1 3 1503 1221 162 1803 1555\r## 5 2013 1 3 1821 1530 171 2131 1910\r## 6 2013 1 3 1839 1700 99 2056 1950\r## 7 2013 1 3 1850 1745 65 2148 2120\r## 8 2013 1 3 1923 1815 68 2036 1958\r## 9 2013 1 3 1941 1759 102 2246 2139\r## 10 2013 1 3 1950 1845 65 2228 2227\r## # ... with 2,036 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Decolaram entre a meia-noite e 6 da manhã (inclusive)  flights %\u0026gt;% filter(between(hour, 0, 5) | (hour == 6 \u0026amp; minute == 0))\r ## # A tibble: 8,970 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 8,960 more rows, and 11 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Reordene suas colunas para encontrar os voos mais rápidos (maior velocidade de voo).  flights %\u0026gt;% select(air_time, distance) %\u0026gt;% mutate(speed = distance/air_time) %\u0026gt;% arrange(desc(speed))\r ## # A tibble: 336,776 x 3\r## air_time distance speed\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 65 762 11.7 ## 2 93 1008 10.8 ## 3 55 594 10.8 ## 4 70 748 10.7 ## 5 105 1035 9.86\r## 6 170 1598 9.4 ## 7 172 1598 9.29\r## 8 175 1623 9.27\r## 9 173 1598 9.24\r## 10 173 1598 9.24\r## # ... with 336,766 more rows\r Teste várias maneiras diferentes de selecionar as variáveis dep_time, dep_delay, arr_time e arr_delay usando as várias helper functions de select.  flights %\u0026gt;% select(dep_time, dep_delay, arr_time, arr_delay)\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(\u0026quot;dep\u0026quot;), starts_with(\u0026quot;arr\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(starts_with(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(matches(\u0026quot;^arr|^dep\u0026quot;))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(!starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;car\u0026quot;)) \u0026amp; contains(c(\u0026quot;dep\u0026quot;, \u0026quot;arr\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time dep_delay arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 2 830 11\r## 2 533 4 850 20\r## 3 542 2 923 33\r## 4 544 -1 1004 -18\r## 5 554 -6 812 -25\r## 6 554 -4 740 12\r## 7 555 -5 913 19\r## 8 557 -3 709 -14\r## 9 557 -3 838 -8\r## 10 558 -2 753 8\r## # ... with 336,766 more rows\r flights %\u0026gt;% select(ends_with(c(\u0026quot;time\u0026quot;, \u0026quot;delay\u0026quot;)) \u0026amp; !starts_with(c(\u0026quot;sched\u0026quot;, \u0026quot;air\u0026quot;)))\r ## # A tibble: 336,776 x 4\r## dep_time arr_time dep_delay arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 830 2 11\r## 2 533 850 4 20\r## 3 542 923 2 33\r## 4 544 1004 -1 -18\r## 5 554 812 -6 -25\r## 6 554 740 -4 12\r## 7 555 913 -5 19\r## 8 557 709 -3 -14\r## 9 557 838 -3 -8\r## 10 558 753 -2 8\r## # ... with 336,766 more rows\r As variáveis dep_time e sched_dep_time estão num formato incorreto (veja ?flights). Converta-as com mutate para um valor em minutos passados desde a meia-noite. Dica: utilize %/% e %%.  flights %\u0026gt;% mutate(\rdep_hour = dep_time %/% 100,\rdep_minute = dep_time %% 100,\rsched_dep_hour = sched_dep_time %/% 100,\rsched_arr_minute = sched_arr_time %% 100\r)\r ## # A tibble: 336,776 x 23\r## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830 819\r## 2 2013 1 1 533 529 4 850 830\r## 3 2013 1 1 542 540 2 923 850\r## 4 2013 1 1 544 545 -1 1004 1022\r## 5 2013 1 1 554 600 -6 812 837\r## 6 2013 1 1 554 558 -4 740 728\r## 7 2013 1 1 555 600 -5 913 854\r## 8 2013 1 1 557 600 -3 709 723\r## 9 2013 1 1 557 600 -3 838 846\r## 10 2013 1 1 558 600 -2 753 745\r## # ... with 336,766 more rows, and 15 more variables: arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;,\r## # dep_hour \u0026lt;dbl\u0026gt;, dep_minute \u0026lt;dbl\u0026gt;, sched_dep_hour \u0026lt;dbl\u0026gt;,\r## # sched_arr_minute \u0026lt;dbl\u0026gt;\r # Há uma outra solução com separate!\rflights %\u0026gt;% separate(\rcol = dep_time,\rinto = c(\u0026quot;dep_hour\u0026quot;, \u0026quot;dep_minute\u0026quot;),\rsep = 1,\r# Esse argumento é importante! Teste com FALSE para ver a diferença\rconvert = TRUE) %\u0026gt;% separate(\rcol = sched_dep_time,\rinto = c(\u0026quot;sched_dep_hour\u0026quot;, \u0026quot;sched_dep_minute\u0026quot;),\rsep = 1,\rconvert = TRUE)\r ## # A tibble: 336,776 x 21\r## year month day dep_hour dep_minute sched_dep_hour sched_dep_minute\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 5 17 5 15\r## 2 2013 1 1 5 33 5 29\r## 3 2013 1 1 5 42 5 40\r## 4 2013 1 1 5 44 5 45\r## 5 2013 1 1 5 54 6 0\r## 6 2013 1 1 5 54 5 58\r## 7 2013 1 1 5 55 6 0\r## 8 2013 1 1 5 57 6 0\r## 9 2013 1 1 5 57 6 0\r## 10 2013 1 1 5 58 6 0\r## # ... with 336,766 more rows, and 14 more variables: dep_delay \u0026lt;dbl\u0026gt;,\r## # arr_time \u0026lt;int\u0026gt;, sched_arr_time \u0026lt;int\u0026gt;, arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r Existe uma outra solução possível para essa questão usando manipulação de strings, com str_sub também. Fica como desafio!\nPensando na legibilidade do código e na flexibilidade da abordagem, qual das duas soluções acima você implementaria? mutate ou duas separate? Reflita.\nO que o código abaixo está fazendo? Porque mesmo após o código abaixo continuam existindo diferenças entre os valores das variáveis air_time e travel_time?  flights %\u0026gt;% select(air_time, dep_time, arr_time, dep_delay, arr_delay) %\u0026gt;% mutate(dep_hour = dep_time %/% 100,\rdep_min = dep_time %% 100,\rdep_time2 = dep_hour * 60 + dep_min,\rarr_hour = arr_time %/% 100,\rarr_min = arr_time %% 100,\rarr_time2 = arr_hour * 60 + arr_min,\rtravel_time = arr_time2 - dep_time2) %\u0026gt;% select(-dep_hour, -dep_min, -arr_hour, -arr_min)\r ## # A tibble: 336,776 x 8\r## air_time dep_time arr_time dep_delay arr_delay dep_time2 arr_time2\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 227 517 830 2 11 317 510\r## 2 227 533 850 4 20 333 530\r## 3 160 542 923 2 33 342 563\r## 4 183 544 1004 -1 -18 344 604\r## 5 116 554 812 -6 -25 354 492\r## 6 150 554 740 -4 12 354 460\r## 7 158 555 913 -5 19 355 553\r## 8 53 557 709 -3 -14 357 429\r## 9 140 557 838 -3 -8 357 518\r## 10 138 558 753 -2 8 358 473\r## # ... with 336,766 more rows, and 1 more variable: travel_time \u0026lt;dbl\u0026gt;\r Essa tem uma resposta mais qualitativa. A primeira parte é parecida com a questão anterior, mas estamos manualmente tentando calcular os tempos de viagem. Acontece que os valores não batem com os tempos de vôo identificados no banco. Isso se deve a pelo menos três questões distintas.\n Uma delas diz respeito ao registro dos tempos, a definição de air_time pode não estar considerando tempos em que o avião está manobrando ou em solo ou mesmo podem existir erros de preenchimento. A segunda diz respeito ao fuso horário distinto entre aeroportos de saída e chegada, que complica o cálculo dos tempos reais, então nosso cálculo está muito cru para identificar isso. A última questão são os vôos longos, que começam em um dia e terminam no dia seguinte, que podem prejudicar nosso método de cálculo. Para corrigir alguns desses problemas, você precisaria escrever um código que minimamente levasse essas questões em consideração. Como esse não é o objetivo do curso, eu deixo para quem quiser tentar. Há uma solução postada aqui.  Use o stringr para concatenar as seguintes strings em uma frase  x \u0026lt;- \u0026quot;.\u0026quot;\ry \u0026lt;- \u0026quot;feliz\u0026quot;\rw \u0026lt;- \u0026quot;acordei\u0026quot;\rz \u0026lt;- \u0026quot;hoje\u0026quot;\rstr_c(z, w, y, sep = \u0026quot; \u0026quot;) %\u0026gt;% str_c(x, sep = \u0026quot;\u0026quot;) %\u0026gt;% str_to_sentence()\r ## [1] \u0026quot;Hoje acordei feliz.\u0026quot;\r Corrija as inconsistências nas colunas país, primeiro_nome, segundo_nome e crie uma nova coluna nomes contendo as duas anteriores. No final, ordene o banco em ordem alfabética.  df \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\r# Sem dplyr\rdf$pais \u0026lt;- str_to_title(df$pais)\rdf$primeiro_nome \u0026lt;- str_to_title(df$primeiro_nome)\rdf$segundo_nome \u0026lt;- str_to_title(df$segundo_nome)\rdf \u0026lt;- df %\u0026gt;% tidyr::unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;)\rdf[ str_order(df$nomes), ]\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r # Com dplyr\rdf \u0026lt;- tibble::tribble(\r~pais, ~primeiro_nome, ~segundo_nome,\r# -------|----------------|-------------|\r\u0026quot;BRASIL\u0026quot;, \u0026quot;ISABELA\u0026quot;, \u0026quot;MARTINS\u0026quot;,\r\u0026quot;Brasil\u0026quot;, \u0026quot;Eduardo\u0026quot;, \u0026quot;cabellos\u0026quot;,\r\u0026quot;brasil\u0026quot;, \u0026quot;márcia\u0026quot;, \u0026quot;pinto\u0026quot;,\r\u0026quot;bRaSiL\u0026quot;, \u0026quot;rogério\u0026quot;, \u0026quot;Marinho\u0026quot;,\r)\rdf %\u0026gt;% mutate(pais = str_to_title(pais),\rprimeiro_nome = str_to_title(primeiro_nome),\rsegundo_nome = str_to_title(segundo_nome)) %\u0026gt;% unite(nomes, primeiro_nome, segundo_nome, sep = \u0026quot; \u0026quot;) %\u0026gt;% arrange(str_order(nomes))\r ## # A tibble: 4 x 2\r## pais nomes ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Brasil Eduardo Cabellos\r## 2 Brasil Isabela Martins ## 3 Brasil Márcia Pinto ## 4 Brasil Rogério Marinho\r Transforme a string c(\u0026quot;Seu nome\u0026quot;, \u0026quot;Seu sobrenome da mãe\u0026quot;, \u0026quot;Seu sobrenome do pai\u0026quot;) na string \u0026quot;SEU SOBRENOME DO PAI, sua inicial do nome. sua inicial da mãe.\u0026quot;, como numa citação. Veja o exemplo abaixo:  # Transforme\rc(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\r ## [1] \u0026quot;Vinícius\u0026quot; \u0026quot;de Souza\u0026quot; \u0026quot;Maia\u0026quot;\r # Resultado\r\u0026quot;MAIA, V. S.\u0026quot;\r ## [1] \u0026quot;MAIA, V. S.\u0026quot;\r x \u0026lt;- c(\u0026quot;Vinícius\u0026quot;, \u0026quot;de Souza\u0026quot;, \u0026quot;Maia\u0026quot;)\rx[1] \u0026lt;- str_sub(x[1], 1, 1) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[2] \u0026lt;- str_sub(x[2], 4, 4) %\u0026gt;% str_c(\u0026quot;.\u0026quot;)\rx[3] \u0026lt;- str_to_upper(x[3])\rstr_c(c(x[3], x[1], x[2]), collapse = \u0026quot; \u0026quot;)\r ## [1] \u0026quot;MAIA V. S.\u0026quot;\r DESAFIO: Nos microdados da área de saúde, é comum que a variável idade esteja registrada da seguinte forma: \u0026ldquo;150\u0026rdquo;, \u0026ldquo;219\u0026rdquo;, \u0026ldquo;312\u0026rdquo;, \u0026ldquo;471\u0026rdquo;. Esses códigos indicam primeiro qual a unidade de medida da idade e segundo o valor desta unidade, 1 = horas, 2 = dias, 3 = meses, 4 = anos. Proponha um código usando stringr para transformar o vetor abaixo em um valor numérico.  # Não precisa se preocupar com essa parte\rx \u0026lt;- as.character(round(c(\rrunif(25, 100, 124),\rrunif(25, 201, 230),\rrunif(25, 301, 312),\rrunif(25, 401, 499)\r)))\r# Como você transformaria esse vetor em número?\rx\r ## [1] \u0026quot;118\u0026quot; \u0026quot;114\u0026quot; \u0026quot;118\u0026quot; \u0026quot;120\u0026quot; \u0026quot;109\u0026quot; \u0026quot;104\u0026quot; \u0026quot;114\u0026quot; \u0026quot;117\u0026quot; \u0026quot;122\u0026quot; \u0026quot;109\u0026quot; \u0026quot;110\u0026quot; \u0026quot;113\u0026quot;\r## [13] \u0026quot;106\u0026quot; \u0026quot;100\u0026quot; \u0026quot;122\u0026quot; \u0026quot;121\u0026quot; \u0026quot;124\u0026quot; \u0026quot;124\u0026quot; \u0026quot;110\u0026quot; \u0026quot;100\u0026quot; \u0026quot;117\u0026quot; \u0026quot;119\u0026quot; \u0026quot;105\u0026quot; \u0026quot;118\u0026quot;\r## [25] \u0026quot;122\u0026quot; \u0026quot;201\u0026quot; \u0026quot;205\u0026quot; \u0026quot;212\u0026quot; \u0026quot;216\u0026quot; \u0026quot;228\u0026quot; \u0026quot;213\u0026quot; \u0026quot;227\u0026quot; \u0026quot;221\u0026quot; \u0026quot;214\u0026quot; \u0026quot;227\u0026quot; \u0026quot;206\u0026quot;\r## [37] \u0026quot;207\u0026quot; \u0026quot;215\u0026quot; \u0026quot;224\u0026quot; \u0026quot;223\u0026quot; \u0026quot;203\u0026quot; \u0026quot;221\u0026quot; \u0026quot;215\u0026quot; \u0026quot;225\u0026quot; \u0026quot;210\u0026quot; \u0026quot;208\u0026quot; \u0026quot;219\u0026quot; \u0026quot;207\u0026quot;\r## [49] \u0026quot;221\u0026quot; \u0026quot;227\u0026quot; \u0026quot;310\u0026quot; \u0026quot;305\u0026quot; \u0026quot;301\u0026quot; \u0026quot;304\u0026quot; \u0026quot;310\u0026quot; \u0026quot;307\u0026quot; \u0026quot;305\u0026quot; \u0026quot;309\u0026quot; \u0026quot;308\u0026quot; \u0026quot;306\u0026quot;\r## [61] \u0026quot;308\u0026quot; \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;303\u0026quot; \u0026quot;306\u0026quot; \u0026quot;302\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;301\u0026quot; \u0026quot;310\u0026quot; \u0026quot;306\u0026quot; \u0026quot;304\u0026quot;\r## [73] \u0026quot;305\u0026quot; \u0026quot;304\u0026quot; \u0026quot;307\u0026quot; \u0026quot;401\u0026quot; \u0026quot;459\u0026quot; \u0026quot;429\u0026quot; \u0026quot;435\u0026quot; \u0026quot;435\u0026quot; \u0026quot;415\u0026quot; \u0026quot;475\u0026quot; \u0026quot;414\u0026quot; \u0026quot;419\u0026quot;\r## [85] \u0026quot;495\u0026quot; \u0026quot;475\u0026quot; \u0026quot;431\u0026quot; \u0026quot;460\u0026quot; \u0026quot;478\u0026quot; \u0026quot;447\u0026quot; \u0026quot;436\u0026quot; \u0026quot;412\u0026quot; \u0026quot;403\u0026quot; \u0026quot;423\u0026quot; \u0026quot;467\u0026quot; \u0026quot;438\u0026quot;\r## [97] \u0026quot;475\u0026quot; \u0026quot;467\u0026quot; \u0026quot;418\u0026quot; \u0026quot;476\u0026quot;\r # Esse exercício é um pouco mais difícil mesmo!\rx %\u0026gt;% str_extract(\u0026quot;\\\\d\u0026quot;)\r ## [1] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot;\r## [19] \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot;\r## [37] \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [55] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot;\r## [73] \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r## [91] \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot; \u0026quot;4\u0026quot;\r tibble(\rtipo_idade = str_sub(x, 1, 1),\ridade = str_sub(x, 2, 3),\ridade_anos =\rif_else(\rstr_detect(tipo_idade, \u0026quot;1\u0026quot;),\ras.numeric(idade) / (24 * 30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;2\u0026quot;),\ras.numeric(idade) / (30 * 12),\rif_else(\rstr_detect(tipo_idade, \u0026quot;3\u0026quot;),\ras.numeric(idade) / 12,\ras.numeric(idade)\r)\r)\r)\r) %\u0026gt;% print(n = Inf)\r ## # A tibble: 100 x 3\r## tipo_idade idade idade_anos\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 18 0.00208 ## 2 1 14 0.00162 ## 3 1 18 0.00208 ## 4 1 20 0.00231 ## 5 1 09 0.00104 ## 6 1 04 0.000463\r## 7 1 14 0.00162 ## 8 1 17 0.00197 ## 9 1 22 0.00255 ## 10 1 09 0.00104 ## 11 1 10 0.00116 ## 12 1 13 0.00150 ## 13 1 06 0.000694\r## 14 1 00 0 ## 15 1 22 0.00255 ## 16 1 21 0.00243 ## 17 1 24 0.00278 ## 18 1 24 0.00278 ## 19 1 10 0.00116 ## 20 1 00 0 ## 21 1 17 0.00197 ## 22 1 19 0.00220 ## 23 1 05 0.000579\r## 24 1 18 0.00208 ## 25 1 22 0.00255 ## 26 2 01 0.00278 ## 27 2 05 0.0139 ## 28 2 12 0.0333 ## 29 2 16 0.0444 ## 30 2 28 0.0778 ## 31 2 13 0.0361 ## 32 2 27 0.075 ## 33 2 21 0.0583 ## 34 2 14 0.0389 ## 35 2 27 0.075 ## 36 2 06 0.0167 ## 37 2 07 0.0194 ## 38 2 15 0.0417 ## 39 2 24 0.0667 ## 40 2 23 0.0639 ## 41 2 03 0.00833 ## 42 2 21 0.0583 ## 43 2 15 0.0417 ## 44 2 25 0.0694 ## 45 2 10 0.0278 ## 46 2 08 0.0222 ## 47 2 19 0.0528 ## 48 2 07 0.0194 ## 49 2 21 0.0583 ## 50 2 27 0.075 ## 51 3 10 0.833 ## 52 3 05 0.417 ## 53 3 01 0.0833 ## 54 3 04 0.333 ## 55 3 10 0.833 ## 56 3 07 0.583 ## 57 3 05 0.417 ## 58 3 09 0.75 ## 59 3 08 0.667 ## 60 3 06 0.5 ## 61 3 08 0.667 ## 62 3 05 0.417 ## 63 3 04 0.333 ## 64 3 03 0.25 ## 65 3 06 0.5 ## 66 3 02 0.167 ## 67 3 10 0.833 ## 68 3 06 0.5 ## 69 3 01 0.0833 ## 70 3 10 0.833 ## 71 3 06 0.5 ## 72 3 04 0.333 ## 73 3 05 0.417 ## 74 3 04 0.333 ## 75 3 07 0.583 ## 76 4 01 1 ## 77 4 59 59 ## 78 4 29 29 ## 79 4 35 35 ## 80 4 35 35 ## 81 4 15 15 ## 82 4 75 75 ## 83 4 14 14 ## 84 4 19 19 ## 85 4 95 95 ## 86 4 75 75 ## 87 4 31 31 ## 88 4 60 60 ## 89 4 78 78 ## 90 4 47 47 ## 91 4 36 36 ## 92 4 12 12 ## 93 4 03 3 ## 94 4 23 23 ## 95 4 67 67 ## 96 4 38 38 ## 97 4 75 75 ## 98 4 67 67 ## 99 4 18 18 ## 100 4 76 76\r Ao invés de utilizar essas chamadas recursivas de if_else, que são muito ruins de ler, como você poderia reescrever a condição usando case_when?\nExplore as contagens da variável rincome em gss_cat, ela ficaria bem representada num gráfico? De qual tipo?  gss_cat %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r Em geral, contagens de variáveis ficam bem em gráficos de barras ou visualizações equivalentes, em que é possível comparar visualmente as contagens das diversas categorias. Mais sobre isso na aula do ggplot2.\nQual a religião mais comum em gss_cat? Qual o partido (partyid) mais popular?  # Religião\rgss_cat %\u0026gt;% count(relig) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 15 x 2\r## relig n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Protestant 10846\r## 2 Catholic 5124\r## 3 None 3523\r## 4 Christian 689\r## 5 Jewish 388\r## 6 Other 224\r## 7 Buddhism 147\r## 8 Inter-nondenominational 109\r## 9 Moslem/islam 104\r## 10 Orthodox-christian 95\r## 11 No answer 93\r## 12 Hinduism 71\r## 13 Other eastern 32\r## 14 Native american 23\r## 15 Don't know 15\r # Partido\rgss_cat %\u0026gt;% count(partyid) %\u0026gt;% arrange(desc(n))\r ## # A tibble: 10 x 2\r## partyid n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Independent 4119\r## 2 Not str democrat 3690\r## 3 Strong democrat 3490\r## 4 Not str republican 3032\r## 5 Ind,near dem 2499\r## 6 Strong republican 2314\r## 7 Ind,near rep 1791\r## 8 Other party 393\r## 9 No answer 154\r## 10 Don't know 1\r A que religião se refere a variável denom? Você pode descobrir isso fazendo uma tabela de contagens?  Você pode chamar count com várias variáveis para fazer uma tabulação cruzada.\ngss_cat %\u0026gt;% count(relig, denom) %\u0026gt;% print(n = Inf)\r ## # A tibble: 47 x 3\r## relig denom n\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer No answer 93\r## 2 Don't know Not applicable 15\r## 3 Inter-nondenominational Not applicable 109\r## 4 Native american Not applicable 23\r## 5 Christian No answer 2\r## 6 Christian Don't know 11\r## 7 Christian No denomination 452\r## 8 Christian Not applicable 224\r## 9 Orthodox-christian Not applicable 95\r## 10 Moslem/islam Not applicable 104\r## 11 Other eastern Not applicable 32\r## 12 Hinduism Not applicable 71\r## 13 Buddhism Not applicable 147\r## 14 Other No denomination 7\r## 15 Other Not applicable 217\r## 16 None Not applicable 3523\r## 17 Jewish Not applicable 388\r## 18 Catholic Not applicable 5124\r## 19 Protestant No answer 22\r## 20 Protestant Don't know 41\r## 21 Protestant No denomination 1224\r## 22 Protestant Other 2534\r## 23 Protestant Episcopal 397\r## 24 Protestant Presbyterian-dk wh 244\r## 25 Protestant Presbyterian, merged 67\r## 26 Protestant Other presbyterian 47\r## 27 Protestant United pres ch in us 110\r## 28 Protestant Presbyterian c in us 104\r## 29 Protestant Lutheran-dk which 267\r## 30 Protestant Evangelical luth 122\r## 31 Protestant Other lutheran 30\r## 32 Protestant Wi evan luth synod 71\r## 33 Protestant Lutheran-mo synod 212\r## 34 Protestant Luth ch in america 71\r## 35 Protestant Am lutheran 146\r## 36 Protestant Methodist-dk which 239\r## 37 Protestant Other methodist 33\r## 38 Protestant United methodist 1067\r## 39 Protestant Afr meth ep zion 32\r## 40 Protestant Afr meth episcopal 77\r## 41 Protestant Baptist-dk which 1457\r## 42 Protestant Other baptists 213\r## 43 Protestant Southern baptist 1536\r## 44 Protestant Nat bapt conv usa 40\r## 45 Protestant Nat bapt conv of am 76\r## 46 Protestant Am bapt ch in usa 130\r## 47 Protestant Am baptist asso 237\r Como você poderia diminuir o número de categorias da variável rincome do banco gss_cat?  A melhor função para redução de fatores é fct_collapse. Veja como ficam a coluna original e a transformada.\ngss_cat2 \u0026lt;- gss_cat %\u0026gt;% # Aqui vou salvar em \u0026quot;rincome2\u0026quot; para a gente poder ver as duas\rmutate(rincome2 = fct_collapse(\rrincome,\r\u0026quot;Non-response\u0026quot; = c(\u0026quot;No answer\u0026quot;, \u0026quot;Don't know\u0026quot;, \u0026quot;Refused\u0026quot;, \u0026quot;Not applicable\u0026quot;),\r\u0026quot;Até 5k\u0026quot; = c(\u0026quot;$4000 to 4999\u0026quot;, \u0026quot;$3000 to 3999\u0026quot;, \u0026quot;$1000 to 2999\u0026quot;, \u0026quot;Lt $1000\u0026quot;),\r\u0026quot;5k-10k\u0026quot; = c( \u0026quot;$8000 to 9999\u0026quot;, \u0026quot;$7000 to 7999\u0026quot;, \u0026quot;$6000 to 6999\u0026quot;, \u0026quot;$5000 to 5999\u0026quot;),\r\u0026quot;10k-20k\u0026quot; = c(\u0026quot;$15000 - 19999\u0026quot;, \u0026quot;$10000 - 14999\u0026quot;),\r\u0026quot;20k+\u0026quot; = c(\u0026quot;$25000 or more\u0026quot;, \u0026quot;$20000 - 24999\u0026quot;))) %\u0026gt;% select(rincome, rincome2)\r# E veja as contagens\rgss_cat2 %\u0026gt;% count(rincome)\r ## # A tibble: 16 x 2\r## rincome n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 No answer 183\r## 2 Don't know 267\r## 3 Refused 975\r## 4 $25000 or more 7363\r## 5 $20000 - 24999 1283\r## 6 $15000 - 19999 1048\r## 7 $10000 - 14999 1168\r## 8 $8000 to 9999 340\r## 9 $7000 to 7999 188\r## 10 $6000 to 6999 215\r## 11 $5000 to 5999 227\r## 12 $4000 to 4999 226\r## 13 $3000 to 3999 276\r## 14 $1000 to 2999 395\r## 15 Lt $1000 286\r## 16 Not applicable 7043\r gss_cat2 %\u0026gt;% count(rincome2)\r ## # A tibble: 5 x 2\r## rincome2 n\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 Non-response 8468\r## 2 20k+ 8646\r## 3 10k-20k 2216\r## 4 5k-10k 970\r## 5 Até 5k 1183\r ggplot2  O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?  ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \u0026quot;blue\u0026quot;))\r Os pontos não ficam azuis porque você não está especificando cores! Dentro da função aes() você está especificando variáveis para serem mapeadas a uma escala de cores. Portanto, o ggplot interpreta \u0026ldquo;blue\u0026rdquo; como uma variável sem nome que tem o valor \u0026ldquo;blue\u0026rdquo; e mapeia ela para a escala de cores padrão, que é vermelha. Se você quer controlar apenas a \u0026ldquo;aparência\u0026rdquo; dos pontos e não está preocupada em mapear nenhuma variável, você pode passar essa estética fora da função aes().\nggplot(data = mpg) + geom_point(\rmapping = aes(x = displ, y = hwy), # aqui acabam os mapeamentos estéticos\rcolor = \u0026quot;blue\u0026quot;, # alteração apenas na aparência do geom\rsize = 2, # alteração apenas na aparência do geom\rshape = 6 # alteração apenas na aparência do geom\r)  Utilizando o banco mpg, faça o diagrama de dispersão de displ por hwy e mapeie a cor para class, o tamanho para cyl e a forma para manufacturer. Como esses atributos estéticos se comportam diferente para variáveis categóricas vs contínuas?  ggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point()\r ## Warning: The shape palette can deal with a maximum of 6 discrete values because\r## more than 6 becomes difficult to discriminate; you have 15. Consider\r## specifying shapes manually if you must have them.\r ## Warning: Removed 112 rows containing missing values (geom_point).\r Ao cumprir as instruções como dadas, logo de cara você recebe um aviso do ggplot2. A paleta de \u0026ldquo;shapes\u0026rdquo; só recebe por padrão 6 shapes diferentes, porque de acordo com o autor, mais de 6 torna difícil de distinguir. Mas eu sou teimoso.\nggplot(mpg, aes(\rdispl, hwy, color = class, size = cyl,\rshape = manufacturer)) +\rgeom_point() +\rscale_shape_manual(values = 1:15, guide = \u0026quot;legend\u0026quot;)\r Esse gráfico é mais um exemplo para vocês verem como diferentes escalas se comportam. A variável cyl é numérica e ordenada, então faz sentido colocá-la num mapeamento como size, já que visualmente é possível indicar que a grandeza aumenta com o tamanho. Classe é uma variável categórica, então ela fica melhor em mapeamentos que ressaltam diferenças entre as categorias, como colors ou shapes. O pacote também impõe algumas restrições sobre o que é possível mapear. Por exemplo, ele retorna erro se você tenta mapear uma variável discreta para uma escala contínua.\nggplot(mpg, aes(displ, hwy, color = class)) +\rgeom_point() +\rscale_color_continuous()\r ## Error: Discrete value supplied to continuous scale\r Experimentem tentar mapear diferentes variáveis no banco mpg para as diferentes escalas e vejam os resultados. Em alguns casos, é possível, mas o gráfico é pouco informativo, em outros, você verá mensagens de erro.\nUtilizando o diamonds, crie um diagrama de dispersão que relacione carat com price. Explore algumas outras variáveis utilizando escalas de cor para ver se você identifica algum padrão. Aplique transformações nas variáveis que você considerar justificadas.  Esse exercício não tem uma resposta correta. O objetivo era que vocês explorassem as transformações estatísticas e as escalas de cores diferentes presentes no ggplot, através do argumento trans, ou mesmo fazer outras transformações que interessassem vocês nas variáveis. Abaixo um exemplo de transformação de Yeo-Johnson, um tipo de transformação BoxCox que aceita valores negativos e uma das escalas de cor do pacote viridis.\nggplot(diamonds, aes(carat, price, color = clarity)) +\rgeom_point() +\rscale_x_continuous(trans = scales::yj_trans(p = 2)) +\rscale_color_viridis_d(option = \u0026quot;magma\u0026quot;)\r Ainda continuando o exemplo anterior, aplique um geom_smooth utilizando várias opções de method para as variáveis originais ou transformadas.  Segundo a mesma lógica, o objetivo era explorar as opções de visualização de modelos simples através do argumento method. Abaixo um exemplo de gam. Uma mudança que fiz foi usar a variável cut ao invés de clarity, porque o gráfico não-transformado de clarity estava muito poluído.\nggplot(diamonds, aes(carat, price, color = cut)) +\rgeom_point(alpha = 0.1) + # pontos translúcidos para reduzir a poluição\rgeom_smooth(method = \u0026quot;gam\u0026quot;, se = FALSE) +\rscale_color_viridis_d(option = \u0026quot;plasma\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ s(x, bs = \u0026quot;cs\u0026quot;)'\r No nosso gráfico de barras usando stat(prop) a gente precisou colocar group = 1, porque? Qual é a diferença entre esses dois códigos?  ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\r ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))\r Acabei explicando isso na aula, devido a uma pergunta, mas para quem perdeu, trata-se do comportamento padrão quando há proporções: cada barra terá sua própria proporção e todas somarão a 100%. O uso de group = 1 indica à função que as proporções que somam a 100% são o total dos níveis do fator e não cada nível individualmente.\nggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = after_stat(prop), group = 1))\r # No caso em que há um \u0026quot;fill\u0026quot;, precisamos normalizar as alturas das barras\rggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(prop),\rfill = clarity\r))\r ggplot(data = diamonds) +\rgeom_bar(mapping = aes(\rx = cut,\ry = stat(count)/sum(stat(count)),\rfill = clarity\r))\r stat_smooth é muito parecido com geom_smooth, mas há uma diferença sutil. Compare os códigos abaixo.  geom_smooth chama stat_smooth quando você utiliza a função para calcular as \u0026ldquo;médias condicionais\u0026rdquo; que correspondem a linha de tendência desenhada no gráfico. É assim com todos os geoms no pacote. Há uma conexão entre o objeto geométrico e uma transformação estatística. Mesmo que seja a transformação _identity, que mantém a variável exatamente como ela estava no dado. A grande vantagem de construir um gráfico com stat_smooth ao invés de geom_smooth é que você pode especificar outro objeto geométrico que não seja o padrão (geom_line + geom_ribbon). É isso que os gráficos abaixo demonstram.\nggplot(mpg, aes(displ, hwy)) + geom_point() +\rgeom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;step\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;linerange\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;errorbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot(mpg, aes(displ, hwy)) + geom_point() +\rstat_smooth(geom = \u0026quot;crossbar\u0026quot;)\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Usando o mpg e facet_grid, crie um scatterplot que contenha displ no eixo x, hwy no eixo y, class na cor, drv nas facetas-coluna e cyl nas facetas linha.  Esse aqui é para demonstrar o uso de facet_grid, que permite especificar fatores de classificação diferentes nas linhas e colunas, diferente de facet_wrap mostrado na aula, que só permite especificar uma dimensão.\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\rgeom_point() +\rfacet_grid(cyl ~ drv)\r Você acha que os dois gráficos abaixo ficarão diferentes um do outro? Porque? Tente responder antes de rodar o código.  ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\r ## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\r Mesmo antes de rodar o código, o observador astuto notará que os mapeamentos locais no segundo gráfico são idênticos entre si e aos mapeamentos globais, então os dois gráficos são iguais.\nTente recriar o seguinte gráfico  O objetivo dessa era fazer vocês fuçarem um pouco na ajuda para tentar recriar o mais fielmente possível o gráfico final. Não precisava ter acertado, o objetivo era chegar o mais próximo possível.\nggplot(mpg, aes(displ, hwy, color = drv)) +\rgeom_point() +\rgeom_smooth(method = lm, se = FALSE) +\rlabs(x = \u0026quot;Rodovia\u0026quot;, y = \u0026quot;Toneladas\u0026quot;, color = \u0026quot;Tração\u0026quot;) +\rscale_color_brewer(palette = \u0026quot;Set1\u0026quot;)\r ## `geom_smooth()` using formula 'y ~ x'\r Transforme o gráfico seguir em um gráfico de pizza usando coord_polar.  ggplot(diamonds, aes(cut, fill = cut)) +\rgeom_bar()\r Depois de simplesmente especificar coord_polar, em geral o gráfico fica meio estranho, não tem aquela cara bonita de pizza. É preciso corrigir os seguintes problemas:\n A largura das barras deve ser igual a proporção das contagens, mas a altura deve ser igual a 1! Portanto, eu inverto as coisas e passo as contagens/proporções para \u0026ldquo;x\u0026rdquo; e \u0026ldquo;y\u0026rdquo; fica com o valor fixo = 1.  ggplot(diamonds, aes(\r# calculando as proporções do total,\r# também funciona com o padrão stat(count)\rx = stat(count)/sum(stat(count)),\ry = 1, # altura igual a 1\rfill = cut)) + # cores\rgeom_bar() +\rcoord_polar() + # coordenadas polares\r# opcional: remover aspectos do tema para um visual mais clean\rtheme_void()\r Como desafio, tentem adicionar elementos textuais das proporções no gráfico. O problema a ser resolvido é como posicionar o texto num sistema de coordenadas polares. Boa sorte!\nGráficos de pizza são polêmicos na análise de dados porque nossos olhos não captam bem diferenças entre formatos curvos e complexos, então a comparação entre as categorias fica prejudicada se houverem mais de 2 ou 3. Eu sempre dou preferência para barras. Há um tipo de gráfico de pizza melhorzinho chamado \u0026ldquo;donut plot\u0026rdquo;, em que o meio do círculo é oco, mas eu ainda prefiro as barras.\npurrr  Utilize uma das funções map_ para:  Nos exemplos abaixo, eu utilizo sempre str() no final para facilitar a visualização das listas, mas não é obrigatório utilizar esse comando.\n1. Calcular a média de cada coluna em `mtcars`.\r map(mtcars, mean) %\u0026gt;% str()\r ## List of 11\r## $ mpg : num 20.1\r## $ cyl : num 6.19\r## $ disp: num 231\r## $ hp : num 147\r## $ drat: num 3.6\r## $ wt : num 3.22\r## $ qsec: num 17.8\r## $ vs : num 0.438\r## $ am : num 0.406\r## $ gear: num 3.69\r## $ carb: num 2.81\r 2. Determinar o tipo de cada coluna em `flights`.\r flights %\u0026gt;% map(class) %\u0026gt;% str()\r ## List of 19\r## $ year : chr \u0026quot;integer\u0026quot;\r## $ month : chr \u0026quot;integer\u0026quot;\r## $ day : chr \u0026quot;integer\u0026quot;\r## $ dep_time : chr \u0026quot;integer\u0026quot;\r## $ sched_dep_time: chr \u0026quot;integer\u0026quot;\r## $ dep_delay : chr \u0026quot;numeric\u0026quot;\r## $ arr_time : chr \u0026quot;integer\u0026quot;\r## $ sched_arr_time: chr \u0026quot;integer\u0026quot;\r## $ arr_delay : chr \u0026quot;numeric\u0026quot;\r## $ carrier : chr \u0026quot;character\u0026quot;\r## $ flight : chr \u0026quot;integer\u0026quot;\r## $ tailnum : chr \u0026quot;character\u0026quot;\r## $ origin : chr \u0026quot;character\u0026quot;\r## $ dest : chr \u0026quot;character\u0026quot;\r## $ air_time : chr \u0026quot;numeric\u0026quot;\r## $ distance : chr \u0026quot;numeric\u0026quot;\r## $ hour : chr \u0026quot;numeric\u0026quot;\r## $ minute : chr \u0026quot;numeric\u0026quot;\r## $ time_hour : chr [1:2] \u0026quot;POSIXct\u0026quot; \u0026quot;POSIXt\u0026quot;\r 3. Computar o número de valores únicos em cada coluna de `iris`.\r flights %\u0026gt;% map(unique) %\u0026gt;% map(length) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r # Sugestão do Pedro Gomes\rflights %\u0026gt;% map(n_distinct) %\u0026gt;% str()\r ## List of 19\r## $ year : int 1\r## $ month : int 12\r## $ day : int 31\r## $ dep_time : int 1319\r## $ sched_dep_time: int 1021\r## $ dep_delay : int 528\r## $ arr_time : int 1412\r## $ sched_arr_time: int 1163\r## $ arr_delay : int 578\r## $ carrier : int 16\r## $ flight : int 3844\r## $ tailnum : int 4044\r## $ origin : int 3\r## $ dest : int 105\r## $ air_time : int 510\r## $ distance : int 214\r## $ hour : int 20\r## $ minute : int 60\r## $ time_hour : int 6936\r 4. Gere 10 distribuições aleatórias (`rnorm`) com médias -10, 0, 10 e 100.\r x \u0026lt;- rep(100, 40)\rmedias \u0026lt;- rep(c(-10, 0, 10, 100), each = 10)\rmap2(x, medias, ~rnorm(.x, mean = .y)) %\u0026gt;% str()\r ## List of 40\r## $ : num [1:100] -9.96 -9.53 -9.12 -9.64 -10.36 ...\r## $ : num [1:100] -11.71 -10.76 -9.41 -9.22 -10.53 ...\r## $ : num [1:100] -11.33 -9.51 -8.98 -10.91 -9.52 ...\r## $ : num [1:100] -11.4 -10.9 -10.7 -12.1 -9.8 ...\r## $ : num [1:100] -11.06 -10.66 -10.33 -9.13 -9.13 ...\r## $ : num [1:100] -10.22 -9.59 -9.81 -10.71 -10.24 ...\r## $ : num [1:100] -11 -9.14 -10.91 -9.38 -9.63 ...\r## $ : num [1:100] -9.83 -9.61 -11.23 -9.68 -10.47 ...\r## $ : num [1:100] -9.11 -10.03 -10.62 -9.65 -10.2 ...\r## $ : num [1:100] -9.06 -10.41 -10.84 -9.16 -9.41 ...\r## $ : num [1:100] -0.8378 0.1102 0.7519 -0.2477 0.0342 ...\r## $ : num [1:100] 0.607 -0.902 -2.185 -0.397 -1.019 ...\r## $ : num [1:100] -0.452 2.067 1.45 -1.184 0.893 ...\r## $ : num [1:100] -0.604 -0.783 1.767 -0.632 1.322 ...\r## $ : num [1:100] -2.515 0.43 0.694 1.239 1.091 ...\r## $ : num [1:100] -1.462 1.177 -0.376 0.037 0.387 ...\r## $ : num [1:100] -0.0803 -0.0421 2.4765 0.0509 -0.1479 ...\r## $ : num [1:100] 1.118 0.662 -1.439 -1.074 0.493 ...\r## $ : num [1:100] -0.3136 0.4455 -0.947 2.0658 -0.0188 ...\r## $ : num [1:100] 0.193 0.625 2.281 0.297 -0.629 ...\r## $ : num [1:100] 9.29 9.1 9.54 9.99 10.2 ...\r## $ : num [1:100] 7.96 7.32 10.7 9.13 10.3 ...\r## $ : num [1:100] 9.96 10.24 10.31 10.54 11.65 ...\r## $ : num [1:100] 10.88 10.41 8.19 10.37 10.28 ...\r## $ : num [1:100] 11.27 9.74 11.75 11.7 9.31 ...\r## $ : num [1:100] 9.62 11.35 10.78 10.79 9.7 ...\r## $ : num [1:100] 9.04 10.24 11.85 9.82 10.66 ...\r## $ : num [1:100] 10.48 6.97 8.97 9.69 11.03 ...\r## $ : num [1:100] 8.48 10.12 9.09 8.18 10.11 ...\r## $ : num [1:100] 9.97 9.27 10.19 10.93 11.07 ...\r## $ : num [1:100] 100 99.2 99.6 100.3 99.2 ...\r## $ : num [1:100] 99 99.9 100.7 98.7 99.7 ...\r## $ : num [1:100] 99.6 99.2 100.1 100 99.9 ...\r## $ : num [1:100] 100.5 100.4 100.2 98.4 98.9 ...\r## $ : num [1:100] 99.8 99.8 100 99.1 101.1 ...\r## $ : num [1:100] 100.7 100 100.1 98.6 100 ...\r## $ : num [1:100] 99 99.4 100.5 100.1 99.3 ...\r## $ : num [1:100] 99.2 98.6 99.2 100.9 97.4 ...\r## $ : num [1:100] 99.7 99.8 100.9 100.5 99.9 ...\r## $ : num [1:100] 99.5 100.9 98.5 99.7 100 ...\r Como você pode criar um vetor indicando se cada coluna em um data.frame é um fator?  # Flights por exemplo\rflights %\u0026gt;% # Lembrem-se que a pergunta pedia para criar um vetor!\rmap_lgl(is.factor)\r ## year month day dep_time sched_dep_time ## FALSE FALSE FALSE FALSE FALSE ## dep_delay arr_time sched_arr_time arr_delay carrier ## FALSE FALSE FALSE FALSE FALSE ## flight tailnum origin dest air_time ## FALSE FALSE FALSE FALSE FALSE ## distance hour minute time_hour ## FALSE FALSE FALSE FALSE\r  Usando as funções predicado keep e discard:\n Selecione todas as colunas caractere no banco flights.    flights %\u0026gt;% keep(is.character)\r ## # A tibble: 336,776 x 4\r## carrier tailnum origin dest ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 UA N14228 EWR IAH ## 2 UA N24211 LGA IAH ## 3 AA N619AA JFK MIA ## 4 B6 N804JB JFK BQN ## 5 DL N668DN LGA ATL ## 6 UA N39463 EWR ORD ## 7 B6 N516JB EWR FLL ## 8 EV N829AS LGA IAD ## 9 B6 N593JB JFK MCO ## 10 AA N3ALAA LGA ORD ## # ... with 336,766 more rows\r 2. Descarte os caracteres em `mpg`.\r mpg %\u0026gt;% discard(is.character)\r ## # A tibble: 234 x 5\r## displ year cyl cty hwy\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 1.8 1999 4 18 29\r## 2 1.8 1999 4 21 29\r## 3 2 2008 4 20 31\r## 4 2 2008 4 21 30\r## 5 2.8 1999 6 16 26\r## 6 2.8 1999 6 18 26\r## 7 3.1 2008 6 18 27\r## 8 1.8 1999 4 18 26\r## 9 1.8 1999 4 16 25\r## 10 2 2008 4 20 28\r## # ... with 224 more rows\r 3. Selecione os fatores ordenados em `diamonds`.\r diamonds %\u0026gt;% keep(is.ordered)\r ## # A tibble: 53,940 x 3\r## cut color clarity\r## \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; ## 1 Ideal E SI2 ## 2 Premium E SI1 ## 3 Good E VS1 ## 4 Premium I VS2 ## 5 Good J SI2 ## 6 Very Good J VVS2 ## 7 Very Good I VVS1 ## 8 Very Good H SI1 ## 9 Fair E VS2 ## 10 Very Good H VS1 ## # ... with 53,930 more rows\r 4. Descarte as variáveis não-numéricas em `iris`\r iris %\u0026gt;% discard(negate(is.numeric))\r ## Sepal.Length Sepal.Width Petal.Length Petal.Width\r## 1 5.1 3.5 1.4 0.2\r## 2 4.9 3.0 1.4 0.2\r## 3 4.7 3.2 1.3 0.2\r## 4 4.6 3.1 1.5 0.2\r## 5 5.0 3.6 1.4 0.2\r## 6 5.4 3.9 1.7 0.4\r## 7 4.6 3.4 1.4 0.3\r## 8 5.0 3.4 1.5 0.2\r## 9 4.4 2.9 1.4 0.2\r## 10 4.9 3.1 1.5 0.1\r## 11 5.4 3.7 1.5 0.2\r## 12 4.8 3.4 1.6 0.2\r## 13 4.8 3.0 1.4 0.1\r## 14 4.3 3.0 1.1 0.1\r## 15 5.8 4.0 1.2 0.2\r## 16 5.7 4.4 1.5 0.4\r## 17 5.4 3.9 1.3 0.4\r## 18 5.1 3.5 1.4 0.3\r## 19 5.7 3.8 1.7 0.3\r## 20 5.1 3.8 1.5 0.3\r## 21 5.4 3.4 1.7 0.2\r## 22 5.1 3.7 1.5 0.4\r## 23 4.6 3.6 1.0 0.2\r## 24 5.1 3.3 1.7 0.5\r## 25 4.8 3.4 1.9 0.2\r## 26 5.0 3.0 1.6 0.2\r## 27 5.0 3.4 1.6 0.4\r## 28 5.2 3.5 1.5 0.2\r## 29 5.2 3.4 1.4 0.2\r## 30 4.7 3.2 1.6 0.2\r## 31 4.8 3.1 1.6 0.2\r## 32 5.4 3.4 1.5 0.4\r## 33 5.2 4.1 1.5 0.1\r## 34 5.5 4.2 1.4 0.2\r## 35 4.9 3.1 1.5 0.2\r## 36 5.0 3.2 1.2 0.2\r## 37 5.5 3.5 1.3 0.2\r## 38 4.9 3.6 1.4 0.1\r## 39 4.4 3.0 1.3 0.2\r## 40 5.1 3.4 1.5 0.2\r## 41 5.0 3.5 1.3 0.3\r## 42 4.5 2.3 1.3 0.3\r## 43 4.4 3.2 1.3 0.2\r## 44 5.0 3.5 1.6 0.6\r## 45 5.1 3.8 1.9 0.4\r## 46 4.8 3.0 1.4 0.3\r## 47 5.1 3.8 1.6 0.2\r## 48 4.6 3.2 1.4 0.2\r## 49 5.3 3.7 1.5 0.2\r## 50 5.0 3.3 1.4 0.2\r## 51 7.0 3.2 4.7 1.4\r## 52 6.4 3.2 4.5 1.5\r## 53 6.9 3.1 4.9 1.5\r## 54 5.5 2.3 4.0 1.3\r## 55 6.5 2.8 4.6 1.5\r## 56 5.7 2.8 4.5 1.3\r## 57 6.3 3.3 4.7 1.6\r## 58 4.9 2.4 3.3 1.0\r## 59 6.6 2.9 4.6 1.3\r## 60 5.2 2.7 3.9 1.4\r## 61 5.0 2.0 3.5 1.0\r## 62 5.9 3.0 4.2 1.5\r## 63 6.0 2.2 4.0 1.0\r## 64 6.1 2.9 4.7 1.4\r## 65 5.6 2.9 3.6 1.3\r## 66 6.7 3.1 4.4 1.4\r## 67 5.6 3.0 4.5 1.5\r## 68 5.8 2.7 4.1 1.0\r## 69 6.2 2.2 4.5 1.5\r## 70 5.6 2.5 3.9 1.1\r## 71 5.9 3.2 4.8 1.8\r## 72 6.1 2.8 4.0 1.3\r## 73 6.3 2.5 4.9 1.5\r## 74 6.1 2.8 4.7 1.2\r## 75 6.4 2.9 4.3 1.3\r## 76 6.6 3.0 4.4 1.4\r## 77 6.8 2.8 4.8 1.4\r## 78 6.7 3.0 5.0 1.7\r## 79 6.0 2.9 4.5 1.5\r## 80 5.7 2.6 3.5 1.0\r## 81 5.5 2.4 3.8 1.1\r## 82 5.5 2.4 3.7 1.0\r## 83 5.8 2.7 3.9 1.2\r## 84 6.0 2.7 5.1 1.6\r## 85 5.4 3.0 4.5 1.5\r## 86 6.0 3.4 4.5 1.6\r## 87 6.7 3.1 4.7 1.5\r## 88 6.3 2.3 4.4 1.3\r## 89 5.6 3.0 4.1 1.3\r## 90 5.5 2.5 4.0 1.3\r## 91 5.5 2.6 4.4 1.2\r## 92 6.1 3.0 4.6 1.4\r## 93 5.8 2.6 4.0 1.2\r## 94 5.0 2.3 3.3 1.0\r## 95 5.6 2.7 4.2 1.3\r## 96 5.7 3.0 4.2 1.2\r## 97 5.7 2.9 4.2 1.3\r## 98 6.2 2.9 4.3 1.3\r## 99 5.1 2.5 3.0 1.1\r## 100 5.7 2.8 4.1 1.3\r## 101 6.3 3.3 6.0 2.5\r## 102 5.8 2.7 5.1 1.9\r## 103 7.1 3.0 5.9 2.1\r## 104 6.3 2.9 5.6 1.8\r## 105 6.5 3.0 5.8 2.2\r## 106 7.6 3.0 6.6 2.1\r## 107 4.9 2.5 4.5 1.7\r## 108 7.3 2.9 6.3 1.8\r## 109 6.7 2.5 5.8 1.8\r## 110 7.2 3.6 6.1 2.5\r## 111 6.5 3.2 5.1 2.0\r## 112 6.4 2.7 5.3 1.9\r## 113 6.8 3.0 5.5 2.1\r## 114 5.7 2.5 5.0 2.0\r## 115 5.8 2.8 5.1 2.4\r## 116 6.4 3.2 5.3 2.3\r## 117 6.5 3.0 5.5 1.8\r## 118 7.7 3.8 6.7 2.2\r## 119 7.7 2.6 6.9 2.3\r## 120 6.0 2.2 5.0 1.5\r## 121 6.9 3.2 5.7 2.3\r## 122 5.6 2.8 4.9 2.0\r## 123 7.7 2.8 6.7 2.0\r## 124 6.3 2.7 4.9 1.8\r## 125 6.7 3.3 5.7 2.1\r## 126 7.2 3.2 6.0 1.8\r## 127 6.2 2.8 4.8 1.8\r## 128 6.1 3.0 4.9 1.8\r## 129 6.4 2.8 5.6 2.1\r## 130 7.2 3.0 5.8 1.6\r## 131 7.4 2.8 6.1 1.9\r## 132 7.9 3.8 6.4 2.0\r## 133 6.4 2.8 5.6 2.2\r## 134 6.3 2.8 5.1 1.5\r## 135 6.1 2.6 5.6 1.4\r## 136 7.7 3.0 6.1 2.3\r## 137 6.3 3.4 5.6 2.4\r## 138 6.4 3.1 5.5 1.8\r## 139 6.0 3.0 4.8 1.8\r## 140 6.9 3.1 5.4 2.1\r## 141 6.7 3.1 5.6 2.4\r## 142 6.9 3.1 5.1 2.3\r## 143 5.8 2.7 5.1 1.9\r## 144 6.8 3.2 5.9 2.3\r## 145 6.7 3.3 5.7 2.5\r## 146 6.7 3.0 5.2 2.3\r## 147 6.3 2.5 5.0 1.9\r## 148 6.5 3.0 5.2 2.0\r## 149 6.2 3.4 5.4 2.3\r## 150 5.9 3.0 5.1 1.8\r Imagine que você tem um diretório cheio de arquivos .csv que correspondem a um único banco de dados. Você tem os caminhos de todos eles num vetor com a forma c(arquivo_1.csv, ..., arquivo_n.csv). Como você importaria esses arquivos? Tente fazer duas soluções diferentes.  # Vamos usar um diretório temporário que vamos preencher com vários tibbles\rpasta \u0026lt;- tempdir()\r# Criamos 100 tibbles e guardamos em 100 arquivos csv.\rx \u0026lt;- rep(10, 100)\rarqs \u0026lt;- sprintf(\u0026quot;arquivo%s.csv\u0026quot;, 1:100)\rmap(x, ~tibble(var1 = rnorm(.x), var2 = rnorm(.x))) %\u0026gt;% map2(arqs, ~write_csv(.x, file.path(pasta, .y))) %\u0026gt;% str()\r # Nossos arquivos estão salvos no diretório temporário:\rdir(pasta)\r ## [1] \u0026quot;arquivo1.csv\u0026quot; \u0026quot;arquivo10.csv\u0026quot; \u0026quot;arquivo100.csv\u0026quot; \u0026quot;arquivo11.csv\u0026quot; ## [5] \u0026quot;arquivo12.csv\u0026quot; \u0026quot;arquivo13.csv\u0026quot; \u0026quot;arquivo14.csv\u0026quot; \u0026quot;arquivo15.csv\u0026quot; ## [9] \u0026quot;arquivo16.csv\u0026quot; \u0026quot;arquivo17.csv\u0026quot; \u0026quot;arquivo18.csv\u0026quot; \u0026quot;arquivo19.csv\u0026quot; ## [13] \u0026quot;arquivo2.csv\u0026quot; \u0026quot;arquivo20.csv\u0026quot; \u0026quot;arquivo21.csv\u0026quot; \u0026quot;arquivo22.csv\u0026quot; ## [17] \u0026quot;arquivo23.csv\u0026quot; \u0026quot;arquivo24.csv\u0026quot; \u0026quot;arquivo25.csv\u0026quot; \u0026quot;arquivo26.csv\u0026quot; ## [21] \u0026quot;arquivo27.csv\u0026quot; \u0026quot;arquivo28.csv\u0026quot; \u0026quot;arquivo29.csv\u0026quot; \u0026quot;arquivo3.csv\u0026quot; ## [25] \u0026quot;arquivo30.csv\u0026quot; \u0026quot;arquivo31.csv\u0026quot; \u0026quot;arquivo32.csv\u0026quot; \u0026quot;arquivo33.csv\u0026quot; ## [29] \u0026quot;arquivo34.csv\u0026quot; \u0026quot;arquivo35.csv\u0026quot; \u0026quot;arquivo36.csv\u0026quot; \u0026quot;arquivo37.csv\u0026quot; ## [33] \u0026quot;arquivo38.csv\u0026quot; \u0026quot;arquivo39.csv\u0026quot; \u0026quot;arquivo4.csv\u0026quot; \u0026quot;arquivo40.csv\u0026quot; ## [37] \u0026quot;arquivo41.csv\u0026quot; \u0026quot;arquivo42.csv\u0026quot; \u0026quot;arquivo43.csv\u0026quot; \u0026quot;arquivo44.csv\u0026quot; ## [41] \u0026quot;arquivo45.csv\u0026quot; \u0026quot;arquivo46.csv\u0026quot; \u0026quot;arquivo47.csv\u0026quot; \u0026quot;arquivo48.csv\u0026quot; ## [45] \u0026quot;arquivo49.csv\u0026quot; \u0026quot;arquivo5.csv\u0026quot; \u0026quot;arquivo50.csv\u0026quot; \u0026quot;arquivo51.csv\u0026quot; ## [49] \u0026quot;arquivo52.csv\u0026quot; \u0026quot;arquivo53.csv\u0026quot; \u0026quot;arquivo54.csv\u0026quot; \u0026quot;arquivo55.csv\u0026quot; ## [53] \u0026quot;arquivo56.csv\u0026quot; \u0026quot;arquivo57.csv\u0026quot; \u0026quot;arquivo58.csv\u0026quot; \u0026quot;arquivo59.csv\u0026quot; ## [57] \u0026quot;arquivo6.csv\u0026quot; \u0026quot;arquivo60.csv\u0026quot; \u0026quot;arquivo61.csv\u0026quot; \u0026quot;arquivo62.csv\u0026quot; ## [61] \u0026quot;arquivo63.csv\u0026quot; \u0026quot;arquivo64.csv\u0026quot; \u0026quot;arquivo65.csv\u0026quot; \u0026quot;arquivo66.csv\u0026quot; ## [65] \u0026quot;arquivo67.csv\u0026quot; \u0026quot;arquivo68.csv\u0026quot; \u0026quot;arquivo69.csv\u0026quot; \u0026quot;arquivo7.csv\u0026quot; ## [69] \u0026quot;arquivo70.csv\u0026quot; \u0026quot;arquivo71.csv\u0026quot; \u0026quot;arquivo72.csv\u0026quot; \u0026quot;arquivo73.csv\u0026quot; ## [73] \u0026quot;arquivo74.csv\u0026quot; \u0026quot;arquivo75.csv\u0026quot; \u0026quot;arquivo76.csv\u0026quot; \u0026quot;arquivo77.csv\u0026quot; ## [77] \u0026quot;arquivo78.csv\u0026quot; \u0026quot;arquivo79.csv\u0026quot; \u0026quot;arquivo8.csv\u0026quot; \u0026quot;arquivo80.csv\u0026quot; ## [81] \u0026quot;arquivo81.csv\u0026quot; \u0026quot;arquivo82.csv\u0026quot; \u0026quot;arquivo83.csv\u0026quot; \u0026quot;arquivo84.csv\u0026quot; ## [85] \u0026quot;arquivo85.csv\u0026quot; \u0026quot;arquivo86.csv\u0026quot; \u0026quot;arquivo87.csv\u0026quot; \u0026quot;arquivo88.csv\u0026quot; ## [89] \u0026quot;arquivo89.csv\u0026quot; \u0026quot;arquivo9.csv\u0026quot; \u0026quot;arquivo90.csv\u0026quot; \u0026quot;arquivo91.csv\u0026quot; ## [93] \u0026quot;arquivo92.csv\u0026quot; \u0026quot;arquivo93.csv\u0026quot; \u0026quot;arquivo94.csv\u0026quot; \u0026quot;arquivo95.csv\u0026quot; ## [97] \u0026quot;arquivo96.csv\u0026quot; \u0026quot;arquivo97.csv\u0026quot; \u0026quot;arquivo98.csv\u0026quot; \u0026quot;arquivo99.csv\u0026quot; ## [101] \u0026quot;filecf810bd36a5\u0026quot; \u0026quot;filecf81149221d\u0026quot; \u0026quot;filecf81164e23\u0026quot; \u0026quot;filecf8161f65f7\u0026quot;\r## [105] \u0026quot;filecf8171030fd\u0026quot; \u0026quot;filecf819e43f49\u0026quot; \u0026quot;filecf81ad26a9f\u0026quot; \u0026quot;filecf81bed9f1\u0026quot; ## [109] \u0026quot;filecf81e7a7e68\u0026quot; \u0026quot;filecf81ef03542\u0026quot; \u0026quot;filecf81fa64a3e\u0026quot; \u0026quot;filecf8239d75ab\u0026quot;\r## [113] \u0026quot;filecf8261936\u0026quot; \u0026quot;filecf826d55378\u0026quot; \u0026quot;filecf8291061a0\u0026quot; \u0026quot;filecf82b985019\u0026quot;\r## [117] \u0026quot;filecf82c00737b\u0026quot; \u0026quot;filecf8339f5\u0026quot; \u0026quot;filecf8341e67d6\u0026quot; \u0026quot;filecf8344158ac\u0026quot;\r## [121] \u0026quot;filecf837a47cc7\u0026quot; \u0026quot;filecf837f15510\u0026quot; \u0026quot;filecf8387a3d29\u0026quot; \u0026quot;filecf83a71232b\u0026quot;\r## [125] \u0026quot;filecf83ac3253a\u0026quot; \u0026quot;filecf83af94598\u0026quot; \u0026quot;filecf83f794f64\u0026quot; \u0026quot;filecf8402156c1\u0026quot;\r## [129] \u0026quot;filecf840c15566\u0026quot; \u0026quot;filecf84163761c\u0026quot; \u0026quot;filecf841d3b53\u0026quot; \u0026quot;filecf844d5642\u0026quot; ## [133] \u0026quot;filecf845e73bac\u0026quot; \u0026quot;filecf8462819d6\u0026quot; \u0026quot;filecf84b8b3144\u0026quot; \u0026quot;filecf84ddc73a0\u0026quot;\r## [137] \u0026quot;filecf84fe515d4\u0026quot; \u0026quot;filecf8500a5a10\u0026quot; \u0026quot;filecf8512766ea\u0026quot; \u0026quot;filecf852fe119b\u0026quot;\r## [141] \u0026quot;filecf8550a39d\u0026quot; \u0026quot;filecf85b14fec\u0026quot; \u0026quot;filecf85e053c83\u0026quot; \u0026quot;filecf85e6a12f4\u0026quot;\r## [145] \u0026quot;filecf8639c6053\u0026quot; \u0026quot;filecf863dc5f3b\u0026quot; \u0026quot;filecf8646e477f\u0026quot; \u0026quot;filecf865645c5d\u0026quot;\r## [149] \u0026quot;filecf868634c0d\u0026quot; \u0026quot;filecf869137c8a\u0026quot; \u0026quot;filecf86a7852d4\u0026quot; \u0026quot;filecf86b5b250\u0026quot; ## [153] \u0026quot;filecf86b9e3bb7\u0026quot; \u0026quot;filecf86d216ac\u0026quot; \u0026quot;filecf86e894a16\u0026quot; \u0026quot;filecf86ea916d3\u0026quot;\r## [157] \u0026quot;filecf86f22266\u0026quot; \u0026quot;filecf86f975377\u0026quot; \u0026quot;filecf8757a72be\u0026quot; \u0026quot;filecf876956e82\u0026quot;\r## [161] \u0026quot;filecf876967b1\u0026quot; \u0026quot;filecf8787a1370\u0026quot; \u0026quot;filecf879037c39\u0026quot; \u0026quot;filecf87964711\u0026quot; ## [165] \u0026quot;filecf87afe7046\u0026quot; \u0026quot;filecf88456ae0\u0026quot; \u0026quot;filecf898344ab\u0026quot;\r # Agora vamos ler todos de volta para uma tibble só.\rarqs \u0026lt;- dir(pasta, pattern = \u0026quot;.csv\u0026quot;, full.names = T)\r # Juntando linhas\rdf \u0026lt;- map_dfr(arqs, read_csv)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # Juntando colunas\rdf \u0026lt;- map_dfc(arqs, read_csv)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r # Usando reduce\r# linhas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_rows)\rdf\r ## # A tibble: 1,000 x 2\r## var1 var2\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554\r## 2 -1.12 1.08 ## 3 -0.821 1.21 ## 4 0.384 0.465\r## 5 0.885 0.477\r## 6 -0.194 0.517\r## 7 0.710 0.128\r## 8 -1.04 -0.947\r## 9 0.782 1.58 ## 10 0.571 0.990\r## # ... with 990 more rows\r # colunas\rdf \u0026lt;- map(arqs, read_csv) %\u0026gt;% reduce(bind_cols)\rdf\r ## # A tibble: 10 x 200\r## var1...1 var2...2 var1...3 var2...4 var1...5 var2...6 var1...7 var2...8\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.837 -0.554 -1.35 0.522 1.49 0.648 -0.567 -0.868\r## 2 -1.12 1.08 0.876 2.11 0.0449 0.0737 -0.808 0.177\r## 3 -0.821 1.21 1.77 -1.31 1.51 1.35 0.559 -0.119\r## 4 0.384 0.465 -0.496 1.10 1.13 -0.331 0.427 0.131\r## 5 0.885 0.477 -0.514 -0.573 -0.0704 0.581 0.751 0.629\r## 6 -0.194 0.517 0.362 -1.62 -0.725 -2.37 0.710 -0.293\r## 7 0.710 0.128 1.11 0.144 0.00462 1.66 1.32 -0.414\r## 8 -1.04 -0.947 0.00775 -1.27 0.0365 0.0813 -1.10 0.757\r## 9 0.782 1.58 0.695 -0.375 -0.342 0.341 -0.325 0.834\r## 10 0.571 0.990 -0.475 -0.356 -1.17 -0.827 -0.148 -1.29 ## # ... with 192 more variables: var1...9 \u0026lt;dbl\u0026gt;, var2...10 \u0026lt;dbl\u0026gt;,\r## # var1...11 \u0026lt;dbl\u0026gt;, var2...12 \u0026lt;dbl\u0026gt;, var1...13 \u0026lt;dbl\u0026gt;, var2...14 \u0026lt;dbl\u0026gt;,\r## # var1...15 \u0026lt;dbl\u0026gt;, var2...16 \u0026lt;dbl\u0026gt;, var1...17 \u0026lt;dbl\u0026gt;, var2...18 \u0026lt;dbl\u0026gt;,\r## # var1...19 \u0026lt;dbl\u0026gt;, var2...20 \u0026lt;dbl\u0026gt;, var1...21 \u0026lt;dbl\u0026gt;, var2...22 \u0026lt;dbl\u0026gt;,\r## # var1...23 \u0026lt;dbl\u0026gt;, var2...24 \u0026lt;dbl\u0026gt;, var1...25 \u0026lt;dbl\u0026gt;, var2...26 \u0026lt;dbl\u0026gt;,\r## # var1...27 \u0026lt;dbl\u0026gt;, var2...28 \u0026lt;dbl\u0026gt;, var1...29 \u0026lt;dbl\u0026gt;, var2...30 \u0026lt;dbl\u0026gt;,\r## # var1...31 \u0026lt;dbl\u0026gt;, var2...32 \u0026lt;dbl\u0026gt;, var1...33 \u0026lt;dbl\u0026gt;, var2...34 \u0026lt;dbl\u0026gt;,\r## # var1...35 \u0026lt;dbl\u0026gt;, var2...36 \u0026lt;dbl\u0026gt;, var1...37 \u0026lt;dbl\u0026gt;, var2...38 \u0026lt;dbl\u0026gt;,\r## # var1...39 \u0026lt;dbl\u0026gt;, var2...40 \u0026lt;dbl\u0026gt;, var1...41 \u0026lt;dbl\u0026gt;, var2...42 \u0026lt;dbl\u0026gt;,\r## # var1...43 \u0026lt;dbl\u0026gt;, var2...44 \u0026lt;dbl\u0026gt;, var1...45 \u0026lt;dbl\u0026gt;, var2...46 \u0026lt;dbl\u0026gt;,\r## # var1...47 \u0026lt;dbl\u0026gt;, var2...48 \u0026lt;dbl\u0026gt;, var1...49 \u0026lt;dbl\u0026gt;, var2...50 \u0026lt;dbl\u0026gt;,\r## # var1...51 \u0026lt;dbl\u0026gt;, var2...52 \u0026lt;dbl\u0026gt;, var1...53 \u0026lt;dbl\u0026gt;, var2...54 \u0026lt;dbl\u0026gt;,\r## # var1...55 \u0026lt;dbl\u0026gt;, var2...56 \u0026lt;dbl\u0026gt;, var1...57 \u0026lt;dbl\u0026gt;, var2...58 \u0026lt;dbl\u0026gt;,\r## # var1...59 \u0026lt;dbl\u0026gt;, var2...60 \u0026lt;dbl\u0026gt;, var1...61 \u0026lt;dbl\u0026gt;, var2...62 \u0026lt;dbl\u0026gt;,\r## # var1...63 \u0026lt;dbl\u0026gt;, var2...64 \u0026lt;dbl\u0026gt;, var1...65 \u0026lt;dbl\u0026gt;, var2...66 \u0026lt;dbl\u0026gt;,\r## # var1...67 \u0026lt;dbl\u0026gt;, var2...68 \u0026lt;dbl\u0026gt;, var1...69 \u0026lt;dbl\u0026gt;, var2...70 \u0026lt;dbl\u0026gt;,\r## # var1...71 \u0026lt;dbl\u0026gt;, var2...72 \u0026lt;dbl\u0026gt;, var1...73 \u0026lt;dbl\u0026gt;, var2...74 \u0026lt;dbl\u0026gt;,\r## # var1...75 \u0026lt;dbl\u0026gt;, var2...76 \u0026lt;dbl\u0026gt;, var1...77 \u0026lt;dbl\u0026gt;, var2...78 \u0026lt;dbl\u0026gt;,\r## # var1...79 \u0026lt;dbl\u0026gt;, var2...80 \u0026lt;dbl\u0026gt;, var1...81 \u0026lt;dbl\u0026gt;, var2...82 \u0026lt;dbl\u0026gt;,\r## # var1...83 \u0026lt;dbl\u0026gt;, var2...84 \u0026lt;dbl\u0026gt;, var1...85 \u0026lt;dbl\u0026gt;, var2...86 \u0026lt;dbl\u0026gt;,\r## # var1...87 \u0026lt;dbl\u0026gt;, var2...88 \u0026lt;dbl\u0026gt;, var1...89 \u0026lt;dbl\u0026gt;, var2...90 \u0026lt;dbl\u0026gt;,\r## # var1...91 \u0026lt;dbl\u0026gt;, var2...92 \u0026lt;dbl\u0026gt;, var1...93 \u0026lt;dbl\u0026gt;, var2...94 \u0026lt;dbl\u0026gt;,\r## # var1...95 \u0026lt;dbl\u0026gt;, var2...96 \u0026lt;dbl\u0026gt;, var1...97 \u0026lt;dbl\u0026gt;, var2...98 \u0026lt;dbl\u0026gt;,\r## # var1...99 \u0026lt;dbl\u0026gt;, var2...100 \u0026lt;dbl\u0026gt;, var1...101 \u0026lt;dbl\u0026gt;, var2...102 \u0026lt;dbl\u0026gt;,\r## # var1...103 \u0026lt;dbl\u0026gt;, var2...104 \u0026lt;dbl\u0026gt;, var1...105 \u0026lt;dbl\u0026gt;, var2...106 \u0026lt;dbl\u0026gt;,\r## # var1...107 \u0026lt;dbl\u0026gt;, var2...108 \u0026lt;dbl\u0026gt;, ...\r Escreva um código sucinto que implemente vários modelos lineares especificados por você. Salve os resultados numa tibble com colunas-lista. Depois, extraia os resultados com unnest(). Use o exemplo como guia.  mtcars\r ## mpg cyl disp hp drat wt qsec vs am gear carb\r## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4\r## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4\r## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1\r## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1\r## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2\r## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1\r## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4\r## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2\r## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2\r## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4\r## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4\r## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3\r## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3\r## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3\r## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4\r## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4\r## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4\r## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1\r## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2\r## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1\r## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1\r## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2\r## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2\r## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4\r## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2\r## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1\r## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2\r## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2\r## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4\r## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6\r## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8\r## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2\r modelos \u0026lt;- c(\u0026quot;mpg ~ wt\u0026quot;,\r\u0026quot;mpg ~ wt + cyl\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat\u0026quot;,\r\u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;)\r# Estou usando funções do pacote broom, mas você não era obrigado a apresentar\r# os resultados bonitinho. O objetivo era treinar esse tipo de workflow.\rmodelos_saida \u0026lt;- tibble(\respecificacao = modelos,\rajuste = map(especificacao, lm, data = mtcars),\rcoefs = map(ajuste, broom::tidy),\rstats = map(ajuste, broom::glance),\raums = map(ajuste, broom::augment)\r)\rmodelos_saida %\u0026gt;% select(especificacao, coefs) %\u0026gt;% unnest(coefs) %\u0026gt;% filter(term != \u0026quot;(Intercept)\u0026quot;)  ## # A tibble: 10 x 6\r## especificacao term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt wt -5.34 0.559 -9.56 1.29e-10\r## 2 mpg ~ wt + cyl wt -3.19 0.757 -4.22 2.22e- 4\r## 3 mpg ~ wt + cyl cyl -1.51 0.415 -3.64 1.06e- 3\r## 4 mpg ~ wt + cyl + drat wt -3.19 0.829 -3.85 6.24e- 4\r## 5 mpg ~ wt + cyl + drat cyl -1.51 0.446 -3.38 2.14e- 3\r## 6 mpg ~ wt + cyl + drat drat -0.0162 1.32 -0.0122 9.90e- 1\r## 7 mpg ~ wt + cyl + drat + am wt -3.13 0.932 -3.36 2.32e- 3\r## 8 mpg ~ wt + cyl + drat + am cyl -1.53 0.465 -3.28 2.88e- 3\r## 9 mpg ~ wt + cyl + drat + am drat -0.130 1.53 -0.0851 9.33e- 1\r## 10 mpg ~ wt + cyl + drat + am am 0.237 1.51 0.157 8.76e- 1\r modelos_saida %\u0026gt;% select(especificacao, stats) %\u0026gt;% unnest(stats)\r ## # A tibble: 4 x 13\r## especificacao r.squared adj.r.squared sigma statistic p.value df logLik\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt 0.753 0.745 3.05 91.4 1.29e-10 1 -80.0\r## 2 mpg ~ wt + cyl 0.830 0.819 2.57 70.9 6.81e-12 2 -74.0\r## 3 mpg ~ wt + cyl ~ 0.830 0.812 2.61 45.6 6.57e-11 3 -74.0\r## 4 mpg ~ wt + cyl ~ 0.830 0.805 2.66 33.0 4.84e-10 4 -74.0\r## # ... with 5 more variables: AIC \u0026lt;dbl\u0026gt;, BIC \u0026lt;dbl\u0026gt;, deviance \u0026lt;dbl\u0026gt;,\r## # df.residual \u0026lt;int\u0026gt;, nobs \u0026lt;int\u0026gt;\r modelos_saida %\u0026gt;% select(especificacao, aums) %\u0026gt;% filter(especificacao == \u0026quot;mpg ~ wt + cyl + drat + am\u0026quot;) %\u0026gt;% unnest(aums)\r ## # A tibble: 32 x 13\r## especificacao .rownames mpg wt cyl drat am .fitted .resid .hat\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 mpg ~ wt + cyl~ Mazda RX4 21 2.62 6 3.9 1 22.3 -1.35 0.0899\r## 2 mpg ~ wt + cyl~ Mazda RX~ 21 2.88 6 3.9 1 21.6 -0.550 0.0924\r## 3 mpg ~ wt + cyl~ Datsun 7~ 22.8 2.32 4 3.85 1 26.3 -3.55 0.137 ## 4 mpg ~ wt + cyl~ Hornet 4~ 21.4 3.22 6 3.08 0 20.4 1.05 0.113 ## 5 mpg ~ wt + cyl~ Hornet S~ 18.7 3.44 8 3.15 0 16.6 2.11 0.122 ## 6 mpg ~ wt + cyl~ Valiant 18.1 3.46 6 2.76 0 19.6 -1.53 0.207 ## 7 mpg ~ wt + cyl~ Duster 3~ 14.3 3.57 8 3.21 0 16.2 -1.87 0.103 ## 8 mpg ~ wt + cyl~ Merc 240D 24.4 3.19 4 3.69 0 23.4 0.996 0.189 ## 9 mpg ~ wt + cyl~ Merc 230 22.8 3.15 4 3.92 0 23.5 -0.700 0.207 ## 10 mpg ~ wt + cyl~ Merc 280 19.2 3.44 6 3.92 0 19.5 -0.340 0.149 ## # ... with 22 more rows, and 3 more variables: .sigma \u0026lt;dbl\u0026gt;, .cooksd \u0026lt;dbl\u0026gt;,\r## # .std.resid \u0026lt;dbl\u0026gt;\r ","date":1621900800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621900800,"objectID":"c1c74f268683837301969e7167daf1ed","permalink":"https://laddem.github.io/courses/tidyverse/solucoes/","publishdate":"2021-05-25T00:00:00Z","relpermalink":"/courses/tidyverse/solucoes/","section":"courses","summary":"Soluções dos exercícios","tags":null,"title":"Soluções","type":"book"},{"authors":["LADDEM"],"categories":null,"content":"\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://laddem.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot;\rif porridge == \u0026quot;blueberry\u0026quot;:\rprint(\u0026quot;Eating...\u0026quot;)\r  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}}\r{{% fragment %}} **Two** {{% /fragment %}}\r{{% fragment %}} Three {{% /fragment %}}\r Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}}\r- Only the speaker can read these notes\r- Press `S` key to view\r{{% /speaker_note %}}\r Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}}\r{{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}\r  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1,\r.reveal section h2,\r.reveal section h3 {\rcolor: navy;\r}\r  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://laddem.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://laddem.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["LADDEM","Robert Ford"],"categories":null,"content":"\rClick the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.\r\r\r\rCreate your slides in Markdown - click the Slides button to check out the example.\r\r\rSupplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://laddem.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://laddem.github.io/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]
>>>>>>> 108c8b8e414614fc9e167a7a8f19787d0ce47482
>>>>>>> Stashed changes
>>>>>>> 960358bf32ee0e3b63e41e67d0fe6242a69c883f
